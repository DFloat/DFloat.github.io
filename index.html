<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>글래스 컴뱃 아레나</title>
    <meta name="description" content="2D 브라우저 기반 전투 게임 - 중력 물리학, 글래스모피즘 UI, 봇 전투 시스템">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* 전역 CSS 재설정 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* body 스타일: 폰트, 배경, 오버플로우 숨김, 전체 화면 */
        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* 게임 캔버스 스타일: 절대 위치, 커서, 배경, 블러 전환 효과 */
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); /* 캔버스 배경도 동일하게 설정 */
            filter: blur(10px); /* 초기 블러 효과 */
            transition: filter 0.5s ease; /* 블러 전환 애니메이션 */
            display: block; /* 항상 보이도록 설정 */
        }
        
        /* 글래스 카드 스타일: 배경 흐림, 테두리, 그림자 */
        .glass-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            color: #fff;
        }
        
        /* HUD (Head-Up Display) 스타일: 왼쪽 상단 고정, flexbox로 내부 요소 정렬 */
        .hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            pointer-events: none;
            z-index: 10;
            display: none;
            flex-direction: row;
            gap: 18px;
            justify-content: center;
            align-items: flex-start;
            padding: 12px 0 0 0;
        }
        
        /* HUD 내부 아이템 스타일: 상호작용 가능 */
        .hud-item {
            pointer-events: auto;
            margin: 0 4px;
            min-width: 170px;
            max-width: 260px;
        }
        
        /* 체력/탄약 바 스타일 */
        .health-bar, .ammo-bar {
            width: 150px;
            height: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            overflow: hidden;
            margin: 8px 0;
        }
        
        /* 체력 바 채우기 스타일: 그라데이션, 너비 전환 효과 */
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ef4444, #f87171);
            transition: width 0.3s ease;
        }
        
        /* 탄약 바 채우기 스타일: 그라데이션, 너비 전환 효과 */
        .ammo-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #60a5fa);
            transition: width 0.3s ease;
        }
        
        /* 스탯 텍스트 스타일 */
        .stats {
            color: white;
            font-size: 14px;
            font-weight: 500;
        }
        
        /* 점수 텍스트 스타일 */
        .score {
            color: white;
            font-size: 20px;
            font-weight: bold;
            text-align: center;
        }
        
        /* 웨이브 텍스트 스타일 */
        .wave {
            color: white;
            font-size: 16px;
            font-weight: 600;
            text-align: center;
            margin-top: 8px;
        }
        
        /* 조작법 텍스트 스타일 */
        .controls {
            color: white;
            font-size: 12px;
        }
        
        /* 조작 키 표시 스타일 */
        .control-key {
            background: rgba(255, 255, 255, 0.1);
            padding: 4px 8px;
            border-radius: 4px;
            margin: 2px;
            display: inline-block;
        }
        
        /* 게임 메시지 컨테이너 스타일 */
        .message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
        }
        
        /* 게임 메시지 주 텍스트 스타일 */
        .message-text {
            color: white;
            font-size: 32px;
            font-weight: bold;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        /* 게임 메시지 보조 텍스트 스타일 */
        .message-sub {
            color: rgba(255, 255, 255, 0.8);
            font-size: 18px;
            text-align: center;
            margin-top: 8px;
        }
        
        /* 깜빡임 애니메이션 */
        .animate-pulse {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* 미니맵 스타일 */
        .minimap {
            width: 120px;
            height: 120px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            position: relative;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        /* 미니맵 플레이어 도트 스타일 */
        .minimap-player {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #3b82f6;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        /* 미니맵 적 도트 스타일 */
        .minimap-enemy {
            position: absolute;
            width: 3px;
            height: 3px;
            background: #ef4444;
            border-radius: 50%;
        }
        
        /* 미니맵 아이템 도트 스타일 */
        .minimap-item {
            position: absolute;
            width: 2px;
            height: 2px;
            background: #fbbf24;
            border-radius: 50%;
        }

        /* 시작 화면 스타일 */
        #startScreen {
            position: absolute; /* 캔버스 위에 오버레이 */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 101; /* HUD보다 높게 설정 */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
            padding: 40px;
        }

        #startScreen h1 {
            font-size: 4em;
            margin-bottom: 20px;
            text-shadow: 0 0 15px rgba(255,255,255,0.5);
        }

        #startScreen p {
            font-size: 1.2em;
            margin-bottom: 30px;
            opacity: 0.8;
        }

        #startButton {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            padding: 15px 30px;
            font-size: 1.5em;
            font-weight: 600;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        #startButton:hover {
            background: rgba(255, 255, 255, 0.3);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
            transform: translateY(-2px);
        }

        #startButton:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        /* 보상 선택 화면 스타일 */
        #rewardSelectionScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200; /* 가장 위에 표시 */
            display: none; /* 초기에는 숨김 */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
            padding: 30px;
        }

        #rewardSelectionScreen h2 {
            font-size: 2.5em;
            margin-bottom: 25px;
            text-shadow: 0 0 10px rgba(255,255,255,0.4);
        }

        .reward-options {
            display: flex;
            gap: 20px;
            flex-wrap: wrap; /* 작은 화면에서 줄바꿈 */
            justify-content: center;
        }

        .reward-button {
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.25);
            border-radius: 12px;
            padding: 20px 25px;
            font-size: 1.2em;
            font-weight: bold;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(8px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
            min-width: 180px;
        }

        .reward-button:hover {
            background: rgba(255, 255, 255, 0.25);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.25);
            transform: translateY(-3px);
        }

        .reward-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        #shopPopup h2 {
            color: #fff;
            font-weight: bold;
        }

        #shopList {
            color: #fff;
            font-weight: normal;
        }

        /* --- 2. 상점 UI/로직: 점수로 패시브 업그레이드 구매 --- */
        /* 1) 상점에 표시할 아이템 목록 및 가격 설정 (보상 목록과 동일, 가격은 예시) */

        /* 2) 상점 UI에 아이템 표시 및 구매 로직 구현 */

        /* 3) 상점 버튼 클릭 시 updateShopList 호출 */
        document.getElementById('shopButton').onclick = () => {
            document.getElementById('shopPopup').style.display = 'block';
            this.updateShopList();
        };
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <!-- HUD 요소들 -->
    <div class="hud">
        <div class="glass-card hud-item" style="display:flex; flex-direction:row; align-items:center; gap:22px; min-width:unset; max-width:unset;">
            <div style="display:flex; align-items:center; gap:10px;">
                <div style="display:flex; align-items:center; gap:6px;">
                    <div style="width:8px; height:8px; background:#ef4444; border-radius:50%; animation:pulse 2s infinite;"></div>
                    <span>체력</span>
                    <div class="health-bar" style="width:70px; margin:0 4px;"><div class="health-fill" id="healthFill" style="width:100%;"></div></div>
                    <span id="healthText">100/100</span>
                </div>
                <div style="display:flex; align-items:center; gap:6px; margin-left:16px;">
                    <div style="width:8px; height:8px; background:#3b82f6; border-radius:50%; animation:pulse 2s infinite;"></div>
                    <span>탄약</span>
                    <div class="ammo-bar" style="width:70px; margin:0 4px;"><div class="ammo-fill" id="ammoFill" style="width:100%;"></div></div>
                    <span id="ammoText">60/60</span>
                </div>
                <div style="display:flex; align-items:center; gap:6px; margin-left:16px;">
                    <div style="width:8px; height:8px; background:#8b5cf6; border-radius:50%;"></div>
                    <span>속도</span>
                    <span id="speedText">5</span>
                </div>
                <div style="display:flex; align-items:center; gap:6px; margin-left:16px;">
                    <div style="width:8px; height:8px; background:#dc2626; border-radius:50%;"></div>
                    <span>공격력</span>
                    <span id="damageText">20</span>
                </div>
                <div style="display:flex; align-items:center; gap:6px; margin-left:16px;">
                    <div style="width:8px; height:8px; background:#7c3aed; border-radius:50%;"></div>
                    <span>다중 발사</span>
                    <span id="multishotText">1</span>
                </div>
                <div style="display:flex; align-items:center; gap:6px; margin-left:16px;">
                    <span style="color:white; font-weight:600;">활성 효과</span>
                    <div id="activeEffects" style="font-size:12px; display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
                        <div id="invincibilityEffect"></div>
                        <div id="shieldBoostEffect"></div>
                        <div id="timeSlowEffect"></div>
                        <div id="magnetEffect"></div>
                        <div id="healthRegenEffect"></div>
                        <div id="rapidFireEffect"></div>
                        <div id="piercingShotEffect"></div>
                        <div id="explosiveShotEffect"></div>
                        <div id="orbitingKnivesEffect"></div>
                        <div id="ricochetShotEffect"></div>
                        <div id="homingShotEffect"></div>
                        <div id="splitShotEffect"></div>
                        <div id="ammoRegenEffect"></div>
                        <div id="timeStopEffect"></div>
                        <div id="dashEffect"></div>
                        <div id="lifeStealEffect"></div>
                        <div id="critChanceEffect"></div>
                        <div id="cooldownReductionEffect"></div>
                        <div id="armorEffect"></div>
                    </div>
                </div>
                <!-- 점수/웨이브/적 수 표시 (오른쪽 끝에 가로로) -->
                <span id="scoreText" style="margin-left:22px; color:#fff; font-size:1.1em; font-weight:600;"></span>
                <span id="waveText" style="margin-left:14px; color:#fff; font-size:1.1em; font-weight:600;"></span>
                <span id="enemyCount" style="margin-left:14px; color:#fff; font-size:1.1em; font-weight:600;"></span>
                <!-- 1. HUD에 XP와 상점 버튼 추가 -->
                <span id="xpText" style="margin-left:18px; color:#ffe066; font-size:1.1em; font-weight:600;"></span>
                <button id="shopButton" style="margin-left:12px; font-size:1em; border-radius:6px; border:none; background:#ffe066; color:#222; padding:4px 16px; cursor:pointer;">상점</button>
            </div>
        </div>
    </div>
    <!-- 나머지 HUD(웨이브, 조작법, 미니맵 등)는 아래/오른쪽 등 별도 배치 필요시 추가 -->
    
    <!-- 게임 메시지 -->
    <div class="message" id="gameMessage" style="display: none;">
        <div class="glass-card">
            <div class="message-text" id="messageText"></div>
            <div class="message-sub" id="messageSubText"></div>
            <button id="restartButton" style="display:none; margin-top:18px; font-size:1.2em; padding:10px 30px; border-radius:8px; background:#6366f1; color:white; border:none; cursor:pointer;">재시작</button>
        </div>
    </div>

    <!-- 시작 화면 -->
    <div id="startScreen" class="glass-card">
        <h1>글래스 컴뱃 아레나</h1>
        <p>2D 브라우저 기반 전투 게임 - 중력 물리학, 글래스모피즘 UI, 봇 전투 시스템</p>
        <button id="startButton">시작하기</button>
        <button id="enemyDexButton">적 도감</button>
    </div>

    <!-- 보상 선택 화면 -->
    <div id="rewardSelectionScreen" class="glass-card">
        <h2 id="rewardSelectionTitle">보상 선택</h2>
        <div class="reward-options" id="rewardOptions">
            <!-- 보상 버튼들이 여기에 동적으로 추가됩니다. -->
        </div>
    </div>

    <!-- 적 도감 화면 -->
    <div id="enemyDexScreen" class="glass-card" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); z-index:300; min-width:520px; min-height:340px; max-width:90vw; max-height:80vh; flex-direction:row; align-items:stretch; padding:0; overflow:hidden;">
        <!-- 좌측 리스트 -->
        <div id="enemyDexList" style="width:180px; background:rgba(0,0,0,0.18); border-right:1px solid rgba(255,255,255,0.12); overflow-y:auto; max-height:80vh; min-height:340px; display:flex; flex-direction:column;"></div>
        <!-- 우측 상세 -->
        <div id="enemyDexDetail" style="flex:1; display:flex; flex-direction:column; align-items:center; justify-content:center; min-width:240px; padding:32px 16px 16px 16px;"></div>
        <button id="closeEnemyDexButton" style="position:absolute; top:12px; right:16px;">닫기</button>
    </div>

    <!-- 퀘스트 버튼 및 퀘스트 팝업 -->
    <button id="questButton" style="position:absolute; top:24px; left:220px; z-index:20; background:rgba(255,255,255,0.18); color:white; border:none; border-radius:8px; padding:8px 18px; font-size:15px; cursor:pointer;">퀘스트</button>
    <div id="questPopup" class="glass-card" style="display:none; position:absolute; top:60px; left:220px; z-index:30; min-width:260px; min-height:180px;">
        <h3 style="color:white; margin-bottom:12px;">퀘스트</h3>
        <div id="questList" style="color:white; font-size:15px;"></div>
        <button id="closeQuestButton" style="margin-top:18px;">닫기</button>
    </div>

    <!-- 인트로 화면: 솔로/함께 플레이 선택 -->
    <div id="introScreen" class="glass-card" style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); z-index:200; display:flex; flex-direction:column; align-items:center; justify-content:center; min-width:340px; min-height:220px;">
        <h1 style="font-size:2.5em; margin-bottom:18px;">글래스 컴뱃 아레나</h1>
        <button id="soloButton" style="margin:10px 0; padding:14px 36px; font-size:1.2em; border-radius:10px; border:none; background:#6366f1; color:white; cursor:pointer;">솔로 플레이</button>
        <button id="multiButton" style="margin:10px 0; padding:14px 36px; font-size:1.2em; border-radius:10px; border:none; background:#22c55e; color:white; cursor:pointer;">함께 플레이</button>
        <div id="multiInfo" style="display:none; color:#fff; margin-top:18px; font-size:1.1em;">함께 플레이(온라인)는 추후 지원 예정입니다.</div>
    </div>

    <!-- 랭킹 화면 -->
    <div id="rankingScreen" class="glass-card" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); z-index:250; min-width:340px; min-height:320px;">
        <h2 style="color:white; margin-bottom:12px;">랭킹</h2>
        <div id="rankingList" style="color:white; font-size:15px; min-height:180px;"></div>
        <button id="closeRankingButton" style="margin-top:18px;">닫기</button>
    </div>

    <!-- 보스 체력바 및 이름 표시용 -->
    <div id="bossBarContainer" style="display:none; position:fixed; top:38px; left:50%; transform:translateX(-50%); z-index:30; min-width:320px; max-width:60vw;">
        <div id="bossName" style="color:#fff; font-size:2em; font-weight:700; text-align:center; text-shadow:0 2px 8px #000; margin-bottom:6px;"></div>
        <div style="background:rgba(0,0,0,0.3); border-radius:8px; width:100%; height:22px; box-shadow:0 2px 8px #000;">
            <div id="bossBar" style="height:100%; background:linear-gradient(90deg,#ff007f,#ff8c00); border-radius:8px; width:100%; transition:width 0.3s;"></div>
        </div>
    </div>

    <!-- 미니맵 (HUD 아래 오른쪽 등 원하는 위치로 조정 가능) -->
    <div class="minimap" id="minimap" style="position:fixed; top:60px; right:32px; z-index:15;">
        <div class="minimap-player" id="minimapPlayer"></div>
    </div>

    <!-- 2. 상점 팝업 UI 추가 (body 하단) -->
    <div id="shopPopup" class="glass-card" style="display:none; position:fixed; top:80px; left:50%; transform:translateX(-50%); z-index:200; min-width:340px; min-height:220px;">
        <h2 style="color:#222; margin-bottom:12px;">상점 (XP로 업그레이드)</h2>
        <div id="shopList" style="color:#222; font-size:15px; min-height:120px;"></div>
        <button id="closeShopButton" style="margin-top:18px;">닫기</button>
    </div>

    <script>
        // GlassCombatArena 게임 클래스 정의
        class GlassCombatArena {
            constructor() {
                // 캔버스 및 2D 컨텍스트 초기화
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.resizeCanvas(); // 캔버스 크기 조정
                
                // 게임 상태 초기화
                this.gameState = {
                    player: { // 플레이어 객체
                        x: this.canvas.width / 2, // 초기 X 위치 (캔버스 중앙)
                        y: this.canvas.height / 2, // 초기 Y 위치 (캔버스 중앙)
                        width: 40, // 너비
                        height: 40, // 높이
                        vx: 0, // X축 속도
                        vy: 0, // Y축 속도
                        health: 150, // 현재 체력 (150 -> 200으로 변경)
                        maxHealth: 150, // 최대 체력 (150 -> 200으로 변경)
                        ammo: 30, // 현재 탄약 (30발로 고정)
                        maxAmmo: 30, // 최대 탄약 (30발로 고정)
                        speed: 5, // 이동 속도
                        jumpPower: 15, // 점프력
                        onGround: false, // 지면 접촉 여부
                        facing: 0, // 바라보는 방향 (라디안)
                        expression: ':D', // 표정
                        color: '#6366f1', // 색상
                        baseDamage: 10, // 기본 공격력 (20 -> 25로 상향)
                        multishot: 1, // 다중 발사 횟수
                        rapidFireTime: 0, // 연발 모드 종료 시간
                        damageReductionFactor: 1, // 피해 감소율 (1 = 100% 피해, 0.5 = 50% 피해)
                        shieldBoostEndTime: 0, // 쉴드 강화 종료 시간
                        healthRegenEndTime: 0, // 체력 재생 종료 시간
                        lastRegenTick: 0, // 마지막 체력 재생 틱 시간
                        magnetEndTime: 0, // 자석 효과 종료 시간
                        magnetRadius: 200, // 자석 효과 범위
                        lastHitById: null, // 마지막으로 플레이어에게 피해를 준 엔티티의 ID
                        type: 'player', // 플레이어 타입 추가
                        orbitingKnives: [], // 회전 칼날 배열 추가
                        piercingShot: 0, // 관통 사격 레벨 (0: 없음, 1+: 관통 횟수)
                        explosiveShot: 0, // 폭발 사격 레벨 (0: 없음, 1+: 레벨)
                        ricochetLevel: 0, // 도탄 사격 레벨
                        homingLevel: 0, // 유도 사격 레벨
                        splitLevel: 0, // 분열 사격 레벨
                        lifeStealPercent: 0, // 생명력 흡수율
                        critChance: 0, // 치명타 확률
                        critMultiplier: 1.5, // 치명타 배율
                        cooldownReduction: 0, // 재사용 대기시간 감소율
                        armor: 0, // 방어력 (고정 피해 감소)
                        timeStopEndTime: 0, // 시간 정지 종료 시간
                        ammoRegenEndTime: 0, // 탄약 재생 종료 시간
                        lastAmmoRegenTick: 0, // 마지막 탄약 재생 틱
                        ammoRegenAmount: 0, // 탄약 재생량
                        dashCooldown: 0, // 마지막 대시 시각
                        dashEndTime: 0, // 대시 종료 시각
                        isDashing: false, // 대시 중 여부
                        reloadTime: 1500, // 기본 재장전 시간(ms)
                        isReloading: false,
                        machineGunMode: false, // 기관단총 패시브
                        machineGunPenalty: false, // 기관단총 패널티
                        reloadPenalty: 0, // 패시브로 인한 추가 재장전 시간(ms)
                        gunRecoil: 0,
                        gunRecoilTarget: 0,
                    },
                    enemies: [], // 적 배열
                    projectiles: [], // 발사체 배열
                    items: [], // 아이템 배열
                    particles: [], // 파티클 배열
                    floatingTexts: [], // 떠다니는 텍스트 배열 (체력 변화 등)
                    allies: [], // 아군 배열 추가
                    score: 0, // 현재 점수
                    wave: 1, // 현재 웨이브
                    gameStatus: 'start', // 게임 상태 ('start', 'playing', 'wave-complete', 'game-over', 'reward-selection')
                    message: '', // 현재 표시되는 메시지 텍스트
                    messageTimer: 0, // 메시지 타이머
                    playerSlowedEndTime: 0, // 플레이어 둔화 효과 종료 시간
                    timeSlowEndTime: 0, // 시간 둔화 효과 종료 시간 (적 느려짐)
                    timeSlowEffect: 1 // 시간 둔화 효과 (1 = 정상 속도, 0 = 정지)
                };
                
                // 입력 상태 초기화
                this.keys = {}; // 눌린 키 상태 저장 객체
                this.mouse = { x: 0, y: 0 }; // 마우스 현재 위치
                
                // 게임 상수 정의 (난이도 및 게임 플레이 조정)
                this.GRAVITY = 0.8; // 중력 가속도
                this.FRICTION = 0.85; // 마찰 계수
                this.GROUND_Y = 50; // 지면의 Y 좌표 (캔버스 하단으로부터의 거리)
                // 사용자 요청에 따라 표정 배열에 ': @' 추가
                this.EXPRESSIONS = [':D', ':>', ':<', ':O', ':/', ':#', 'XD', 'X>', ':V', ':@']; // 캐릭터 표정 배열
                
                // 아이템 타입 정의 (새로운 아이템 추가)
                this.ITEM_TYPES = [
                    { type: 'health', effect: 50, color: '#22c55e', emoji: '❤️' }, // 체력 회복
                    { type: 'ammo', effect: 30, color: '#f59e0b', emoji: '🔋' }, // 탄약 회복
                    { type: 'speed', effect: 2, color: '#8b5cf6', emoji: '🚀' }, // 이동 속도 증가
                    { type: 'shield', effect: 50, color: '#3b82f6', emoji: '🛡️' }, // 최대 체력 증가
                    { type: 'damage', effect: 10, color: '#dc2626', emoji: '⚔️' }, // 공격력 증가
                    { type: 'multishot', effect: 3, color: '#7c3aed', emoji: '💥' }, // 다중 발사
                    { type: 'megahealth', effect: 100, color: '#059669', emoji: '💚' }, // 대량 체력 회복
                    { type: 'rapid', effect: 5, color: '#ea580c', emoji: '⚡' }, // 연발 모드
                    { type: 'invincibility', effect: 5000, color: '#ffd700', emoji: '✨' }, // 무적 (5초)
                    { type: 'grenade', effect: 1, color: '#6b7280', emoji: '💣' }, // 수류탄
                    { type: 'shield_boost', effect: 0.5, duration: 10000, color: '#87ceeb', emoji: '🔵' }, // 쉴드 강화 (10초, 50% 피해 감소)
                    { type: 'time_slow', effect: 0.5, duration: 5000, color: '#800080', emoji: '⏳' }, // 시간 둔화 (5초, 50% 느려짐)
                    { type: 'magnet', effect: 200, duration: 8000, color: '#8b4513', emoji: '  ' }, // 자석 (8초, 200px 범위)
                    { type: 'health_regen', effect: 5, duration: 10000, tickInterval: 500, color: '#32cd32', emoji: '⚕️' }, // 체력 재생 (10초, 0.5초마다 5회복)
                    { type: 'ally_summon', effect: 1, color: '#90ee90', emoji: '🤖' }, // 아군 소환 아이템
                    { type: 'orbiting_knife', effect: 1, color: '#c0c0c0', emoji: '🔪' }, // 회전 칼날 아이템
                    { type: 'piercing_shot', effect: 1, color: '#800080', emoji: '✨' }, // 관통 사격 아이템
                    { type: 'explosive_shot', effect: 1, color: '#ff4500', emoji: '💥' }, // 폭발 사격 아이템
                    { type: 'ricochet_shot', effect: 1, color: '#00ced1', emoji: '↩️' }, // 도탄 사격
                    { type: 'homing_shot', effect: 1, color: '#ff1493', emoji: '🧭' }, // 유도 사격
                    { type: 'split_shot', effect: 1, color: '#9932cc', emoji: '➕' }, // 분열 사격
                    { type: 'time_stop', effect: 3000, color: '#4b0082', emoji: '🛑' }, // 시간 정지 (3초)
                    { type: 'ammo_regen', effect: 10, duration: 5000, tickInterval: 200, color: '#ffd700', emoji: '🟡' } // 탄약 재생 (5초, 0.2초마다 10회복)
                ];
                
                // 적 타입 정의 (새로운 적 추가됨)
                this.ENEMY_TYPES = {
                    boss: {
                        name: '글래스 보스',
                        health: 800,
                        speed: 2.5,
                        damage: 40,
                        color: '#ff007f',
                        size: 90,
                        shootInterval: 900,
                        points: 3000,
                        missileCooldown: 3000, lastMissile: 0, // 미사일 난사
                        teleportCooldown: 6000, lastTeleport: 0, // 순간이동
                        explosionCooldown: 7000, lastExplosion: 0, // 광역 폭발
                        summonCooldown: 9000, lastSummon: 0, // 소환
                        shieldCooldown: 12000, lastShield: 0, shieldDuration: 3000, isInvincible: false, invincibleEndTime: 0, // 쉴드
                        blackholeCooldown: 15000, lastBlackhole: 0, // 블랙홀
                        description: '모든 보스 능력을 가진 궁극의 보스. 웨이브가 오를수록 더욱 강해진다.'
                    },
                    basic: {
                        name: '기본 적', health: 40, speed: 2, damage: 15, color: '#ef4444', size: 35, shootInterval: 2000, points: 100
                    },
                    fast: {
                        name: '빠른 적', health: 25, speed: 4, damage: 12, color: '#f97316', size: 30, shootInterval: 1500, points: 150
                    },
                    tank: {
                        name: '탱크 적', health: 80, speed: 1, damage: 25, color: '#7c3aed', size: 45, shootInterval: 3000, points: 250
                    },
                    sniper: {
                        name: '저격수', health: 30, speed: 1.5, damage: 30, color: '#06b6d4', size: 32, shootInterval: 4000, points: 200
                    },
                    bomber: {
                        name: '폭격병', health: 45, speed: 1.5, damage: 30, color: '#b91c1c', size: 38, shootInterval: 3000, points: 220
                    },
                    guardian: {
                        name: '수호자', health: 200, speed: 1.2, damage: 45, color: '#1e40af', size: 55, shootInterval: 1800, points: 400
                    },
                    assassin: {
                        name: '암살자', health: 35, speed: 5, damage: 20, color: '#6b21a8', size: 28, shootInterval: 1200, points: 180
                    },
                    heavy: {
                        name: '중장병', health: 100, speed: 0.8, damage: 40, color: '#92400e', size: 50, shootInterval: 2500, points: 300
                    },
                    ghost: {
                        name: '유령', health: 20, speed: 6, damage: 10, color: '#a8a29e', size: 25, shootInterval: 2500, points: 200, isInvincible: false, invincibilityDuration: 1000 // 유령 전용 속성
                    },
                    medic: {
                        name: '치유사', health: 50, speed: 1.5, damage: 0, color: '#10b981', size: 30, shootInterval: 5000, points: 300, healAmount: 20, healRadius: 150 // 치유사 전용 속성
                    },
                    summoner: {
                        name: '소환사', health: 70, speed: 1, damage: 5, color: '#9333ea', size: 40, shootInterval: 8000, points: 400, summonCount: 1, summonType: 'basic' // 소환사 전용 속성
                    },
                    jumper: {
                        name: '점퍼', health: 30, speed: 3, damage: 18, color: '#facc15', size: 35, shootInterval: 2000, points: 120, jumpCooldown: 2000, lastJump: 0 // 점퍼 전용 속성
                    },
                    shielded: {
                        name: '방패병', health: 120, speed: 0.7, damage: 20, color: '#6b7280', size: 45, shootInterval: 2800, points: 280, shieldAngle: Math.PI / 3 // 방패병 전용 속성
                    },
                    teleporter: {
                        name: '순간이동병', health: 35, speed: 1, damage: 25, color: '#a78bfa', size: 30, shootInterval: 3500, points: 220, teleportCooldown: 4000, lastTeleport: 0 // 순간이동병 전용 속성
                    },
                    drone: {
                        name: '드론', health: 20, speed: 7, damage: 10, color: '#94a3b8', size: 20, shootInterval: 1000, points: 80, flies: true // 드론 전용 속성
                    },
                    spitter: {
                        name: '침뱉는병', health: 50, speed: 1.3, damage: 15, color: '#16a34a', size: 35, shootInterval: 2500, points: 180, slowEffect: 0.5, slowDuration: 3000 // 침뱉는병 전용 속성
                    },
                    berserker: {
                        name: '광전사', health: 60, speed: 3, damage: 20, color: '#be123c', size: 38, shootInterval: 1800, points: 250, rageThreshold: 0.3, rageSpeedBoost: 1.5, rageDamageBoost: 1.5, isRaging: false // 광전사 전용 속성
                    },
                    // 새로운 보스 타입
                    boss_alpha: {
                        name: '알파 보스', health: 200, speed: 2, damage: 25, color: '#ff007f', size: 65, shootInterval: 1800, points: 700,
                        summonCooldown: 10000, lastSummon: 0, summonCount: 2, summonType: 'basic',
                        // 스킬1: 미니언 소환
                        dashCooldown: 7000, lastDash: 0, dashCount: 3, dashDuration: 300, isDashing: false,
                        // 스킬2: 연속 돌진
                        shockwaveCooldown: 12000, lastShockwave: 0,
                        description: '미니언 소환, 연속 돌진, 광역 충격파'
                    },
                    boss_beta: {
                        name: '베타 보스', health: 300, speed: 1.5, damage: 20, color: '#00ffff', size: 70, shootInterval: 2500, points: 800,
                        // 스킬1: 쉴드(무적)
                        shieldCooldown: 10000, lastShield: 0, shieldDuration: 3000, isInvincible: false, invincibleEndTime: 0,
                        // 스킬2: 탄막 발사
                        barrageCooldown: 8000, lastBarrage: 0,
                        // 스킬3: 체력 회복
                        healCooldown: 14000, lastHeal: 0, healAmount: 60,
                        description: '쉴드, 탄막, 체력 회복'
                    },
                    boss_gamma: {
                        name: '감마 보스', health: 180, speed: 3.5, damage: 35, color: '#ff8c00', size: 60, shootInterval: 1000, points: 900,
                        // 스킬1: 순간이동
                        teleportCooldown: 6000, lastTeleport: 0, teleportRange: 200,
                        // 스킬2: 레이저
                        laserCooldown: 9000, lastLaser: 0, laserDuration: 1200,
                        // 스킬3: 속도 버프
                        speedBuffCooldown: 12000, lastSpeedBuff: 0, speedBuffDuration: 3000, isSpeedBuffed: false,
                        description: '순간이동, 레이저, 속도 버프'
                    },
                    boss_delta: {
                        name: '델타 보스', health: 350, speed: 1.7, damage: 30, color: '#22223b', size: 80, shootInterval: 2000, points: 1200,
                        // 스킬1: 블랙홀
                        blackholeCooldown: 9000, lastBlackhole: 0, blackholeRadius: 180,
                        // 스킬2: 광역 폭발
                        explosionCooldown: 11000, lastExplosion: 0,
                        // 스킬3: 플레이어 둔화
                        slowCooldown: 13000, lastSlow: 0, slowDuration: 3000,
                        description: '블랙홀, 광역 폭발, 플레이어 둔화'
                    },
                    boss_epsilon: {
                        name: '엡실론 보스', health: 320, speed: 2.2, damage: 22, color: '#fbbf24', size: 75, shootInterval: 1800, points: 1100,
                        // 스킬1: 분신 생성
                        cloneCooldown: 10000, lastClone: 0, clones: 2, hasCloned: false,
                        // 스킬2: 탄환 반사
                        reflectCooldown: 9000, lastReflect: 0, reflectDuration: 2000, isReflecting: false,
                        // 스킬3: 체력 흡수
                        drainCooldown: 12000, lastDrain: 0, drainAmount: 40,
                        description: '분신, 탄환 반사, 체력 흡수'
                    },
                    boss_zeta: {
                        name: '제타 보스', health: 300, speed: 2.5, damage: 28, color: '#06d6a0', size: 78, shootInterval: 1700, points: 1300,
                        // 스킬1: 시간 왜곡(슬로우)
                        timeWarpCooldown: 8000, lastTimeWarp: 0, timeWarpDuration: 2500, isTimeWarp: false,
                        // 스킬2: 연발 사격
                        rapidFireCooldown: 9000, lastRapidFire: 0, rapidFireDuration: 2000, isRapidFire: false,
                        // 스킬3: 랜덤 위치 이동
                        randomMoveCooldown: 11000, lastRandomMove: 0,
                        description: '시간 왜곡, 연발 사격, 랜덤 이동'
                    },
                    boss_eta: {
                        name: '에타 보스', health: 400, speed: 1.3, damage: 40, color: '#ff006e', size: 90, shootInterval: 3000, points: 1500,
                        // 스킬1: 레이저
                        laserCooldown: 7000, lastLaser: 0, laserDuration: 1200,
                        // 스킬2: 연속 점프
                        jumpCooldown: 9000, lastJump: 0, jumpCount: 3, jumpPower: 30,
                        // 스킬3: 방어력 증가
                        armorBuffCooldown: 12000, lastArmorBuff: 0, armorBuffDuration: 4000, isArmorBuffed: false,
                        description: '레이저, 연속 점프, 방어력 증가'
                    },
                    boss_theta: {
                        name: '쎄타 보스', health: 370, speed: 1.8, damage: 26, color: '#3a86ff', size: 85, shootInterval: 2100, points: 1250,
                        // 스킬1: 발사체 반사
                        reflectAllCooldown: 10000, lastReflectAll: 0, reflectAllDuration: 2000, isReflecting: false,
                        // 스킬2: 도탄 탄환
                        ricochetCooldown: 9000, lastRicochet: 0, ricochetCount: 5,
                        // 스킬3: 플레이어 위치 추적
                        trackCooldown: 11000, lastTrack: 0, trackDuration: 2000, isTracking: false,
                        description: '발사체 반사, 도탄, 위치 추적'
                    },
                    // === 신규 적 10종 ===
                    mirror: {
                        name: '미러 적', health: 35, speed: 2.5, damage: 15, color: '#b6e0fe', size: 32, shootInterval: 1800, points: 180, mirrorPlayer: true // 플레이어 움직임 따라함
                    },
                    leech: {
                        name: '흡혈 적', health: 30, speed: 2, damage: 10, color: '#a21caf', size: 30, shootInterval: 2000, points: 160, leechAmount: 10 // 닿으면 체력 흡수
                    },
                    mine: {
                        name: '지뢰 적', health: 20, speed: 1, damage: 40, color: '#fbbf24', size: 28, shootInterval: 99999, points: 120, explodesOnNear: true, explodeRadius: 60 // 근접 폭발
                    },
                    freezer: {
                        name: '빙결 적', health: 28, speed: 1.7, damage: 12, color: '#38bdf8', size: 30, shootInterval: 2200, points: 150, freezeOnHit: true, freezeDuration: 2000 // 맞으면 빙결
                    },
                    reflector: {
                        name: '반사 적', health: 40, speed: 1.5, damage: 15, color: '#f472b6', size: 34, shootInterval: 2500, points: 200, reflectChance: 0.3 // 30% 확률로 탄환 반사
                    },
                    healer: {
                        name: '힐러 적', health: 32, speed: 1.2, damage: 0, color: '#bef264', size: 32, shootInterval: 4000, points: 180, healAmount: 15, healRadius: 120, healsOthers: true // 주변 적 회복
                    },
                    portal: {
                        name: '포탈 적', health: 30, speed: 2.2, damage: 13, color: '#818cf8', size: 30, shootInterval: 2000, points: 170, teleportsNearPlayer: true, teleportCooldown: 3000, lastTeleport: 0 // 순간이동
                    },
                    exploder: {
                        name: '폭발 적', health: 25, speed: 2, damage: 18, color: '#f87171', size: 28, shootInterval: 99999, points: 140, explodesOnDeath: true, explodeRadius: 70 // 죽으면 폭발
                    },
                    magnet: {
                        name: '자석 적', health: 30, speed: 1.8, damage: 10, color: '#fde047', size: 30, shootInterval: 2000, points: 160, pullsItems: true, magnetRadius: 180 // 아이템 끌어당김
                    },
                    curse: {
                        name: '저주 적', health: 28, speed: 1.6, damage: 10, color: '#a3a3a3', size: 30, shootInterval: 2200, points: 170, cursesPlayer: true, curseDuration: 2500 // 맞추면 디버프
                    },
                    // === 신규 보스 5종 ===
                    boss_delta: {
                        name: '델타 보스', health: 350, speed: 1.7, damage: 30, color: '#22223b', size: 80, shootInterval: 2000, points: 1200, blackholeCooldown: 9000, lastBlackhole: 0, blackholeRadius: 180 // 블랙홀 생성
                    },
                    boss_epsilon: {
                        name: '엡실론 보스', health: 320, speed: 2.2, damage: 22, color: '#fbbf24', size: 75, shootInterval: 1800, points: 1100, cloneThreshold: 0.5, clones: 3, hasCloned: false // 분신 생성
                    },
                    boss_zeta: {
                        name: '제타 보스', health: 300, speed: 2.5, damage: 28, color: '#06d6a0', size: 78, shootInterval: 1700, points: 1300, timeWarpCooldown: 8000, lastTimeWarp: 0 // 시간 왜곡
                    },
                    boss_eta: {
                        name: '에타 보스', health: 400, speed: 1.3, damage: 40, color: '#ff006e', size: 90, shootInterval: 3000, points: 1500, laserCooldown: 7000, lastLaser: 0, laserDuration: 1200 // 레이저 발사
                    },
                    boss_theta: {
                        name: '쎄타 보스', health: 370, speed: 1.8, damage: 26, color: '#3a86ff', size: 85, shootInterval: 2100, points: 1250, reflectAllCooldown: 10000, lastReflectAll: 0, reflectAllDuration: 2000 // 발사체 반사
                    },
                    // === 새로운 적 3종 추가 ===
                    juggernaut: {
                        name: '저거너트', health: 800, speed: 1.2, damage: 8, color: '#444444', size: 60, shootInterval: 3000, points: 600, description: '공격력은 약하지만 엄청난 체력을 자랑하는 거대 적.'
                    },
                    // 공중부양 적
                    floater: {
                        name: '플로터', health: 60, speed: 2.5, damage: 18, color: '#00e6e6', size: 32, shootInterval: 1800, points: 220, flies: true, description: '지상 장애물 무시, 공중에서 부유하며 이동하는 적.'
                    },
                    // 특이패턴 적(주기적 무적)
                    phaser: {
                        name: '페이저', health: 70, speed: 2, damage: 22, color: '#ff00cc', size: 34, shootInterval: 2000, points: 300, isInvincible: false, phaseInterval: 2000, lastPhase: 0, description: '주기적으로 잠시 무적이 되는 특수 적.'
                    },
                    // 참신한 하늘 몹 (탄막)
                    skyblaster: {
                        name: '스카이블래스터',
                        health: 90,
                        speed: 3.2,
                        damage: 14,
                        color: '#00bfff',
                        size: 36,
                        shootInterval: 1400,
                        points: 350,
                        flies: true,
                        multishot: 6, // 한 번에 6발 퍼뜨림
                        spread: Math.PI / 2, // 90도 범위로 퍼짐
                        description: '하늘을 날며 한 번에 여러 발의 총알을 퍼뜨리는 참신한 탄막 몹.'
                    },
                    melee: {
                        name: '근접 공격',
                        health: 0,
                        speed: 0,
                        damage: 0,
                        color: '#f59e42',
                        size: 0,
                        shootInterval: 0,
                        points: 0,
                        description: '근접 공격 무기'
                    }
                };

                // 보상 옵션 정의
                this.REWARD_OPTIONS = [
                    { text: '+100 최대 체력', type: 'maxHealth', value: 100 },
                    { text: '+50 현재 체력', type: 'currentHealth', value: 50 },
                    { text: '+5 공격력', type: 'damage', value: 5 },
                    { text: '+1 이동 속도', type: 'speed', value: 1 },
                    { text: '+1 다중 발사', type: 'multishot', value: 1 },
                    { text: '회전 칼날', type: 'orbiting_knife', value: 1 }, // 보상으로 회전 칼날 추가
                    { text: '관통 사격', type: 'piercing_shot', value: 1 }, // 보상으로 관통 사격 추가
                    { text: '폭발 사격', type: 'explosive_shot', value: 1 }, // 보상으로 폭발 사격 추가
                    { text: '도탄 사격', type: 'ricochet_shot', value: 1 }, // 보상으로 도탄 사격 추가
                    { text: '유도 사격', type: 'homing_shot', value: 1 }, // 보상으로 유도 사격 추가
                    { text: '분열 사격', type: 'split_shot', value: 1 }, // 보상으로 분열 사격 추가
                    { text: '생명력 흡수', type: 'life_steal', value: 0.02 }, // 생명력 흡수 추가 (2%)
                    { text: '치명타 확률', type: 'crit_chance', value: 0.05 }, // 치명타 확률 추가 (5%)
                    { text: '재사용 대기시간 감소', type: 'cooldown_reduction', value: 0.05 }, // 재사용 대기시간 감소 (5%)
                    { text: '방어력', type: 'armor', value: 5 }, // 방어력 추가 (5)
                    { text: '시간 정지', type: 'time_stop', value: 3000 }, // 시간 정지 아이템
                    { text: '탄약 재생', type: 'ammo_regen', value: 10 } // 탄약 재생 아이템
                ];
                
                // 이벤트 리스너 설정
                this.setupEventListeners();
                this.xp = 0;

                // GlassCombatArena 생성자 내부에 추가
                this.upgrades = { gun: 0, melee: 0, health: 0, speed: 0, cooldown: 0 };
                this.scoreMilestones = [1000, 2000, 3000, 5000, 8000, 12000, 18000, 25000, 35000, 50000];
                this.nextMilestoneIndex = 0;
            }
            
            // 캔버스 크기를 창 크기에 맞게 조정
            resizeCanvas = () => {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }
            
            // 이벤트 리스너 설정 (키보드, 마우스, 창 크기 조정)
            setupEventListeners = () => {
                // 키보드 입력 처리
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    if (e.key === ' ') e.preventDefault(); // 스페이스바 기본 동작 방지 (스크롤)
                    if (e.key.toLowerCase() === 'e') this.tryDash();
                    if (e.key === '1') this.currentWeapon = 'gun';
                    if (e.key === '2') this.currentWeapon = 'melee';
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });
                
                // 마우스 입력 처리
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouse.x = e.clientX - rect.left;
                    this.mouse.y = e.clientY - rect.top;
                });
                
                this.canvas.addEventListener('click', (e) => {
                    if (this.gameState.gameStatus === 'playing') {
                        this.shoot(); // 게임 플레이 중일 때만 발사
                    } else if (e.button === 0 && this.gameState.gameStatus === 'start') {
                        // 시작 화면에서 클릭 시 시작 버튼 클릭과 동일하게 처리 (선택 사항)
                        // document.getElementById('startButton').click();
                    } else if (e.button === 0 && this.gameState.gameStatus === 'game-over') {
                        // 게임 오버 화면에서 클릭 시 재시작 (선택 사항)
                        // this.resetGame();
                    }
                });
                
                // 창 크기 조정 시 캔버스 크기 재조정
                window.addEventListener('resize', this.resizeCanvas);

                // 시작 버튼 클릭 이벤트
                document.getElementById('startButton').addEventListener('click', this.startGame);
            }

            // 시작 화면 표시 (캔버스 블러 처리)
            showStartScreen = () => {
                this.canvas.style.filter = 'blur(10px)'; // 캔버스 블러 처리
                this.canvas.style.display = 'block'; // 캔버스 보이게
                document.querySelector('.hud').style.display = 'none'; // HUD 숨김
                document.getElementById('startScreen').style.display = 'flex'; // 시작 화면 표시
                document.getElementById('rewardSelectionScreen').style.display = 'none'; // 보상 화면 숨김
            }

            // 게임 시작
            startGame = () => {
                this.canvas.style.filter = 'blur(0px)'; // 캔버스 블러 제거
                document.getElementById('startScreen').style.display = 'none'; // 시작 화면 숨김
                document.querySelector('.hud').style.display = 'flex'; // HUD 표시 (flex로 변경)
                document.getElementById('rewardSelectionScreen').style.display = 'none'; // 보상 화면 숨김

                // 게임 상태 초기화 (resetGame과 유사)
                this.gameState = {
                    player: {
                        x: this.canvas.width / 2, y: this.canvas.height / 2,
                        width: 40, height: 40,
                        vx: 0, vy: 0,
                        health: 150, maxHealth: 150, // 기본값 100으로 변경
                        ammo: 30, maxAmmo: 30, // 기본값 100으로 변경
                        speed: 5, jumpPower: 15,
                        onGround: false, facing: 0,
                        expression: this.getRandomExpression(),
                        color: '#6366f1',
                        baseDamage: 10, // 기본값 10으로 변경
                        multishot: 1,
                        rapidFireTime: 0,
                        damageReductionFactor: 1,
                        shieldBoostEndTime: 0,
                        healthRegenEndTime: 0,
                        lastRegenTick: 0,
                        magnetEndTime: 0,
                        magnetRadius: 200,
                        lastHitById: null, // 초기화
                        type: 'player', // 플레이어 타입
                        orbitingKnives: [], // 회전 칼날 초기화
                        piercingShot: 0, // 관통 사격 초기화
                        explosiveShot: 0, // 폭발 사격 초기화
                        ricochetLevel: 0, // 도탄 사격 초기화
                        homingLevel: 0, // 유도 사격 초기화
                        splitLevel: 0, // 분열 사격 초기화
                        lifeStealPercent: 0, // 생명력 흡수 초기화
                        critChance: 0, // 치명타 확률 초기화
                        critMultiplier: 1.5, // 치명타 배율 초기화
                        cooldownReduction: 0, // 재사용 대기시간 감소 초기화
                        armor: 0, // 방어력 초기화
                        timeStopEndTime: 0, // 시간 정지 초기화
                        ammoRegenEndTime: 0, // 탄약 재생 초기화
                        lastAmmoRegenTick: 0, // 마지막 탄약 재생 틱 초기화
                        ammoRegenAmount: 0, // 탄약 재생량 초기화
                        dashCooldown: 0, // 마지막 대시 시각
                        dashEndTime: 0, // 대시 종료 시각
                        isDashing: false, // 대시 중 여부
                        reloadTime: 1500, // 기본 재장전 시간(ms)
                        isReloading: false,
                        machineGunMode: false, // 기관단총 패시브
                        machineGunPenalty: false, // 기관단총 패널티
                        reloadPenalty: 0, // 패시브로 인한 추가 재장전 시간(ms)
                        gunRecoil: 0,
                        gunRecoilTarget: 0,
                    },
                    enemies: [],
                    projectiles: [],
                    items: [],
                    particles: [],
                    floatingTexts: [],
                    allies: [], // 아군 배열 초기화
                    score: 0,
                    wave: 1,
                    gameStatus: 'playing',
                    message: '',
                    messageTimer: 0,
                    playerSlowedEndTime: 0,
                    timeSlowEndTime: 0,
                    timeSlowEffect: 1
                };
                
                this.spawnInitialWave(); // 초기 웨이브 생성
                this.gameLoop(); // 게임 루프 시작
                this.updateHUD(); // HUD 초기 업데이트
                this.hideMessage(); // 메시지 숨기기

                // === startGame 함수 내부에 추가 ===
                this.currentWeapon = 'gun'; // 게임 시작 시 무기 초기화
                this.upgrades = { gun: 0, melee: 0, health: 0, speed: 0, cooldown: 0 };
            }
            
            // 무작위 표정 반환
            getRandomExpression = () => {
                if (this.EXPRESSIONS && this.EXPRESSIONS.length > 0) {
                    return this.EXPRESSIONS[Math.floor(Math.random() * this.EXPRESSIONS.length)];
                }
                return ':)'; // 표정 배열이 비어있는 경우를 위한 기본 표정
            }
            
            // 현재 웨이브에 따라 적 타입 결정 (새로운 적 등장 로직 추가)
            getEnemyTypeForWave = (wave) => {
                const bossTypes = [
                    'boss_alpha','boss_beta','boss_gamma','boss_delta','boss_epsilon','boss_zeta','boss_eta','boss_theta'
                ];
                if (wave % 10 === 0) {
                    return bossTypes[Math.floor(Math.random() * bossTypes.length)];
                }
                // 일반 웨이브 적 생성 로직
                if (wave <= 2) {
                    return 'basic';
                } else if (wave <= 5) {
                    const rand = Math.random();
                    if (rand < 0.4) return 'basic';
                    else if (rand < 0.7) return 'fast';
                    else return 'jumper';
                } else if (wave <= 8) {
                    const rand = Math.random();
                    if (rand < 0.2) return 'basic';
                    else if (rand < 0.35) return 'fast';
                    else if (rand < 0.5) return 'tank';
                    else if (rand < 0.65) return 'assassin';
                    else if (rand < 0.75) return 'jumper';
                    else if (rand < 0.85) return 'teleporter';
                    else return 'drone';
                } else if (wave <= 12) {
                    const rand = Math.random();
                    if (rand < 0.1) return 'basic';
                    else if (rand < 0.18) return 'fast';
                    else if (rand < 0.26) return 'tank';
                    else if (rand < 0.34) return 'sniper';
                    else if (rand < 0.42) return 'assassin';
                    else if (rand < 0.50) return 'heavy';
                    else if (rand < 0.58) return 'bomber';
                    else if (rand < 0.66) return 'jumper';
                    else if (rand < 0.74) return 'teleporter';
                    else if (rand < 0.82) return 'drone';
                    else if (rand < 0.90) return 'spitter';
                    else return 'berserker';
                } else if (wave <= 15) {
                    const rand = Math.random();
                    if (rand < 0.05) return 'basic';
                    else if (rand < 0.10) return 'fast';
                    else if (rand < 0.15) return 'tank';
                    else if (rand < 0.20) return 'sniper';
                    else if (rand < 0.25) return 'assassin';
                    else if (rand < 0.30) return 'heavy';
                    else if (rand < 0.35) return 'bomber';
                    else if (rand < 0.40) return 'guardian';
                    else if (rand < 0.45) return 'ghost';
                    else if (rand < 0.50) return 'medic';
                    else if (rand < 0.55) return 'summoner';
                    else if (rand < 0.60) return 'jumper';
                    else if (rand < 0.65) return 'shielded';
                    else if (rand < 0.70) return 'teleporter';
                    else if (rand < 0.75) return 'drone';
                    else if (rand < 0.80) return 'spitter';
                    else if (rand < 0.85) return 'berserker';
                    else if (rand < 0.88) return 'mirror';
                    else if (rand < 0.90) return 'leech';
                    else if (rand < 0.92) return 'mine';
                    else if (rand < 0.94) return 'freezer';
                    else if (rand < 0.96) return 'reflector';
                    else if (rand < 0.98) return 'healer';
                    else if (rand < 0.99) return 'portal';
                    else return 'exploder';
                } else {
                    // 15웨이브 이상: 신규 적 확률 대폭 증가
                    const rand = Math.random();
                    if (rand < 0.03) return 'basic';
                    else if (rand < 0.06) return 'fast';
                    else if (rand < 0.09) return 'tank';
                    else if (rand < 0.12) return 'sniper';
                    else if (rand < 0.15) return 'assassin';
                    else if (rand < 0.18) return 'heavy';
                    else if (rand < 0.21) return 'bomber';
                    else if (rand < 0.24) return 'guardian';
                    else if (rand < 0.27) return 'ghost';
                    else if (rand < 0.30) return 'medic';
                    else if (rand < 0.33) return 'summoner';
                    else if (rand < 0.36) return 'jumper';
                    else if (rand < 0.39) return 'shielded';
                    else if (rand < 0.42) return 'teleporter';
                    else if (rand < 0.45) return 'drone';
                    else if (rand < 0.48) return 'spitter';
                    else if (rand < 0.51) return 'berserker';
                    else if (rand < 0.58) return 'mirror';
                    else if (rand < 0.63) return 'leech';
                    else if (rand < 0.68) return 'mine';
                    else if (rand < 0.73) return 'freezer';
                    else if (rand < 0.78) return 'reflector';
                    else if (rand < 0.83) return 'healer';
                    else if (rand < 0.88) return 'portal';
                    else if (rand < 0.93) return 'exploder';
                    else if (rand < 0.96) return 'magnet';
                    else return 'curse';
                }
            }
            
            // 새로운 적 객체 생성
            createEnemy = (enemyType = null) => {
                const side = Math.random() < 0.5 ? 'left' : 'right';
                const x = side === 'left' ? -50 : this.canvas.width + 50;
                const y = Math.random() * (this.canvas.height - 200);
                let type;
                if (this.gameState.wave % 10 === 0) {
                    type = 'boss';
                } else {
                    type = enemyType || this.getEnemyTypeForWave(this.gameState.wave);
                }
                let enemyData = { ...this.ENEMY_TYPES[type] };
                // 스케일링: 웨이브가 오를수록 체력/공격력/속도 증가 (보스는 더 강하게)
                if (type === 'boss') {
                    const scale = 1 + (this.gameState.wave / 10);
                    enemyData.health = Math.floor(enemyData.health * scale);
                    enemyData.maxHealth = enemyData.health;
                    enemyData.speed = enemyData.speed * (1 + (this.gameState.wave / 30));
                    enemyData.damage = Math.floor(enemyData.damage * scale);
                    enemyData.points = Math.floor(enemyData.points * scale);
                    // 스킬 쿨타임 초기화
                    enemyData.lastMissile = 0;
                    enemyData.lastTeleport = 0;
                    enemyData.lastExplosion = 0;
                    enemyData.lastSummon = 0;
                    enemyData.lastShield = 0;
                    enemyData.lastBlackhole = 0;
                    enemyData.isInvincible = false;
                    enemyData.invincibleEndTime = 0;
                    this.showMessage('보스가 등장했습니다!', enemyData.name, 2000);
                } else {
                    const scale = 1 + (this.gameState.wave - 1) * 0.15;
                    enemyData.health = Math.floor(enemyData.health * scale);
                    enemyData.maxHealth = enemyData.health;
                    enemyData.speed = enemyData.speed * (1 + (this.gameState.wave - 1) * 0.05);
                    enemyData.damage = Math.floor(enemyData.damage * scale);
                    enemyData.points = Math.floor(enemyData.points * scale);
                }
                // 신규 적/보스 등장 메시지
                const newTypes = [
                    'mirror','leech','mine','freezer','reflector','healer','portal','exploder','magnet','curse',
                    'boss_delta','boss_epsilon','boss_zeta','boss_eta','boss_theta'
                ];
                if (newTypes.includes(type)) {
                    this.showMessage(`${this.ENEMY_TYPES[type].name} 등장!`, '새로운 위협이 나타났습니다!', 3000);
                }

                // 적 객체 반환
                return {
                    id: Date.now() + Math.random(), // 고유 ID
                    type: type, // 적 타입
                    x: x, y: y, // 위치
                    width: enemyData.size, height: enemyData.size, // 크기
                    vx: 0, vy: 0, // 속도
                    health: enemyData.health, maxHealth: enemyData.health, // 체력 (maxHealth도 동일하게 설정)
                    ammo: 20, maxAmmo: 20, // 탄약 (적은 고정값)
                    speed: enemyData.speed, // 이동 속도
                    damage: enemyData.damage, // 공격력
                    jumpPower: 10, // 점프력 (적은 고정값)
                    onGround: false, // 지면 접촉 여부
                    facing: 0, // 바라보는 방향
                    expression: this.getRandomExpression(), // 표정
                    color: enemyData.color, // 색상
                    lastShot: 0, // 마지막 발사 시간
                    shootInterval: enemyData.shootInterval, // 발사 간격
                    points: enemyData.points, // 처치 시 획득 점수
                    // 새로운 적 전용 속성 초기화
                    isInvincible: enemyData.isInvincible || false,
                    invincibilityDuration: enemyData.invincibilityDuration || 0,
                    invincibleEndTime: 0,
                    healAmount: enemyData.healAmount || 0,
                    healRadius: enemyData.healRadius || 0,
                    summonCooldown: enemyData.summonCooldown || 0, // 알파 보스
                    lastSummon: enemyData.lastSummon || 0, // 알파 보스
                    summonCount: enemyData.summonCount || 0, // 알파 보스
                    summonType: enemyData.summonType || 'basic', // 알파 보스
                    shieldCooldown: enemyData.shieldCooldown || 0, // 베타 보스
                    lastShield: enemyData.lastShield || 0, // 베타 보스
                    shieldDuration: enemyData.shieldDuration || 0, // 베타 보스
                    burstProjectiles: enemyData.burstProjectiles || 0, // 베타 보스
                    burstDamage: enemyData.burstDamage || 0, // 베타 보스
                    teleportStrikeCooldown: enemyData.teleportStrikeCooldown || 0, // 감마 보스
                    lastTeleportStrike: enemyData.lastTeleportStrike || 0, // 감마 보스
                    teleportRange: enemyData.teleportRange || 0, // 감마 보스
                    jumpCooldown: enemyData.jumpCooldown || 0,
                    lastJump: enemyData.lastJump || 0,
                    flies: enemyData.flies || false, // 드론
                    slowEffect: enemyData.slowEffect || 0, // 침뱉는병
                    slowDuration: enemyData.slowDuration || 0,
                    rageThreshold: enemyData.rageThreshold || 0, // 광전사
                    rageSpeedBoost: enemyData.rageSpeedBoost || 1,
                    rageDamageBoost: enemyData.rageDamageBoost || 1,
                    isRaging: false // 광전사 상태
                };
            }

            // 아군 드론 생성
            spawnAlly = (x, y) => {
                this.gameState.allies.push({
                    id: Date.now() + Math.random(),
                    type: 'ally',
                    x: x, y: y,
                    width: 25, height: 25,
                    vx: 0, vy: 0,
                    health: 70, maxHealth: 70,
                    speed: 5,
                    damage: 10, // 25 -> 10
                    color: '#90ee90',
                    lastShot: 0,
                    shootInterval: 600,
                    onGround: false,
                    facing: 0,
                    expression: this.getRandomExpression(),
                    flies: true
                });
            }
            
            // 아이템 객체 생성
            createItem = (x, y) => {
                const itemType = this.ITEM_TYPES[Math.floor(Math.random() * this.ITEM_TYPES.length)]; // 무작위 아이템 타입 선택
                return {
                    id: Date.now() + Math.random(), // 고유 ID
                    x: x, y: y, // 위치
                    width: 20, height: 20, // 크기
                    vx: (Math.random() - 0.5) * 4, // 수평 초기 속도 (무작위)
                    vy: -Math.random() * 8 - 5, // 위로 튀어나오는 초기 속도 (무작위)
                    onGround: false, // 지면 접촉 여부
                    type: itemType.type, // 아이템 타입
                    effect: itemType.effect, // 아이템 효과량
                    color: itemType.color, // 아이템 색상
                    emoji: itemType.emoji, // 아이템 이모지
                    bobOffset: Math.random() * Math.PI * 2, // 떠다니는 애니메이션 오프셋
                    collected: false, // 수집 여부
                    duration: itemType.duration || 0, // 아이템 지속 시간 (새로운 아이템용)
                    tickInterval: itemType.tickInterval || 0 // 체력 재생 등 주기적 효과용
                };
            }
            
            // 플레이어 발사 로직
            shoot = () => {
                const player = this.gameState.player;
                if (player.isReloading) return;
                if (this.currentWeapon === 'gun') {
                    if (player.ammo <= 0) {
                        this.reload();
                        return;
                    }
                    const now = Date.now();
                    let shootInterval = 200;
                    if (player.machineGunMode) shootInterval = 60;
                    if (player.rapidFireTime && now < player.rapidFireTime) shootInterval = 100;
                    shootInterval *= (1 - player.cooldownReduction);
                    if (player.lastShot && now - player.lastShot < shootInterval) return;
                    const startX = player.x + player.width / 2;
                    const startY = player.y + player.height / 2;
                    const angle = Math.atan2(this.mouse.y - startY, this.mouse.x - startX);
                    let speed = player.machineGunMode ? 16 : 12;
                    let damage = player.baseDamage;
                    let isCritical = false;
                    if (Math.random() < player.critChance) {
                        damage *= player.critMultiplier;
                        isCritical = true;
                    }
                    if (player.machineGunMode) damage *= 0.5;
                    if (player.machineGunPenalty) damage *= 0.5;
                    if (player.homingLevel >= 3 && player.homingPenalty) damage *= 0.95;
                    const multishot = player.multishot;
                    const actualMultishot = Math.min(multishot, 4);
                    for (let i = 0; i < actualMultishot; i++) {
                        const spreadAngle = angle + (i - (actualMultishot - 1) / 2) * 0.2;
                        let baseLife = 120;
                        let ricochetBonus = player.ricochetLevel ? player.ricochetLevel * 30 : 0;
                        let projectileLife = baseLife + ricochetBonus;
                        this.gameState.projectiles.push({
                            id: Date.now() + Math.random() + i,
                            x: startX, y: startY,
                            vx: Math.cos(spreadAngle) * speed,
                            vy: Math.sin(spreadAngle) * speed,
                            radius: player.machineGunMode ? 2 : 3,
                            damage: damage,
                            life: projectileLife,
                            color: player.machineGunMode ? '#aaa' : (player.rapidFireTime && now < player.rapidFireTime ? '#ff6b00' : '#fbbf24'),
                            ownerId: 'player',
                            pierceCount: player.piercingShot,
                            explosiveRadius: player.explosiveShot > 0 ? (80 + player.explosiveShot * 20) : 0,
                            bounceCount: player.ricochetLevel,
                            isHoming: player.homingLevel > 0,
                            homingStrength: player.homingLevel > 0 ? (0.05 + player.homingLevel * 0.01) : 0,
                            splitCount: player.splitLevel,
                            isCritical: isCritical,
                            hitEnemies: []
                        });
                    }
                    // 기관단총 패널티: 4발당 탄약 1 소모
                    if (player.machineGunMode) {
                        player.ammo -= 0.25;
                        if (player.ammo < 0) player.ammo = 0;
                    } else {
                        player.ammo--;
                    }
                    player.lastShot = now;
                    this.updateHUD();
                } else if (this.currentWeapon === 'melee') {
                    const range = 70;
                    const damage = player.baseDamage * 4;
                    let hit = false;
                    this.gameState.enemies.forEach(enemy => {
                        const dx = (enemy.x + enemy.width/2) - (player.x + player.width/2);
                        const dy = (enemy.y + enemy.height/2) - (player.y + player.height/2);
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < range) {
                            enemy.health = Math.max(0, enemy.health - damage);
                            this.createFloatingText(enemy.x + enemy.width/2, enemy.y, `-${damage}`, 'orange');
                            this.createHitParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                            if (enemy.health <= 0) {
                                this.addScore(enemy.points || 100);
                                if (Math.random() < 0.4) this.gameState.items.push(this.createItem(enemy.x, enemy.y));
                                this.gameState.enemies = this.gameState.enemies.filter(e => e !== enemy);
                            }
                            hit = true;
                        }
                    });
                    if (hit) this.showMessage('칼 공격!', '', 600);
                }
            }

            reload = () => {
                const player = this.gameState.player;
                if (player.isReloading) return;
                player.isReloading = true;
                player.gunRecoilTarget = 18;
                let reloadTime = player.reloadTime + player.reloadPenalty;
                this.showMessage('재장전 중...', '', reloadTime);
                setTimeout(() => {
                    player.ammo = 100;
                    player.isReloading = false;
                    player.gunRecoilTarget = 0;
                    this.updateHUD();
                }, reloadTime);
            }
            
            // 수류탄 투척 로직
            throwGrenade = () => {
                const player = this.gameState.player;
                const now = Date.now();
                // 수류탄 쿨타임 (예시: 2초)
                if (player.lastGrenade && now - player.lastGrenade < 2000) return;

                const startX = player.x + player.width / 2;
                const startY = player.y + player.height / 2;
                const angle = Math.atan2(this.mouse.y - startY, this.mouse.x - startX);
                const speed = 10; // 수류탄 투척 속도
                const grenadeLife = 60; // 수류탄 수명 (프레임)
                const explosionDelay = 40; // 폭발까지의 딜레이 (프레임)

                this.gameState.projectiles.push({
                    id: Date.now() + Math.random(),
                    x: startX, y: startY,
                    vx: (Math.cos(angle) * speed) * this.gameState.timeSlowEffect, // 시간 둔화 영향 받음
                    vy: (Math.sin(angle) * speed) * this.gameState.timeSlowEffect, // 시간 둔화 영향 받음
                    radius: 8, // 수류탄 크기
                    damage: 0, // 직접 데미지 없음 (폭발 데미지)
                    life: grenadeLife,
                    color: '#6b7280',
                    ownerId: 'player',
                    isGrenade: true, // 수류탄임을 나타내는 플래그
                    explosionRadius: 150, // 폭발 범위
                    explosionDamage: 70, // 폭발 데미지
                    explosionDelay: explosionDelay // 폭발 딜레이
                });
                player.lastGrenade = now;
            }
            
            // 초기 웨이브 적 생성 및 아이템 드롭
            spawnInitialWave = () => {
                if (this.gameState.gameStatus !== 'spawning') return;
                let enemyCount;
                if (this.gameState.wave % 10 === 0) {
                    // 이미 보스가 있으면 추가 소환 금지
                    if (this.gameState.enemies.some(e => e.type && e.type.startsWith('boss'))) return;
                    const bossTypes = [
                        'boss_alpha','boss_beta','boss_gamma','boss_delta','boss_epsilon','boss_zeta','boss_eta','boss_theta'
                    ];
                    const bossType = bossTypes[Math.floor(Math.random() * bossTypes.length)];
                    const bossData = this.ENEMY_TYPES[bossType];
                    this.showMessage(`${bossData.name} 등장!`, '강력한 보스가 나타났습니다!', 2000);
                    this.gameState.enemies.push(this.createEnemy(bossType));
                    return;
                } else if (this.gameState.wave === 1) {
                    enemyCount = 3;
                } else if (this.gameState.wave === 2) {
                    enemyCount = 5;
                } else if (this.gameState.wave === 3) {
                    enemyCount = 7;
                } else if (this.gameState.wave <= 10) {
                    enemyCount = Math.min(10, 7 + (this.gameState.wave - 3) * 1);
                } else if (this.gameState.wave <= 15) {
                    enemyCount = Math.min(15, 10 + (this.gameState.wave - 10) * 1);
                } else {
                    enemyCount = Math.min(20, 15 + (this.gameState.wave - 15) * 1);
                }
                // 웨이브별로 적 타입 다양화
                for (let i = 0; i < enemyCount; i++) {
                    setTimeout(() => {
                        let type = undefined;
                        if (this.gameState.wave >= 2 && Math.random() < 0.2) type = 'fast';
                        if (this.gameState.wave >= 3 && Math.random() < 0.15) type = 'tank';
                        if (this.gameState.wave >= 4 && Math.random() < 0.1) type = 'sniper';
                        if (this.gameState.wave >= 5 && Math.random() < 0.1) type = 'bomber';
                        this.gameState.enemies.push(this.createEnemy(type));
                    }, i * 500);
                }
                
                // 아이템 생성 (전체적으로 감소, 탄약은 유지/증가)
                const totalItemCount = Math.min(5, Math.floor(this.gameState.wave / 3) + 2); // 최대 5개, 웨이브에 따라 더 많이
                let ammoItemCount = 0;
                if (this.gameState.wave >= 5) { // 웨이브 5부터는 탄약 1개 보장
                    ammoItemCount = 1;
                }
                
                for (let i = 0; i < totalItemCount; i++) {
                    setTimeout(() => {
                        let itemToCreate;
                        // 아군 소환 아이템 드롭 확률 (예: 10%)
                        if (Math.random() < 0.1) { 
                            itemToCreate = this.ITEM_TYPES.find(item => item.type === 'ally_summon');
                        } else if (ammoItemCount > 0 && Math.random() < 0.4) { // 탄약 드롭 확률 80% -> 40%로 하향
                            itemToCreate = this.ITEM_TYPES.find(item => item.type === 'ammo');
                            ammoItemCount--;
                        } else if (Math.random() < 0.25) { // 다중 발사 아이템 25% 확률로 우선 등장
                            itemToCreate = this.ITEM_TYPES.find(item => item.type === 'multishot');
                        } else {
                            // 탄약/다중발사/아군소환이 아니면 무작위 아이템
                            const nonSpecialItems = this.ITEM_TYPES.filter(item => item.type !== 'ammo' && item.type !== 'ally_summon' && item.type !== 'multishot');
                            itemToCreate = nonSpecialItems[Math.floor(Math.random() * nonSpecialItems.length)];
                        }

                        this.gameState.items.push(this.createItem(
                            Math.random() * (this.canvas.width - 40) + 20,
                            Math.random() * (this.canvas.height - 200) + 50
                        ));
                        // 생성된 아이템의 타입을 itemToCreate로 덮어쓰기
                        this.gameState.items[this.gameState.items.length - 1].type = itemToCreate.type;
                        this.gameState.items[this.gameState.items.length - 1].effect = itemToCreate.effect;
                        this.gameState.items[this.gameState.items.length - 1].color = itemToCreate.color;
                        this.gameState.items[this.gameState.items.length - 1].emoji = itemToCreate.emoji;
                        this.gameState.items[this.gameState.items.length - 1].duration = itemToCreate.duration || 0;
                        this.gameState.items[this.gameState.items.length - 1].tickInterval = itemToCreate.tickInterval || 0;

                    }, i * 3000);
                }
            }
            
            // 캐릭터 (플레이어 및 적) 상태 업데이트 (새로운 적 AI 로직 추가)
            updateCharacter = (character) => {
                const now = Date.now();
                // player 변수를 함수 시작 부분에서 정의하여 모든 조건문에서 접근 가능하도록 함
                const player = this.gameState.player; 

                // 플레이어 둔화 효과 해제
                if (character === player) { // character === this.gameState.player 대신 player 사용
                    if (now > this.gameState.playerSlowedEndTime) {
                        character.speed = 5; // 기본 속도로 복귀
                    }
                    // 체력 재생 효과
                    if (now < character.healthRegenEndTime && now - character.lastRegenTick > character.tickInterval) {
                        character.health = Math.min(character.maxHealth, character.health + character.effect);
                        this.createFloatingText(character.x + character.width / 2, character.y, `+${character.effect}`, 'lime');
                        character.lastRegenTick = now;
                    }
                    // 탄약 재생 효과
                    if (now < character.ammoRegenEndTime && now - character.lastAmmoRegenTick > character.tickInterval) {
                        character.ammo = Math.min(character.maxAmmo, character.ammo + character.ammoRegenAmount);
                        this.createFloatingText(character.x + character.width / 2, character.y + 20, `+${character.ammoRegenAmount} 탄약`, 'yellow');
                        character.lastAmmoRegenTick = now;
                    }
                }

                // 중력 적용 (드론은 중력 무시)
                if (!character.onGround && !character.flies) {
                    character.vy += this.GRAVITY;
                }
                
                // 지면 충돌 처리 (드론은 지면 충돌 없음)
                if (!character.flies && character.y + character.height > this.canvas.height - this.GROUND_Y) {
                    character.y = this.canvas.height - this.GROUND_Y - character.height;
                    character.vy = 0;
                    character.onGround = true;
                } else if (!character.flies) {
                    character.onGround = false;
                }
                
                // 위치 업데이트 (시간 정지 효과 적용)
                if (this.gameState.timeSlowEffect > 0) { // 시간이 완전히 멈추지 않았을 때만 이동
                    character.x += character.vx * this.gameState.timeSlowEffect;
                    character.y += character.vy * this.gameState.timeSlowEffect;
                }
                
                // 마찰 적용
                character.vx *= this.FRICTION;
                
                // 화면 경계 제한
                character.x = Math.max(0, Math.min(this.canvas.width - character.width, character.x));
                // 드론은 Y축도 화면 경계 제한 (상단)
                if (character.flies) {
                    character.y = Math.max(50, Math.min(this.canvas.height - this.GROUND_Y - character.height, character.y));
                }

                // 플레이어 입력 처리
                if (character === player) { // character === this.gameState.player 대신 player 사용
                    const currentSpeed = character.speed * (now > this.gameState.playerSlowedEndTime ? 1 : this.gameState.playerSlowEffect || 1);
                    if (this.keys['a']) character.vx -= currentSpeed;
                    if (this.keys['d']) character.vx += currentSpeed;
                    if ((this.keys['w'] || this.keys[' ']) && character.onGround) {
                        character.vy = -character.jumpPower;
                        character.onGround = false;
                    }
                    
                    // 마우스 방향으로 플레이어 바라보게 설정
                    const dx = this.mouse.x - (character.x + character.width / 2);
                    const dy = this.mouse.y - (character.y + character.height / 2);
                    character.facing = Math.atan2(dy, dx);
                    // gunRecoil 보간 (부드럽게 복귀)
                    character.gunRecoil += (character.gunRecoilTarget - character.gunRecoil) * 0.25;
                    if (Math.abs(character.gunRecoil - character.gunRecoilTarget) < 0.5) character.gunRecoil = character.gunRecoilTarget;
                } else if (character.type === 'ally') {
                    // 아군 AI: 가장 가까운 적을 찾아 이동하고 공격
                    let closestEnemy = null;
                    let minDistance = Infinity;

                    this.gameState.enemies.forEach(enemy => {
                        const dx = enemy.x - character.x;
                        const dy = enemy.y - character.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestEnemy = enemy;
                        }
                    });

                    if (closestEnemy) {
                        const dx = closestEnemy.x - character.x;
                        const dy = closestEnemy.y - character.y;
                        const angle = Math.atan2(dy, dx);
                        character.facing = angle;

                        // 적에게 접근 (너무 가까워지면 멈춤)
                        if (minDistance > 100) { // 적과 100px 이상 떨어져 있으면 이동
                            character.vx += Math.cos(angle) * 0.5 * character.speed * this.gameState.timeSlowEffect;
                            character.vy += Math.sin(angle) * 0.5 * character.speed * this.gameState.timeSlowEffect;
                        } else { // 적과 가까워지면 속도 줄임
                            character.vx *= 0.9 * this.gameState.timeSlowEffect;
                            character.vy *= 0.9 * this.gameState.timeSlowEffect;
                        }

                        // 공격
                        if (this.gameState.timeSlowEffect === 0) {
                            // 시간 정지 중에는 쿨타임을 강제로 갱신
                            character.lastShot = now;
                        } else if (now - character.lastShot > character.shootInterval * this.gameState.timeSlowEffect) {
                            this.gameState.projectiles.push({
                                id: Date.now() + Math.random(),
                                x: character.x + character.width / 2,
                                y: character.y + character.height / 2,
                                vx: Math.cos(angle) * 7,
                                vy: Math.sin(angle) * 7,
                                radius: 3,
                                damage: character.damage,
                                life: 80,
                                color: character.color,
                                ownerId: character.id,
                                pierceCount: 0,
                                explosiveRadius: 0,
                                bounceCount: 0,
                                isHoming: false,
                                homingStrength: 0,
                                splitCount: 0,
                                hitEnemies: []
                            });
                            character.lastShot = now;
                        }
                    } else {
                        // 적이 없으면 플레이어 따라다님
                        const dx = player.x - character.x; // player 변수 사용
                        const dy = player.y - character.y; // player 변수 사용
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance > 50) { // 플레이어와 50px 이상 떨어져 있으면 이동
                            const angle = Math.atan2(dy, dx);
                            character.vx += Math.cos(angle) * 0.3 * character.speed * this.gameState.timeSlowEffect;
                            character.vy += Math.sin(angle) * 0.3 * character.speed * this.gameState.timeSlowEffect;
                        } else {
                            character.vx *= 0.9 * this.gameState.timeSlowEffect;
                            character.vy *= 0.9 * this.gameState.timeSlowEffect;
                        }
                    }

                } else {
                    // 적 AI 동작 (시간 정지 효과 적용)
                    if (this.gameState.timeSlowEffect === 0) return; // 시간이 완전히 정지했으면 적은 움직이지 않음

                    const dx = (player.x + player.width / 2) - (character.x + character.width / 2); // player 변수 사용
                    const dy = (player.y + player.height / 2) - (character.y + character.height / 2); // player 변수 사용
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // === 보스 스킬 ===
                    if (character.type === 'boss') {
                        // 1. 미사일 난사 (여러 방향으로 탄환 퍼붓기)
                        if (now - character.lastMissile > character.missileCooldown) {
                            const missileCount = 12 + Math.floor(this.gameState.wave/5);
                            for (let i = 0; i < missileCount; i++) {
                                const angle = (Math.PI * 2) * (i / missileCount);
                                this.gameState.projectiles.push({
                                    id: Date.now() + Math.random(),
                                    x: character.x + character.width / 2,
                                    y: character.y + character.height / 2,
                                    vx: Math.cos(angle) * 8,
                                    vy: Math.sin(angle) * 8,
                                    radius: 6,
                                    damage: Math.floor(character.damage * 0.7),
                                    life: 90,
                                    color: character.color,
                                    ownerId: character.id
                                });
                            }
                            this.createFloatingText(character.x + character.width/2, character.y-20, '미사일 난사!', 'orange');
                            character.lastMissile = now;
                        }
                        // 2. 순간이동 (플레이어 근처로)
                        if (now - character.lastTeleport > character.teleportCooldown) {
                            const newX = player.x + (Math.random() - 0.5) * 200;
                            const newY = player.y + (Math.random() - 0.5) * 200;
                            character.x = Math.max(0, Math.min(this.canvas.width - character.width, newX));
                            character.y = Math.max(50, Math.min(this.canvas.height - this.GROUND_Y - character.height, newY));
                            this.createCollectParticles(character.x, character.y, character.color);
                            this.createFloatingText(character.x + character.width/2, character.y-20, '순간이동!', 'cyan');
                            character.lastTeleport = now;
                        }
                        // 3. 광역 폭발
                        if (now - character.lastExplosion > character.explosionCooldown) {
                            this.createExplosion(character.x + character.width/2, character.y + character.height/2, 120 + this.gameState.wave*2, Math.floor(character.damage * 1.2), character.id);
                            this.createFloatingText(character.x + character.width/2, character.y-20, '광역 폭발!', 'red');
                            character.lastExplosion = now;
                        }
                        // 4. 소환 (일반 적)
                        if (now - character.lastSummon > character.summonCooldown) {
                            const summonCount = 2 + Math.floor(this.gameState.wave/10);
                            for (let i = 0; i < summonCount; i++) {
                                const spawnX = character.x + (Math.random() - 0.5) * 120;
                                const spawnY = character.y + (Math.random() - 0.5) * 120;
                                const summonedEnemy = this.createEnemy();
                                summonedEnemy.x = Math.max(0, Math.min(this.canvas.width - summonedEnemy.width, spawnX));
                                summonedEnemy.y = Math.max(50, Math.min(this.canvas.height - this.GROUND_Y - summonedEnemy.height, spawnY));
                                this.gameState.enemies.push(summonedEnemy);
                            }
                            this.createFloatingText(character.x + character.width/2, character.y-20, '소환!', 'yellow');
                            character.lastSummon = now;
                        }
                        // 5. 쉴드 (무적)
                        if (!character.isInvincible && now - character.lastShield > character.shieldCooldown) {
                            character.isInvincible = true;
                            character.invincibleEndTime = now + character.shieldDuration;
                            character.lastShield = now;
                            this.createFloatingText(character.x + character.width/2, character.y-20, '쉴드!', 'lightblue');
                        }
                        if (character.isInvincible && now > character.invincibleEndTime) {
                            character.isInvincible = false;
                        }
                        // 6. 블랙홀 (플레이어를 끌어당김)
                        if (now - character.lastBlackhole > character.blackholeCooldown) {
                            // 블랙홀 효과: 플레이어를 보스 쪽으로 순간적으로 끌어당김
                            const dx = (character.x + character.width/2) - (player.x + player.width/2);
                            const dy = (character.y + character.height/2) - (player.y + player.height/2);
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist < 600) {
                                player.vx += dx/dist * 30;
                                player.vy += dy/dist * 30;
                                this.createFloatingText(player.x + player.width/2, player.y-20, '블랙홀!', 'purple');
                            }
                            this.createFloatingText(character.x + character.width/2, character.y-20, '블랙홀!', 'purple');
                            character.lastBlackhole = now;
                        }
                    }

                    // 일반 보스 AI 이동/공격
                    if (distance > 10) {
                        character.vx += (dx > 0 ? 1 : -1) * 0.3 * this.gameState.timeSlowEffect;
                        character.facing = Math.atan2(dy, dx);
                    }
                    // 기본 발사 (플레이어 향해)
                    if (distance < 700 && now - character.lastShot > character.shootInterval * this.gameState.timeSlowEffect) {
                        const angle = Math.atan2(dy, dx);
                        this.gameState.projectiles.push({
                            id: Date.now() + Math.random(),
                            x: character.x + character.width / 2,
                            y: character.y + character.height / 2,
                            vx: Math.cos(angle) * 7,
                            vy: Math.sin(angle) * 7,
                            radius: 3,
                            damage: character.damage,
                            life: 80,
                            color: character.color,
                            ownerId: character.id,
                            pierceCount: 0,
                            explosiveRadius: 0,
                            bounceCount: 0,
                            isHoming: false,
                            homingStrength: 0,
                            splitCount: 0,
                            hitEnemies: []
                        });
                        character.lastShot = now;
                    }
                }

                // 신규 적/보스 고유 스킬/AI 구현 예시 (주석)
                if (character.type === 'mirror' && player) {
                    // 미러 적: 플레이어 움직임을 따라함 (좌우 반전)
                    character.vx = -player.vx;
                    character.vy = player.vy;
                }
                if (character.type === 'leech') {
                    // 흡혈 적: 플레이어에 닿으면 체력 흡수
                    // (충돌 체크 후 player.health -= leechAmount, character.health += leechAmount 등 구현)
                }
                if (character.type === 'mine') {
                    // 지뢰 적: 플레이어 근처에서 폭발
                }
                if (character.type === 'freezer') {
                    // 빙결 적: 발사체에 맞으면 플레이어 이동 속도 감소
                }
                if (character.type === 'reflector') {
                    // 반사 적: 일정 확률로 플레이어 탄환 반사
                }
                if (character.type === 'healer') {
                    // 힐러 적: 주기적으로 주변 적 체력 회복
                }
                if (character.type === 'portal') {
                    // 포탈 적: 순간이동하며 플레이어 근처에 나타남
                }
                if (character.type === 'exploder') {
                    // 폭발 적: 죽을 때 폭발, 주변에 데미지
                }
                if (character.type === 'magnet') {
                    // 자석 적: 플레이어의 아이템을 끌어당김
                }
                if (character.type === 'curse') {
                    // 저주 적: 맞추면 플레이어에게 디버프
                }
                // === 신규 보스 ===
                if (character.type === 'boss_delta') {
                    // 델타 보스: 주기적으로 블랙홀 생성(플레이어 끌어당김)
                }
                if (character.type === 'boss_epsilon') {
                    // 엡실론 보스: 체력 일정 이하에서 분신 생성
                }
                if (character.type === 'boss_zeta') {
                    // 제타 보스: 주기적으로 시간 왜곡(속도 랜덤화)
                }
                if (character.type === 'boss_eta') {
                    // 에타 보스: 일정 시간마다 레이저 발사
                }
                if (character.type === 'boss_theta') {
                    // 쎄타 보스: 일정 시간마다 플레이어 발사체 반사
                }
                // ...

                // === 각 보스별 고유 스킬 ===
                if (character.type === 'boss_alpha') {
                    // 1. 미니언 소환
                    if (now - character.lastSummon > character.summonCooldown) {
                        for (let i = 0; i < character.summonCount; i++) {
                            const spawnX = character.x + (Math.random() - 0.5) * 100;
                            const spawnY = character.y + (Math.random() - 0.5) * 100;
                            const summonedEnemy = this.createEnemy(character.summonType);
                            summonedEnemy.x = spawnX;
                            summonedEnemy.y = spawnY;
                            this.gameState.enemies.push(summonedEnemy);
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, '미니언 소환!', 'yellow');
                        character.lastSummon = now;
                    }
                    // 2. 연속 돌진
                    if (now - character.lastDash > character.dashCooldown) {
                        character.isDashing = true;
                        let dashIdx = 0;
                        const dash = () => {
                            if (dashIdx < character.dashCount) {
                                const angle = Math.atan2(player.y - character.y, player.x - character.x);
                                character.vx += Math.cos(angle) * 30;
                                character.vy += Math.sin(angle) * 30;
                                this.createFloatingText(character.x + character.width/2, character.y-20, '돌진!', 'orange');
                                dashIdx++;
                                setTimeout(dash, character.dashDuration);
                            } else {
                                character.isDashing = false;
                            }
                        };
                        dash();
                        character.lastDash = now;
                    }
                    // 3. 광역 충격파
                    if (now - character.lastShockwave > character.shockwaveCooldown) {
                        this.createExplosion(character.x + character.width/2, character.y + character.height/2, 180, character.damage * 1.5, character.id);
                        this.createFloatingText(character.x + character.width/2, character.y-20, '충격파!', 'red');
                        character.lastShockwave = now;
                    }
                }
                if (character.type === 'boss_beta') {
                    // 1. 쉴드(무적)
                    if (!character.isInvincible && now - character.lastShield > character.shieldCooldown) {
                        character.isInvincible = true;
                        character.invincibleEndTime = now + character.shieldDuration;
                        character.lastShield = now;
                        this.createFloatingText(character.x + character.width/2, character.y-20, '쉴드!', 'lightblue');
                    }
                    if (character.isInvincible && now > character.invincibleEndTime) {
                        character.isInvincible = false;
                    }
                    // 2. 탄막 발사
                    if (now - character.lastBarrage > character.barrageCooldown) {
                        const count = 18;
                        for (let i = 0; i < count; i++) {
                            const angle = (Math.PI * 2) * (i / count);
                            this.gameState.projectiles.push({
                                id: Date.now() + Math.random(),
                                x: character.x + character.width / 2,
                                y: character.y + character.height / 2,
                                vx: Math.cos(angle) * 7,
                                vy: Math.sin(angle) * 7,
                                radius: 5,
                                damage: character.damage * 0.7,
                                life: 90,
                                color: character.color,
                                ownerId: character.id
                            });
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, '탄막!', 'cyan');
                        character.lastBarrage = now;
                    }
                    // 3. 체력 회복
                    if (now - character.lastHeal > character.healCooldown) {
                        character.health = Math.min(character.maxHealth, character.health + character.healAmount);
                        this.createFloatingText(character.x + character.width/2, character.y-20, `+${character.healAmount} 회복!`, 'green');
                        character.lastHeal = now;
                    }
                }
                if (character.type === 'boss_gamma') {
                    // 1. 순간이동
                    if (now - character.lastTeleport > character.teleportCooldown) {
                        const newX = player.x + (Math.random() - 0.5) * character.teleportRange;
                        const newY = player.y + (Math.random() - 0.5) * character.teleportRange;
                        character.x = Math.max(0, Math.min(this.canvas.width - character.width, newX));
                        character.y = Math.max(50, Math.min(this.canvas.height - this.GROUND_Y - character.height, newY));
                        this.createCollectParticles(character.x, character.y, character.color);
                        this.createFloatingText(character.x + character.width/2, character.y-20, '순간이동!', 'orange');
                        character.lastTeleport = now;
                    }
                    // 2. 레이저
                    if (now - character.lastLaser > character.laserCooldown) {
                        // 플레이어 방향으로 강력한 레이저(직선상 폭발)
                        const angle = Math.atan2(player.y - character.y, player.x - character.x);
                        for (let d = 60; d < 400; d += 40) {
                            const lx = character.x + character.width/2 + Math.cos(angle) * d;
                            const ly = character.y + character.height/2 + Math.sin(angle) * d;
                            this.createExplosion(lx, ly, 40, character.damage * 1.2, character.id);
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, '레이저!', 'red');
                        character.lastLaser = now;
                    }
                    // 3. 속도 버프
                    if (!character.isSpeedBuffed && now - character.lastSpeedBuff > character.speedBuffCooldown) {
                        character.speed *= 2;
                        character.isSpeedBuffed = true;
                        this.createFloatingText(character.x + character.width/2, character.y-20, '속도 버프!', 'lime');
                        setTimeout(() => {
                            character.speed /= 2;
                            character.isSpeedBuffed = false;
                        }, character.speedBuffDuration);
                        character.lastSpeedBuff = now;
                    }
                }
                if (character.type === 'boss_delta') {
                    // 1. 블랙홀
                    if (now - character.lastBlackhole > character.blackholeCooldown) {
                        const dx = (character.x + character.width/2) - (player.x + player.width/2);
                        const dy = (character.y + character.height/2) - (player.y + player.height/2);
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < 600) {
                            player.vx += dx/dist * 30;
                            player.vy += dy/dist * 30;
                            this.createFloatingText(player.x + player.width/2, player.y-20, '블랙홀!', 'purple');
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, '블랙홀!', 'purple');
                        character.lastBlackhole = now;
                    }
                    // 2. 광역 폭발
                    if (now - character.lastExplosion > character.explosionCooldown) {
                        this.createExplosion(character.x + character.width/2, character.y + character.height/2, 120, character.damage * 1.2, character.id);
                        this.createFloatingText(character.x + character.width/2, character.y-20, '광역 폭발!', 'red');
                        character.lastExplosion = now;
                    }
                    // 3. 플레이어 둔화
                    if (now - character.lastSlow > character.slowCooldown) {
                        player.speed = Math.max(1, player.speed * 0.5);
                        this.createFloatingText(player.x + player.width/2, player.y-20, '둔화!', 'blue');
                        setTimeout(() => { player.speed = 5; }, character.slowDuration);
                        character.lastSlow = now;
                    }
                }
                if (character.type === 'boss_epsilon') {
                    // 1. 분신 생성
                    if (!character.hasCloned && now - character.lastClone > character.cloneCooldown) {
                        for (let i = 0; i < character.clones; i++) {
                            const clone = this.createEnemy('boss_epsilon');
                            clone.health = Math.floor(character.health * 0.3);
                            clone.x = character.x + (Math.random() - 0.5) * 120;
                            clone.y = character.y + (Math.random() - 0.5) * 120;
                            this.gameState.enemies.push(clone);
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, '분신!', 'yellow');
                        character.hasCloned = true;
                        character.lastClone = now;
                    }
                    // 2. 탄환 반사
                    if (!character.isReflecting && now - character.lastReflect > character.reflectCooldown) {
                        character.isReflecting = true;
                        this.createFloatingText(character.x + character.width/2, character.y-20, '탄환 반사!', 'cyan');
                        setTimeout(() => { character.isReflecting = false; }, character.reflectDuration);
                        character.lastReflect = now;
                    }
                    // 3. 체력 흡수
                    if (now - character.lastDrain > character.drainCooldown) {
                        player.health = Math.max(0, player.health - character.drainAmount);
                        character.health = Math.min(character.maxHealth, character.health + character.drainAmount);
                        this.createFloatingText(player.x + player.width/2, player.y-20, `-${character.drainAmount} 흡수!`, 'purple');
                        this.createFloatingText(character.x + character.width/2, character.y-20, `+${character.drainAmount} 흡수!`, 'purple');
                        character.lastDrain = now;
                    }
                }
                if (character.type === 'boss_zeta') {
                    // 1. 시간 왜곡(슬로우)
                    if (!character.isTimeWarp && now - character.lastTimeWarp > character.timeWarpCooldown) {
                        this.gameState.timeSlowEffect = 0.5;
                        character.isTimeWarp = true;
                        this.createFloatingText(character.x + character.width/2, character.y-20, '시간 왜곡!', 'blue');
                        setTimeout(() => {
                            this.gameState.timeSlowEffect = 1;
                            character.isTimeWarp = false;
                        }, character.timeWarpDuration);
                        character.lastTimeWarp = now;
                    }
                    // 2. 연발 사격
                    if (!character.isRapidFire && now - character.lastRapidFire > character.rapidFireCooldown) {
                        character.isRapidFire = true;
                        this.createFloatingText(character.x + character.width/2, character.y-20, '연발 사격!', 'orange');
                        let shots = 0;
                        const rapid = () => {
                            if (shots < 10) {
                                const angle = Math.atan2(player.y - character.y, player.x - character.x) + (Math.random()-0.5)*0.3;
                                this.gameState.projectiles.push({
                                    id: Date.now() + Math.random(),
                                    x: character.x + character.width / 2,
                                    y: character.y + character.height / 2,
                                    vx: Math.cos(angle) * 12,
                                    vy: Math.sin(angle) * 12,
                                    radius: 5,
                                    damage: character.damage * 0.7,
                                    life: 90,
                                    color: character.color,
                                    ownerId: character.id
                                });
                                shots++;
                                setTimeout(rapid, 80);
                            } else {
                                character.isRapidFire = false;
                            }
                        };
                        rapid();
                        character.lastRapidFire = now;
                    }
                    // 3. 랜덤 위치 이동
                    if (now - character.lastRandomMove > character.randomMoveCooldown) {
                        character.x = Math.random() * (this.canvas.width - character.width);
                        character.y = Math.random() * (this.canvas.height - this.GROUND_Y - character.height);
                        this.createCollectParticles(character.x, character.y, character.color);
                        this.createFloatingText(character.x + character.width/2, character.y-20, '순간이동!', 'cyan');
                        character.lastRandomMove = now;
                    }
                }
                if (character.type === 'boss_eta') {
                    // 1. 레이저
                    if (now - character.lastLaser > character.laserCooldown) {
                        const angle = Math.atan2(player.y - character.y, player.x - character.x);
                        for (let d = 60; d < 400; d += 40) {
                            const lx = character.x + character.width/2 + Math.cos(angle) * d;
                            const ly = character.y + character.height/2 + Math.sin(angle) * d;
                            this.createExplosion(lx, ly, 40, character.damage * 1.2, character.id);
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, '레이저!', 'red');
                        character.lastLaser = now;
                    }
                    // 2. 연속 점프
                    if (now - character.lastJump > character.jumpCooldown) {
                        let jumpIdx = 0;
                        const jump = () => {
                            if (jumpIdx < character.jumpCount) {
                                character.vy = -character.jumpPower;
                                this.createFloatingText(character.x + character.width/2, character.y-20, '점프!', 'lime');
                                jumpIdx++;
                                setTimeout(jump, 400);
                            }
                        };
                        jump();
                        character.lastJump = now;
                    }
                    // 3. 방어력 증가
                    if (!character.isArmorBuffed && now - character.lastArmorBuff > character.armorBuffCooldown) {
                        character.armor = (character.armor || 0) + 20;
                        character.isArmorBuffed = true;
                        this.createFloatingText(character.x + character.width/2, character.y-20, '방어력 증가!', 'blue');
                        setTimeout(() => {
                            character.armor = (character.armor || 0) - 20;
                            character.isArmorBuffed = false;
                        }, character.armorBuffDuration);
                        character.lastArmorBuff = now;
                    }
                }
                if (character.type === 'boss_theta') {
                    // 1. 발사체 반사
                    if (!character.isReflecting && now - character.lastReflectAll > character.reflectAllCooldown) {
                        character.isReflecting = true;
                        this.createFloatingText(character.x + character.width/2, character.y-20, '발사체 반사!', 'cyan');
                        setTimeout(() => { character.isReflecting = false; }, character.reflectAllDuration);
                        character.lastReflectAll = now;
                    }
                    // 2. 도탄 탄환
                    if (now - character.lastRicochet > character.ricochetCooldown) {
                        for (let i = 0; i < character.ricochetCount; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            this.gameState.projectiles.push({
                                id: Date.now() + Math.random(),
                                x: character.x + character.width / 2,
                                y: character.y + character.height / 2,
                                vx: Math.cos(angle) * 10,
                                vy: Math.sin(angle) * 10,
                                radius: 5,
                                damage: character.damage * 0.7,
                                life: 120,
                                color: character.color,
                                ownerId: character.id,
                                bounceCount: 2
                            });
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, '도탄!', 'orange');
                        character.lastRicochet = now;
                    }
                    // 3. 플레이어 위치 추적
                    if (!character.isTracking && now - character.lastTrack > character.trackCooldown) {
                        character.isTracking = true;
                        this.createFloatingText(character.x + character.width/2, character.y-20, '위치 추적!', 'red');
                        setTimeout(() => { character.isTracking = false; }, character.trackDuration);
                        character.lastTrack = now;
                    }
                }
            }
            
            // 발사체 상태 업데이트 및 충돌 감지 (유령 무적 상태 처리 추가)
            updateProjectiles = () => {
                // Homing logic: adjust velocity of homing projectiles
                for (let i = 0; i < this.gameState.projectiles.length; i++) {
                    const p = this.gameState.projectiles[i];
                    if (p.isHoming) {
                        let nearest = null, minDist = 99999;
                        for (const enemy of this.gameState.enemies) {
                            const dx = enemy.x + enemy.width/2 - p.x;
                            const dy = enemy.y + enemy.height/2 - p.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist < minDist) { minDist = dist; nearest = enemy; }
                        }
                        // Homing parameters
                        const maxTurn = (p.homingStrength || 0.08) * Math.PI; // 최대 회전 각도 (라디안)
                        const speed = Math.sqrt(p.vx*p.vx + p.vy*p.vy) || 8;
                        if (nearest) {
                            const dx = nearest.x + nearest.width/2 - p.x;
                            const dy = nearest.y + nearest.height/2 - p.y;
                            const targetAngle = Math.atan2(dy, dx);
                            let currentAngle = Math.atan2(p.vy, p.vx);
                            let delta = targetAngle - currentAngle;
                            // -PI ~ PI로 보정
                            while (delta > Math.PI) delta -= 2*Math.PI;
                            while (delta < -Math.PI) delta += 2*Math.PI;
                            // 회전 각도 제한
                            if (Math.abs(delta) > maxTurn) delta = maxTurn * Math.sign(delta);
                            const newAngle = currentAngle + delta;
                            p.vx = Math.cos(newAngle) * speed;
                            p.vy = Math.sin(newAngle) * speed;
                        } else {
                            // 적이 없으면 기존 방향/속도 유지 (정지하지 않음)
                            // 아무것도 하지 않음
                        }
                    }
                }
                const projectilesToRemove = new Set();
                const player = this.gameState.player;
                // 1. 발사체 이동/수명
                for (let i = 0; i < this.gameState.projectiles.length; i++) {
                    const p = this.gameState.projectiles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life--;
                    if (
                        p.x < -100 || p.x > this.canvas.width + 100 ||
                        p.y < -100 || p.y > this.canvas.height + 100 ||
                        p.life <= 0
                    ) {
                        projectilesToRemove.add(i);
                        continue;
                    }
                }
                // 2. 플레이어 발사체 → 적 충돌
                for (let i = 0; i < this.gameState.projectiles.length; i++) {
                    const p = this.gameState.projectiles[i];
                    if (p.ownerId === 'player') {
                        for (let j = 0; j < this.gameState.enemies.length; j++) {
                            const enemy = this.gameState.enemies[j];
                            if (!enemy) continue;
                            const dx = p.x - (enemy.x + enemy.width / 2);
                            const dy = p.y - (enemy.y + enemy.height / 2);
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < (p.radius || 0) + (enemy.width || 0) / 2) {
                                // 유령/보스 쉴드 무적 체크
                                if (enemy.type === 'ghost' && enemy.isInvincible) continue;
                                if (enemy.type === 'boss_beta' && enemy.isInvincible) continue;
                                enemy.health -= p.damage;
                                this.createFloatingText(enemy.x + enemy.width / 2, enemy.y, `-${p.damage}`, 'white');
                                this.createHitParticles(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                                // 폭발 사격
                                if (p.explosiveRadius && p.explosiveRadius > 0) {
                                    this.createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, p.explosiveRadius, p.damage, p.ownerId);
                                }
                                // 분열 사격
                                if (p.splitCount && p.splitCount > 0) {
                                    this.createSplitProjectiles(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, p.damage, p.ownerId, p.radius, p.splitCount);
                                }
                                if (enemy.health <= 0) {
                                    this.addScore(enemy.points || 100);
                                    if (Math.random() < 0.4) this.gameState.items.push(this.createItem(enemy.x, enemy.y));
                                    this.gameState.enemies = this.gameState.enemies.filter(e => e !== enemy);
                                }
                                projectilesToRemove.add(i);
                                break;
                            }
                        }
                    }
                }
                // 3. 적 발사체 → 플레이어 충돌
                for (let i = 0; i < this.gameState.projectiles.length; i++) {
                    const p = this.gameState.projectiles[i];
                    // Only enemy bullets (not player or ally) can hit the player
                    if (p.ownerId && p.ownerId !== 'player' && p.ownerId !== 'ally') {
                        const dx = p.x - (player.x + player.width / 2);
                        const dy = p.y - (player.y + player.height / 2);
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < (p.radius || 0) + (player.width || 0) / 2) {
                            // 무적 체크
                            if (Date.now() < player.invincibleEndTime) {
                                this.createFloatingText(player.x + player.width / 2, player.y, `무적!`, 'gold');
                            } else {
                                let actualDamage = p.damage;
                                actualDamage = Math.max(0, actualDamage - player.armor);
                                if (Date.now() < player.shieldBoostEndTime) {
                                    actualDamage *= player.damageReductionFactor;
                                    this.createFloatingText(player.x + player.width / 2, player.y, `-${actualDamage.toFixed(0)} (쉴드)`, 'lightblue');
                                } else {
                                    this.createFloatingText(player.x + player.width / 2, player.y, `-${actualDamage.toFixed(0)}`, 'red');
                                }
                                player.health -= actualDamage;
                                this.createHitParticles(player.x + player.width / 2, player.y + player.height / 2);
                                player.lastHitById = p.ownerId;
                                if (player.health <= 0) this.gameOver();
                            }
                            projectilesToRemove.add(i);
                        }
                    }
                }
                // 4. 발사체끼리 충돌(플레이어 vs 적)
                for (let i = 0; i < this.gameState.projectiles.length; i++) {
                    const p1 = this.gameState.projectiles[i];
                    if (p1.ownerId === 'player') {
                        for (let j = 0; j < this.gameState.projectiles.length; j++) {
                            if (i === j) continue;
                            const p2 = this.gameState.projectiles[j];
                            if (p2.ownerId && p2.ownerId !== 'player' && p2.ownerId !== 'ally') {
                                const dx = p1.x - p2.x;
                                const dy = p1.y - p2.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist < (p1.radius || 0) + (p2.radius || 0)) {
                                    projectilesToRemove.add(i);
                                    projectilesToRemove.add(j);
                                }
                            }
                        }
                    }
                }
                // 실제로 제거
                this.gameState.projectiles = this.gameState.projectiles.filter((_, idx) => !projectilesToRemove.has(idx));
            };

            // 분열 사격 (Split Shot) 시 작은 발사체 생성
            createSplitProjectiles = (x, y, baseDamage, ownerId, parentRadius, splitLevel) => {
                const numSplits = 3 + splitLevel; // 레벨에 따라 분열되는 작은 탄환 수 증가
                const splitSpeed = 5; // 작은 탄환 속도
                const splitDamage = baseDamage * 0.5; // 작은 탄환 데미지 (원본의 절반)
                const splitRadius = parentRadius / 1.5; // 작은 탄환 반지름

                for (let i = 0; i < numSplits; i++) {
                    const splitAngle = Math.random() * Math.PI * 2; // 무작위 방향
                    this.gameState.projectiles.push({
                        id: Date.now() + Math.random(),
                        x: x,
                        y: y,
                        vx: Math.cos(splitAngle) * splitSpeed,
                        vy: Math.sin(splitAngle) * splitSpeed,
                        radius: 3, // 기존 7에서 4로 하향
                        damage: splitDamage,
                        life: 60, // 짧은 수명
                        color: '#9932cc', // 분열 사격 색상
                        ownerId: ownerId,
                        pierceCount: 0,
                        explosiveRadius: 0,
                        bounceCount: 0,
                        isHoming: false,
                        homingStrength: 0,
                        splitCount: 0, // 분열된 탄환은 다시 분열하지 않음
                        hitEnemies: []
                    });
                }
            }

            // 폭발 효과 생성 (수류탄 폭발에만 사용됨)
            createExplosion = (x, y, radius, damage, ownerId) => { // ownerId 추가
                // 파티클 생성
                for (let i = 0; i < 30; i++) {
                    this.gameState.particles.push({
                        x: x, y: y,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        life: 40, maxLife: 40,
                        color: '#ff4500', // 주황색 폭발 색상
                        size: Math.random() * 5 + 2
                    });
                }

                // 플레이어에게 범위 피해 적용 (수류탄 폭발에만 해당)
                const player = this.gameState.player;
                let dx = x - (player.x + player.width / 2);
                let dy = y - (player.y + player.height / 2);
                let distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < radius + player.width / 2) {
                    // 플레이어 무적 상태 체크
                    if (Date.now() < player.invincibleEndTime) {
                        this.createFloatingText(player.x + player.width / 2, player.y, `무적!`, 'gold');
                    } else {
                        // 플레이어가 발사한 수류탄 폭발에는 피해를 입지 않도록
                        if (ownerId === 'player') {
                            this.createFloatingText(player.x + player.width / 2, player.y, `회피!`, 'cyan');
                            // 수류탄 폭발에 의한 사망은 기록하지 않음
                            return; 
                        }

                        let actualDamage = damage;
                        // 방어력 적용
                        actualDamage = Math.max(0, actualDamage - this.gameState.player.armor);
                        if (Date.now() < player.shieldBoostEndTime) {
                            actualDamage *= player.damageReductionFactor;
                            this.createFloatingText(player.x + player.width / 2, player.y, `-${actualDamage.toFixed(0)} (쉴드)`, 'lightblue');
                        } else {
                            this.createFloatingText(player.x + player.width / 2, player.y, `-${actualDamage.toFixed(0)}`, 'red'); // 데미지 텍스트
                        }
                        player.health -= actualDamage;
                        this.createHitParticles(player.x + player.width / 2, player.y + player.height / 2);
                        
                        // 폭발로 인한 피해일 경우 마지막 피해자 ID 저장 (수류탄이 아닌 다른 폭발에 대비)
                        this.gameState.player.lastHitById = ownerId;

                        if (player.health <= 0) {
                            this.gameOver();
                        }
                    }
                }

                // 적들에게 범위 피해 적용 (수류탄 폭발에만 해당)
                this.gameState.enemies.forEach(enemy => {
                    dx = x - (enemy.x + enemy.width / 2);
                    dy = y - (enemy.y + enemy.height / 2);
                    distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < radius + enemy.width / 2) {
                        // 유령 무적 상태 체크
                        if (enemy.type === 'ghost' && enemy.isInvincible) return;
                        // 베타 보스 쉴드 체크
                        if (enemy.type === 'boss_beta' && enemy.isInvincible) return;
                        // 방패병 방어 체크 (폭발은 전방/후방 상관없이 피해)
                        if (enemy.type === 'shielded') {
                            enemy.health -= damage * 0.5; // 방패병은 폭발 피해 50% 감소
                            this.createFloatingText(enemy.x + enemy.width / 2, enemy.y, `-${(damage * 0.5).toFixed(0)} (방어)`, 'orange');
                        } else {
                            enemy.health -= damage; // 적에게도 동일한 폭발 데미지
                            this.createFloatingText(enemy.x + enemy.width / 2, enemy.y, `-${damage}`, 'white');
                        }
                        this.createHitParticles(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                        if (enemy.health <= 0) {
                            // 적 처치 로직 (점수, 아이템 드롭 등)
                            this.addScore(enemy.points || 100);
                            if (Math.random() < 0.4) this.gameState.items.push(this.createItem(enemy.x, enemy.y));
                            this.gameState.enemies = this.gameState.enemies.filter(e => e.id !== enemy.id);
                        }
                    }
                });

                // 아군에게 범위 피해 적용
                this.gameState.allies.forEach(ally => {
                    dx = x - (ally.x + ally.width / 2);
                    dy = y - (ally.y + ally.height / 2);
                    distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < radius + ally.width / 2) {
                         // 아군이 발사한 수류탄 폭발에는 피해를 입지 않도록
                        if (ownerId === ally.id) {
                            this.createFloatingText(ally.x + ally.width / 2, ally.y, `회피!`, 'cyan');
                            return; 
                        }

                        ally.health -= damage;
                        this.createFloatingText(ally.x + ally.width / 2, ally.y, `-${damage}`, 'orange');
                        this.createHitParticles(ally.x + ally.width / 2, ally.y + ally.height / 2);
                        if (ally.health <= 0) {
                            this.gameState.allies = this.gameState.allies.filter(a => a.id !== ally.id);
                            this.createFloatingText(ally.x + ally.width / 2, ally.y, `사망!`, 'grey');
                        }
                    }
                });
            }
            
            // 아이템 상태 업데이트 및 플레이어 충돌 감지
            updateItems = () => {
                const player = this.gameState.player;
                const now = Date.now();

                // 자석 효과 적용
                if (now < player.magnetEndTime) {
                    this.gameState.items.forEach(item => {
                        const dx = (player.x + player.width / 2) - (item.x + item.width / 2);
                        const dy = (player.y + player.height / 2) - (item.y + item.height / 2);
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < player.magnetRadius) {
                            const force = 0.5; // 자석 힘
                            item.vx += (dx / distance) * force;
                            item.vy += (dy / distance) * force;
                        }
                    });
                }


                this.gameState.items = this.gameState.items.filter(item => {
                    if (item.collected) return false; // 이미 수집된 아이템은 제거
                    
                    // 중력 적용
                    if (!item.onGround) {
                        item.vy += this.GRAVITY;
                    }
                    
                    // 지면 충돌 처리 (바운스 효과)
                    if (item.y + item.height > this.canvas.height - this.GROUND_Y) {
                        item.y = this.canvas.height - this.GROUND_Y - item.height;
                        item.vy = -item.vy * 0.5; // 바운스 효과
                        if (Math.abs(item.vy) < 2) {
                            item.vy = 0;
                            item.onGround = true;
                        }
                    }
                    
                    // 위치 업데이트
                    item.x += item.vx;
                    item.y += item.vy;
                    
                    // 마찰 적용
                    item.vx *= 0.98;
                    
                    // 화면 경계 제한
                    item.x = Math.max(0, Math.min(this.canvas.width - item.width, item.x));
                    
                    // 지면에 있을 때만 떠다니는 애니메이션
                    if (item.onGround) {
                        item.y += Math.sin(Date.now() * 0.003 + item.bobOffset) * 1;
                    }
                    
                    // 플레이어와 충돌 체크
                    if (player.x < item.x + item.width &&
                        player.x + player.width > item.x &&
                        player.y < item.y + item.height &&
                        player.y + player.height > item.y) {
                        
                        this.collectItem(item); // 아이템 수집
                        return false; // 아이템 제거
                    }
                    
                    return true; // 아이템 유지
                });
            }
            
            // 아이템 수집 시 효과 적용
            collectItem = (item) => {
                const player = this.gameState.player;
                const now = Date.now();
                
                switch (item.type) {
                    case 'health':
                        player.health = Math.min(player.maxHealth, player.health + item.effect);
                        this.createFloatingText(player.x + player.width / 2, player.y, `+${item.effect}`, 'green'); // 체력 텍스트
                        this.showMessage(`+${item.effect} 체력!`, '', 1500);
                        break;
                    case 'ammo':
                        player.ammo = Math.min(player.maxAmmo, player.ammo + item.effect);
                        this.createFloatingText(player.x + player.width / 2, player.y, `+${item.effect}`, 'blue'); // 탄약 텍스트
                        this.showMessage(`+${item.effect} 탄약!`, '', 1500);
                        break;
                    case 'speed':
                        player.speed = Math.min(10, player.speed + item.effect);
                        this.showMessage(`속도 증가!`, `+${item.effect}`, 1500);
                        break;
                    case 'shield':
                        player.maxHealth += item.effect;
                        player.health = Math.min(player.maxHealth, player.health + item.effect); // 최대 체력 증가 시 현재 체력도 증가
                        this.showMessage(`방어막 강화!`, `+${item.effect} 최대 체력`, 1500);
                        break;
                    case 'damage':
                        player.baseDamage = (player.baseDamage || 25) + item.effect; // 기본 공격력 25로 수정 반영
                        this.showMessage(`공격력 증가!`, `+${item.effect} 데미지`, 1500);
                        break;
                    case 'multishot':
                        player.multishot = Math.min(99, (player.multishot || 1) + 1);
                        this.showMessage(`다중 발사!`, `${player.multishot}발 동시 발사`, 2000);
                        break;
                    case 'megahealth':
                        player.health = Math.min(player.maxHealth, player.health + item.effect);
                        this.createFloatingText(player.x + player.width / 2, player.y, `+${item.effect}`, 'lime'); // 메가 힐링 텍스트
                        this.showMessage(`메가 힐링!`, `+${item.effect} 체력`, 2000);
                        break;
                    case 'rapid':
                        player.rapidFireTime = (Date.now() + 10000); // 10초간 빠른 발사
                        this.showMessage(`연발 모드!`, '10초간 빠른 발사', 2000);
                        break;
                    case 'invincibility':
                        player.invincibleEndTime = now + item.effect;
                        this.showMessage(`무적!`, `${item.effect / 1000}초간 무적`, 2000);
                        break;
                    case 'grenade':
                        this.throwGrenade(); // 수류탄 투척
                        this.showMessage(`수류탄!`, `적들을 날려버리세요!`, 1500);
                        break;
                    case 'shield_boost':
                        player.shieldBoostEndTime = now + item.duration;
                        player.damageReductionFactor = item.effect;
                        this.showMessage(`쉴드 강화!`, `받는 피해 ${item.effect * 100}% 감소`, 2000);
                        break;
                    case 'time_slow':
                        this.gameState.timeSlowEndTime = now + item.duration;
                        this.gameState.timeSlowEffect = item.effect;
                        this.showMessage(`시간 둔화!`, `모든 적 느려짐`, 2000);
                        break;
                    case 'magnet':
                        player.magnetEndTime = now + item.duration;
                        this.showMessage(`자석!`, `아이템을 끌어당깁니다`, 2000);
                        break;
                    case 'health_regen':
                        player.healthRegenEndTime = now + item.duration;
                        player.lastRegenTick = now; // 첫 틱은 바로 적용
                        player.effect = item.effect; // 체력 재생량 저장
                        player.tickInterval = item.tickInterval; // 체력 재생 간격 저장
                        this.showMessage(`체력 재생!`, `${item.duration / 1000}초간 체력 회복`, 2000);
                        break;
                    case 'ally_summon':
                        this.showMessage(`아군 소환!`, `든든한 아군이 합류합니다!`, 2000);
                        this.spawnAlly(player.x + (player.width / 2), player.y + (player.height / 2)); // 플레이어 위치에 소환
                        break;
                    case 'orbiting_knife':
                        player.orbitingKnives.push({
                            angle: Math.random() * Math.PI * 2, // 초기 무작위 각도
                            radius: 60, // 플레이어로부터의 거리
                            speed: 0.05, // 각속도
                            damage: 15, // 칼날 공격력
                            lastHit: 0, // 마지막 공격 시간 (쿨다운용)
                            cooldown: 200, // 공격 쿨다운 (ms)
                            color: this.ITEM_TYPES.find(i => i.type === 'orbiting_knife').color, // 아이템 타입에서 색상 가져오기
                            emoji: this.ITEM_TYPES.find(i => i.type === 'orbiting_knife').emoji // 아이템 타입에서 이모지 가져오기
                        });
                        this.showMessage(`회전 칼날 획득!`, `플레이어 주위를 돕니다!`, 2000);
                        break;
                    case 'piercing_shot':
                        player.piercingShot = Math.min(99, player.piercingShot + item.effect);
                        this.showMessage(`관통 사격!`, `탄환이 적을 관통합니다! (Lv.${player.piercingShot})`, 2000);
                        break;
                    case 'explosive_shot':
                        player.explosiveShot = Math.min(99, player.explosiveShot + item.effect);
                        this.showMessage(`폭발 사격!`, `탄환이 폭발합니다! (Lv.${player.explosiveShot})`, 2000);
                        break;
                    case 'ricochet_shot':
                        player.ricochetLevel = Math.min(99, player.ricochetLevel + item.effect);
                        this.showMessage(`도탄 사격!`, `탄환이 벽에서 튕겨 나갑니다! (Lv.${player.ricochetLevel})`, 2000);
                        break;
                    case 'homing_shot':
                        player.homingLevel = Math.min(99, player.homingLevel + item.effect);
                        this.showMessage(`유도 사격!`, `탄환이 적을 추적합니다! (Lv.${player.homingLevel})`, 2000);
                        break;
                    case 'split_shot':
                        player.splitLevel = Math.min(99, player.splitLevel + item.effect);
                        this.showMessage(`분열 사격!`, `탄환이 분열하여 추가 피해를 줍니다! (Lv.${player.splitLevel})`, 2000);
                        break;
                    case 'life_steal':
                        player.lifeStealPercent = Math.min(0.2, player.lifeStealPercent + item.effect); // 최대 20%
                        this.showMessage(`생명력 흡수!`, `피해량의 ${(player.lifeStealPercent * 100).toFixed(0)}% 체력 회복!`, 2000);
                        break;
                    case 'crit_chance':
                        player.critChance = Math.min(0.5, player.critChance + item.effect); // 최대 50%
                        this.showMessage(`치명타 확률!`, `치명타 확률 ${(player.critChance * 100).toFixed(0)}%`, 2000);
                        break;
                    case 'cooldown_reduction':
                        player.cooldownReduction = Math.min(0.5, player.cooldownReduction + item.effect); // 최대 50%
                        this.showMessage(`재사용 대기시간 감소!`, `발사 속도 ${(player.cooldownReduction * 100).toFixed(0)}% 증가!`, 2000);
                        break;
                    case 'armor':
                        player.armor += item.effect;
                        this.showMessage(`방어력!`, `피해량 ${item.effect} 감소!`, 2000);
                        break;
                    case 'time_stop':
                        this.gameState.timeStopEndTime = now + item.effect;
                        this.gameState.timeSlowEffect = 0; // 모든 적 정지
                        this.showMessage(`시간 정지!`, `${item.effect / 1000}초간 모든 적 정지!`, 2000);
                        break;
                    case 'ammo_regen':
                        player.ammoRegenEndTime = now + item.duration;
                        player.lastAmmoRegenTick = now;
                        player.ammoRegenAmount = item.effect;
                        this.showMessage(`탄약 재생!`, `${item.duration / 1000}초간 탄약 자동 회복!`, 2000);
                        break;
                }
                
                this.createCollectParticles(item.x, item.y, item.color); // 아이템 수집 파티클 생성
                this.addScore(50); // 아이템 수집 시 점수 획득
                this.updateHUD(); // HUD 업데이트
            }
            
            // 피격 파티클 생성
            createHitParticles = (x, y) => {
                for (let i = 0; i < 6; i++) {
                    this.gameState.particles.push({
                        x: x, y: y,
                        vx: (Math.random() - 0.5) * 6, // 무작위 X 속도
                        vy: (Math.random() - 0.5) * 6, // 무작위 Y 속도
                        life: 30, maxLife: 30, // 수명
                        color: '#ff6b6b', // 색상 (빨간색)
                        size: Math.random() * 3 + 1 // 크기
                    });
                }
            }
            
            // 아이템 수집 파티클 생성
            createCollectParticles = (x, y, color) => {
                for (let i = 0; i < 8; i++) {
                    this.gameState.particles.push({
                        x: x, y: y,
                        vx: (Math.random() - 0.5) * 4, // 무작위 X 속도
                        vy: (Math.random() - 0.5) * 4, // 무작위 Y 속도
                        life: 40, maxLife: 40, // 수명
                        color: color, // 아이템 색상
                        size: Math.random() * 4 + 2 // 크기
                    });
                }
            }

            // 떠다니는 텍스트 생성 (체력 변화 등)
            createFloatingText = (x, y, text, color) => {
                this.gameState.floatingTexts.push({
                    x: x,
                    y: y,
                    text: text,
                    color: color,
                    life: 60, // 텍스트 수명 (프레임)
                    maxLife: 60,
                    vy: -1 // 위로 이동하는 속도
                });
            }
            
            // 파티클 상태 업데이트
            updateParticles = () => {
                this.gameState.particles = this.gameState.particles.filter(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vx *= 0.98; // 속도 감소 (마찰)
                    particle.vy *= 0.98; // 속도 감소 (마찰)
                    particle.life--; // 수명 감소
                    
                    return particle.life > 0; // 수명이 남은 파티클만 유지
                });
            }

            // 떠다니는 텍스트 상태 업데이트
            updateFloatingTexts = () => {
                this.gameState.floatingTexts = this.gameState.floatingTexts.filter(text => {
                    text.y += text.vy; // 위로 이동
                    text.life--; // 수명 감소
                    return text.life > 0; // 수명이 남은 텍스트만 유지
                });
            }
            
            // 웨이브 완료 체크
            checkWaveComplete = () => {
                if (this.gameState.enemies.length === 0 && this.gameState.gameStatus === 'playing') {
                    this.gameState.gameStatus = 'wave-complete';
                    this.showMessage(`웨이브 ${this.gameState.wave} 완료!`, '다음 웨이브 준비 중...', 3000);
                    this.gameState.wave++;
                    setTimeout(() => {
                        this.gameState.gameStatus = 'spawning';
                        this.spawnInitialWave();
                        this.gameState.gameStatus = 'playing';
                    }, 3000);
                }
            }
            
            // 게임 오버 처리
            gameOver = () => {
                this.gameState.gameStatus = 'game-over'; // 게임 상태를 '게임 오버'로 변경
                this.showMessage('게임 오버!', `최종 점수: ${this.gameState.score.toLocaleString()}`, 5000, true);
                // 어떤 적에게 죽었는지 콘솔에 출력
                const lastHitById = this.gameState.player.lastHitById;
                if (lastHitById) {
                    // lastHitById가 적의 ID일 경우 해당 적의 정보를 찾음
                    const killerEnemy = Object.values(this.ENEMY_TYPES).find(enemyType => 
                        this.gameState.enemies.some(enemy => enemy.id === lastHitById && enemy.type === enemyType.type)
                    );
                    if (killerEnemy) {
                        console.log(`플레이어가 '${killerEnemy.name}'에게 사망했습니다.`);
                    } else if (lastHitById === 'player') { // 플레이어 스스로에게 피해를 입은 경우 (수류탄 등)
                        console.log('플레이어가 스스로에게 피해를 입어 사망했습니다.');
                    } else {
                        console.log(`플레이어가 알 수 없는 적에게 사망했습니다 (ID: ${lastHitById}).`);
                    }
                } else {
                    console.log('플레이어가 적에게 직접적인 공격 없이 사망했습니다 (예: 낙사).');
                }
                // 5초 후 게임 재시작 (시작 화면으로 돌아가지 않음)
                const restartBtn = document.getElementById('restartButton');
                restartBtn.style.display = 'block';
                restartBtn.onclick = () => {
                    restartBtn.style.display = 'none';
                    this.resetGame();
                };
            }
            
            // 게임 초기화
            resetGame = () => {
                // 게임 상태를 초기값으로 재설정
                this.gameState = {
                    player: {
                        x: this.canvas.width / 2, y: this.canvas.height / 2,
                        width: 40, height: 40,
                        vx: 0, vy: 0,
                        health: 150, maxHealth: 150, // 기본값 100으로 변경
                        ammo: 30, maxAmmo: 30, // 기본값 100으로 변경
                        speed: 5, jumpPower: 15,
                        onGround: false, facing: 0,
                        expression: this.getRandomExpression(),
                        color: '#6366f1',
                        baseDamage: 10, // 기본값 10으로 변경
                        multishot: 1,
                        rapidFireTime: 0,
                        damageReductionFactor: 1,
                        shieldBoostEndTime: 0,
                        healthRegenEndTime: 0,
                        lastRegenTick: 0,
                        magnetEndTime: 0,
                        magnetRadius: 200,
                        lastHitById: null, // 초기화
                        type: 'player', // 플레이어 타입
                        orbitingKnives: [], // 회전 칼날 초기화
                        piercingShot: 0, // 관통 사격 초기화
                        explosiveShot: 0, // 폭발 사격 초기화
                        ricochetLevel: 0, // 도탄 사격 초기화
                        homingLevel: 0, // 유도 사격 초기화
                        splitLevel: 0, // 분열 사격 초기화
                        lifeStealPercent: 0, // 생명력 흡수 초기화
                        critChance: 0, // 치명타 확률 초기화
                        critMultiplier: 1.5, // 치명타 배율 초기화
                        cooldownReduction: 0, // 재사용 대기시간 감소 초기화
                        armor: 0, // 방어력 초기화
                        timeStopEndTime: 0, // 시간 정지 초기화
                        ammoRegenEndTime: 0, // 탄약 재생 초기화
                        lastAmmoRegenTick: 0, // 마지막 탄약 재생 틱 초기화
                        ammoRegenAmount: 0, // 탄약 재생량 초기화
                        dashCooldown: 0, // 마지막 대시 시각
                        dashEndTime: 0, // 대시 종료 시각
                        isDashing: false, // 대시 중 여부
                        reloadTime: 1500, // 기본 재장전 시간(ms)
                        isReloading: false,
                        machineGunMode: false, // 기관단총 패시브
                        machineGunPenalty: false, // 기관단총 패널티
                        reloadPenalty: 0, // 패시브로 인한 추가 재장전 시간(ms)
                        gunRecoil: 0,
                        gunRecoilTarget: 0,
                    },
                    enemies: [],
                    projectiles: [],
                    items: [],
                    particles: [],
                    floatingTexts: [],
                    allies: [], // 아군 배열 초기화
                    score: 0,
                    wave: 1,
                    gameStatus: 'playing', // 게임 오버 후 바로 플레이 상태로 전환
                    message: '',
                    messageTimer: 0,
                    playerSlowedEndTime: 0,
                    timeSlowEndTime: 0,
                    timeSlowEffect: 1
                };
                
                this.spawnInitialWave(); // 새 게임 시작 시 초기 웨이브 생성
                this.updateHUD(); // HUD 업데이트 (초기화된 값으로)
                this.hideMessage(); // 메시지 숨기기
                this.gameLoop(); // 게임 루프 재시작
            }

            // 게임 메시지 표시
            showMessage = (text, subText, duration, showRestart) => {
                const messageEl = document.getElementById('gameMessage');
                const messageTextEl = document.getElementById('messageText');
                const messageSubTextEl = document.getElementById('messageSubText');
                const restartBtn = document.getElementById('restartButton');
                messageTextEl.textContent = text;
                messageSubTextEl.textContent = subText;
                messageEl.style.display = 'block';
                if (showRestart) {
                    restartBtn.style.display = 'block';
                } else if (restartBtn) {
                    restartBtn.style.display = 'none';
                }
                if (!showRestart) {
                    setTimeout(() => {
                        this.hideMessage();
                    }, duration);
                }
            }
            
            // 게임 메시지 숨기기
            hideMessage = () => {
                document.getElementById('gameMessage').style.display = 'none';
            }

            // 보상 선택 화면 표시
            showRewardSelection = (type = 'score') => {
                this.canvas.style.filter = 'blur(10px)';
                document.querySelector('.hud').style.display = 'none';
                document.getElementById('rewardSelectionScreen').style.display = 'flex';
                const titleEl = document.getElementById('rewardSelectionTitle');
                if (type === 'boss') {
                    titleEl.textContent = '보스 처치! 보상을 선택하세요.';
                } else {
                    titleEl.textContent = '점수 달성! 보상을 선택하세요.';
                }
                const rewardOptionsEl = document.getElementById('rewardOptions');
                rewardOptionsEl.innerHTML = '';
                const shuffledRewards = [...this.REWARD_OPTIONS].sort(() => 0.5 - Math.random());
                const selectedRewards = shuffledRewards.slice(0, 3);
                selectedRewards.forEach(option => {
                    const button = document.createElement('button');
                    button.className = 'reward-button';
                    button.textContent = option.text;
                    button.addEventListener('click', () => {
                        this.applyReward(option.type, option.value);
                        this.hideRewardSelection();
                        this.gameState.gameStatus = 'playing';
                        this.updateHUD();
                        if (typeof this.gameLoop === 'function') {
                            this.gameLoop();
                        }
                    });
                    rewardOptionsEl.appendChild(button);
                });
            };

            // 보상 선택 화면 숨기기
            hideRewardSelection = () => {
                this.canvas.style.filter = 'blur(0px)'; // 캔버스 블러 제거
                document.querySelector('.hud').style.display = 'flex'; // HUD 표시
                document.getElementById('rewardSelectionScreen').style.display = 'none'; // 보상 화면 숨김
            }

            // 선택된 보상 적용
            applyReward = (type, value) => {
                const player = this.gameState.player;
                switch (type) {
                    case 'tank':
                        player.maxHealth += 100;
                        player.health = Math.min(player.maxHealth, player.health + 100);
                        player.speed -= 4;
                        this.showMessage('탱크가 되어!', '최대 체력 +100, 이동 속도 -4', 2000);
                        break;
                    case 'speedster':
                        player.speed += 10;
                        player.dashCooldown = Math.max(0, player.dashCooldown - 10000);
                        player.baseDamage *= 0.95;
                        player.reloadPenalty += 3000;
                        this.showMessage('빨라진다아아아아!', '속도 +10, 대시 쿨타임 -10초, 공격력 -5%, 재장전 +3초', 2000);
                        break;
                    case 'machine_gun':
                        player.machineGunMode = true;
                        player.machineGunPenalty = true;
                        player.reloadPenalty += 5000;
                        this.showMessage('기관단총!', '연사, 재장전 +5초, 공격력 -50%', 2000);
                        break;
                    case 'homing_master':
                        player.homingLevel = 3;
                        player.homingPenalty = true;
                        this.showMessage('유도탄!', '유도탄 Lv.3, 공격력 -5%', 2000);
                        break;
                    case 'ricochet_shot':
                        player.ricochetLevel = 1;
                        this.showMessage('탱탱볼!', '총알이 벽에 튕김', 2000);
                        break;
                    case 'vampire':
                        player.lifeStealPercent += 0.03;
                        player.reloadPenalty += 2000;
                        this.showMessage('뱀파이어!', '흡혈, 재장전 +2초', 2000);
                        break;
                    case 'knife_shield':
                        for (let i = 0; i < 3; i++) {
                            player.orbitingKnives.push({
                                angle: Math.random() * Math.PI * 2,
                                radius: 60,
                                speed: 0.05,
                                damage: 15,
                                lastHit: 0,
                                cooldown: 200,
                                color: this.ITEM_TYPES.find(i => i.type === 'orbiting_knife').color,
                                emoji: this.ITEM_TYPES.find(i => i.type === 'orbiting_knife').emoji
                            });
                        }
                        this.showMessage('칼날이 나를 감싸네!', '칼날 3개 생성', 2000);
                        break;
                    case 'crit_master':
                        player.critChance += 0.2;
                        player.maxHealth = Math.floor(player.maxHealth * 0.9);
                        player.health = Math.min(player.maxHealth, player.health);
                        this.showMessage('스치기만 해도 치명타!', '치명타 +20%, 체력 -10%', 2000);
                        break;
                    case 'armor':
                        player.armor += 5;
                        this.showMessage('방어력!', '피해량 5 감소', 2000);
                        break;
                    case 'ammo_overflow':
                        player.ammoRegenEndTime = Date.now() + 10000;
                        player.ammoRegenAmount = 10;
                        player.maxAmmo += 20;
                        this.showMessage('탄약이 넘쳐!', '탄약 자동 회복, 탄약통 +20', 2000);
                        break;
                    // 기존 단순 보상도 지원
                    case 'maxHealth':
                        player.maxHealth += value;
                        player.health = Math.min(player.maxHealth, player.health + value);
                        this.showMessage(`최대 체력 +${value}!`, '', 1500);
                        break;
                    case 'currentHealth':
                        player.health = Math.min(player.maxHealth, player.health + value);
                        this.createFloatingText(player.x + player.width / 2, player.y, `+${value}`, 'green');
                        this.showMessage(`체력 +${value}!`, '', 1500);
                        break;
                    case 'damage':
                        player.baseDamage += value;
                        this.showMessage(`공격력 +${value}!`, '', 1500);
                        break;
                    case 'speed':
                        player.speed += value;
                        this.showMessage(`이동 속도 +${value}!`, '', 1500);
                        break;
                    case 'multishot':
                        player.multishot = Math.min(99, (player.multishot || 1) + 1);
                        this.showMessage(`다중 발사!`, `${player.multishot}발 동시 발사`, 2000);
                        break;
                    case 'orbiting_knife':
                        player.orbitingKnives.push({
                            angle: Math.random() * Math.PI * 2,
                            radius: 60,
                            speed: 0.05,
                            damage: 15,
                            lastHit: 0,
                            cooldown: 200,
                            color: this.ITEM_TYPES.find(i => i.type === 'orbiting_knife').color,
                            emoji: this.ITEM_TYPES.find(i => i.type === 'orbiting_knife').emoji
                        });
                        this.showMessage(`회전 칼날 획득!`, `플레이어 주위를 돕니다!`, 2000);
                        break;
                    case 'piercing_shot':
                        player.piercingShot = Math.min(99, player.piercingShot + value);
                        this.showMessage(`관통 사격!`, `탄환이 적을 관통합니다! (Lv.${player.piercingShot})`, 2000);
                        break;
                    case 'explosive_shot':
                        player.explosiveShot = Math.min(99, player.explosiveShot + value);
                        this.showMessage(`폭발 사격!`, `탄환이 폭발합니다! (Lv.${player.explosiveShot})`, 2000);
                        break;
                    case 'ricochet_shot':
                        player.ricochetLevel = Math.min(99, player.ricochetLevel + value);
                        this.showMessage(`도탄 사격!`, `탄환이 벽에서 튕겨 나갑니다! (Lv.${player.ricochetLevel})`, 2000);
                        break;
                    case 'homing_shot':
                        player.homingLevel = Math.min(99, player.homingLevel + value);
                        this.showMessage(`유도 사격!`, `탄환이 적을 추적합니다! (Lv.${player.homingLevel})`, 2000);
                        break;
                    case 'split_shot':
                        player.splitLevel = Math.min(99, player.splitLevel + value);
                        this.showMessage(`분열 사격!`, `탄환이 분열하여 추가 피해를 줍니다! (Lv.${player.splitLevel})`, 2000);
                        break;
                    case 'life_steal':
                        player.lifeStealPercent = Math.min(0.2, player.lifeStealPercent + value);
                        this.showMessage(`생명력 흡수!`, `피해량의 ${(player.lifeStealPercent * 100).toFixed(0)}% 체력 회복!`, 2000);
                        break;
                    case 'crit_chance':
                        player.critChance = Math.min(0.5, player.critChance + value);
                        this.showMessage(`치명타 확률!`, `치명타 확률 ${(player.critChance * 100).toFixed(0)}%`, 2000);
                        break;
                    case 'cooldown_reduction':
                        player.cooldownReduction = Math.min(0.5, player.cooldownReduction + value);
                        this.showMessage(`재사용 대기시간 감소!`, `발사 속도 ${(player.cooldownReduction * 100).toFixed(0)}% 증가!`, 2000);
                        break;
                    case 'armor':
                        player.armor += value;
                        this.showMessage(`방어력!`, `피해량 ${value} 감소!`, 2000);
                        break;
                    case 'time_stop':
                        this.gameState.timeStopEndTime = Date.now() + value;
                        this.gameState.timeSlowEffect = 0;
                        this.showMessage(`시간 정지!`, `${value / 1000}초간 모든 적 정지!`, 2000);
                        break;
                    case 'ammo_regen':
                        player.ammoRegenEndTime = Date.now() + 5000;
                        player.lastAmmoRegenTick = Date.now();
                        player.ammoRegenAmount = value;
                        this.showMessage(`탄약 재생!`, `5초간 탄약 자동 회복!`, 2000);
                        break;
                }
                this.updateHUD();
            }
            
            // HUD 업데이트 (체력, 탄약, 점수, 웨이브, 미니맵)
            updateHUD = () => {
                const player = this.gameState.player;
                const now = Date.now();
                
                // 체력 바 업데이트
                const healthPercent = (Math.max(0, player.health) / player.maxHealth) * 100;
                document.getElementById('healthFill').style.width = healthPercent + '%';
                document.getElementById('healthText').textContent = `${Math.max(0, player.health.toFixed(0))}/${player.maxHealth.toFixed(0)}`;
                
                // 탄약 바 업데이트
                const ammoPercent = (player.ammo / player.maxAmmo) * 100;
                document.getElementById('ammoFill').style.width = ammoPercent + '%';
                document.getElementById('ammoText').textContent = `${player.ammo.toFixed(0)}/${player.maxAmmo.toFixed(0)}`;
                
                // 점수 및 웨이브 업데이트
                document.getElementById('scoreText').textContent = this.gameState.score.toLocaleString();
                document.getElementById('waveText').textContent = `웨이브 ${this.gameState.wave}`;
                document.getElementById('enemyCount').textContent = `적: ${this.gameState.enemies.length}마리`;

                // 새로운 스탯 업데이트
                document.getElementById('speedText').textContent = player.speed;
                document.getElementById('damageText').textContent = player.baseDamage;
                document.getElementById('multishotText').textContent = player.multishot;

                // 활성 효과 업데이트
                const invincibilityEl = document.getElementById('invincibilityEffect');
                const shieldBoostEl = document.getElementById('shieldBoostEffect');
                const timeSlowEl = document.getElementById('timeSlowEffect');
                const magnetEl = document.getElementById('magnetEffect');
                const healthRegenEl = document.getElementById('healthRegenEffect');
                const rapidFireEl = document.getElementById('rapidFireEffect');
                const piercingShotEl = document.getElementById('piercingShotEffect'); 
                const explosiveShotEl = document.getElementById('explosiveShotEffect'); 
                const orbitingKnivesEl = document.getElementById('orbitingKnivesEffect'); 
                const ricochetShotEl = document.getElementById('ricochetShotEffect'); 
                const homingShotEl = document.getElementById('homingShotEffect'); 
                const splitShotEl = document.getElementById('splitShotEffect'); 
                const ammoRegenEl = document.getElementById('ammoRegenEffect');
                const timeStopEl = document.getElementById('timeStopEffect');
                const dashEl = document.getElementById('dashEffect');

                invincibilityEl.textContent = now < player.invincibleEndTime ? `무적: ${( (player.invincibleEndTime - now) / 1000).toFixed(1)}초` : '';
                shieldBoostEl.textContent = now < player.shieldBoostEndTime ? `쉴드 강화: ${( (player.shieldBoostEndTime - now) / 1000).toFixed(1)}초 (${(1 - player.damageReductionFactor) * 100}% 감소)` : '';
                timeSlowEl.textContent = now < this.gameState.timeSlowEndTime && this.gameState.timeSlowEffect > 0 ? `시간 둔화: ${( (this.gameState.timeSlowEndTime - now) / 1000).toFixed(1)}초` : '';
                magnetEl.textContent = now < player.magnetEndTime ? `자석: ${( (player.magnetEndTime - now) / 1000).toFixed(1)}초` : '';
                healthRegenEl.textContent = now < player.healthRegenEndTime ? `체력 재생: ${( (player.healthRegenEndTime - now) / 1000).toFixed(1)}초` : '';
                rapidFireEl.textContent = now < player.rapidFireTime ? `연발: ${( (player.rapidFireTime - now) / 1000).toFixed(1)}초` : '';
                piercingShotEl.textContent = player.piercingShot > 0 ? `관통 사격: ${player.piercingShot}회` : '';
                explosiveShotEl.textContent = player.explosiveShot > 0 ? `폭발 사격: Lv.${player.explosiveShot}` : '';
                orbitingKnivesEl.textContent = player.orbitingKnives.length > 0 ? `회전 칼날: ${player.orbitingKnives.length}개` : '';
                ricochetShotEl.textContent = player.ricochetLevel > 0 ? `도탄 사격: Lv.${player.ricochetLevel}` : '';
                homingShotEl.textContent = player.homingLevel > 0 ? `유도 사격: Lv.${player.homingLevel}` : '';
                splitShotEl.textContent = player.splitLevel > 0 ? `분열 사격: Lv.${player.splitLevel}` : '';
                ammoRegenEl.textContent = now < player.ammoRegenEndTime ? `탄약 재생: ${( (player.ammoRegenEndTime - now) / 1000).toFixed(1)}초` : '';
                timeStopEl.textContent = now < this.gameState.timeStopEndTime ? `시간 정지: ${( (this.gameState.timeStopEndTime - now) / 1000).toFixed(1)}초` : '';
                if (dashEl) {
                    if (player.isDashing) dashEl.textContent = `대시: 무적!`;
                    else if (now - player.dashCooldown < 1000) dashEl.textContent = `대시 쿨타임: ${((1000 - (now - player.dashCooldown))/1000).toFixed(1)}초`;
                    else dashEl.textContent = '';
                }


                // 패시브 스킬 업데이트
                const lifeStealEl = document.getElementById('lifeStealEffect');
                const critChanceEl = document.getElementById('critChanceEffect');
                const cooldownReductionEl = document.getElementById('cooldownReductionEffect');
                const armorEl = document.getElementById('armorEffect');

                lifeStealEl.textContent = player.lifeStealPercent > 0 ? `생명력 흡수: ${(player.lifeStealPercent * 100).toFixed(0)}%` : '';
                critChanceEl.textContent = player.critChance > 0 ? `치명타 확률: ${(player.critChance * 100).toFixed(0)}%` : '';
                cooldownReductionEl.textContent = player.cooldownReduction > 0 ? `재사용 대기시간 감소: ${(player.cooldownReduction * 100).toFixed(0)}%` : '';
                armorEl.textContent = player.armor > 0 ? `방어력: ${player.armor}` : '';

                // 미니맵 업데이트
                this.updateMinimap();

                // 보스 체력바 표시
                const bossBarContainer = document.getElementById('bossBarContainer');
                const bossBar = document.getElementById('bossBar');
                const bossName = document.getElementById('bossName');
                const boss = this.gameState.enemies.find(e => e.type && e.type.startsWith('boss'));
                if (boss) {
                    bossBarContainer.style.display = 'block';
                    bossName.textContent = this.ENEMY_TYPES[boss.type].name;
                    bossBar.style.width = Math.max(0, (boss.health / boss.maxHealth) * 100) + '%';
                } else {
                    bossBarContainer.style.display = 'none';
                }
                // 5. updateHUD에 XP 표시 추가
                document.getElementById('xpText').textContent = `XP: ${this.xp}`;
            }
            
            // 미니맵 업데이트 (플레이어, 적, 아이템 위치 표시)
            updateMinimap = () => {
                const minimapPlayer = document.getElementById('minimapPlayer');
                const minimap = document.getElementById('minimap');
                
                // 플레이어 위치 계산 및 업데이트
                const playerX = (this.gameState.player.x / this.canvas.width) * 120;
                const playerY = (this.gameState.player.y / this.canvas.height) * 120;
                
                minimapPlayer.style.left = playerX + 'px';
                minimapPlayer.style.top = playerY + 'px';
                
                // 기존 적/아이템 도트 제거
                const existingDots = minimap.querySelectorAll('.minimap-enemy, .minimap-item, .minimap-ally');
                existingDots.forEach(dot => dot.remove());
                
                // 적 도트 추가
                this.gameState.enemies.forEach(enemy => {
                    const enemyX = (enemy.x / this.canvas.width) * 120;
                    const enemyY = (enemy.y / this.canvas.height) * 120;
                    
                    const dot = document.createElement('div');
                    dot.className = 'minimap-enemy';
                    dot.style.left = enemyX + 'px';
                    dot.style.top = enemyY + 'px';
                    minimap.appendChild(dot);
                });
                
                // 아이템 도트 추가
                this.gameState.items.forEach(item => {
                    const itemX = (item.x / this.canvas.width) * 120;
                    const itemY = (item.y / this.canvas.height) * 120;
                    
                    const dot = document.createElement('div');
                    dot.className = 'minimap-item';
                    dot.style.left = itemX + 'px';
                    dot.style.top = itemY + 'px';
                    minimap.appendChild(dot);
                });

                // 아군 도트 추가
                this.gameState.allies.forEach(ally => {
                    const allyX = (ally.x / this.canvas.width) * 120;
                    const allyY = (ally.y / this.canvas.height) * 120;
                    
                    const dot = document.createElement('div');
                    dot.className = 'minimap-ally'; // 새로운 클래스
                    dot.style.left = allyX + 'px';
                    dot.style.top = allyY + 'px';
                    dot.style.backgroundColor = ally.color; // 아군 색상
                    dot.style.width = '3px';
                    dot.style.height = '3px';
                    dot.style.borderRadius = '50%';
                    minimap.appendChild(dot);
                });
            }
            
            // 캐릭터 (플레이어 및 적) 그리기 (유령 무적 상태 시 시각적 효과 추가)
            drawCharacter = (character) => {
                this.ctx.save(); // 현재 캔버스 상태 저장
                
                // 그림자 그리기 (변환 전)
                this.ctx.globalAlpha = 0.2;
                this.ctx.fillStyle = 'black';
                this.ctx.fillRect(character.x + 3, character.y + character.height + 3, character.width, 5);
                
                // 플레이어 캐릭터 그리기 (변환 적용)
                if (character.type === 'player') {
                    // 캐릭터의 중심으로 캔버스 원점 이동
                    this.ctx.translate(character.x + character.width / 2, character.y + character.height / 2);
                    // 마우스 방향으로 플레이어 회전 (캐릭터의 기본 방향이 오른쪽이라고 가정하고 180도 회전 보정)
                    this.ctx.rotate(character.facing + Math.PI); 

                    // 캐릭터 몸체 (글래스 효과)
                    this.ctx.globalAlpha = 0.8;
                    this.ctx.fillStyle = character.color;
                    this.ctx.shadowBlur = 15;
                    this.ctx.shadowColor = character.color;
                    this.ctx.beginPath();
                    this.ctx.roundRect(-character.width / 2, -character.height / 2, character.width, character.height, 8);
                    this.ctx.fill();

                    // 글래스 효과
                    this.ctx.globalAlpha = 0.3;
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    this.ctx.beginPath();
                    this.ctx.roundRect(-character.width / 2, -character.height / 2, character.width, character.height / 2, 8);
                    this.ctx.fill();

                    // 표정 그리기
                    this.ctx.globalAlpha = 1;
                    this.ctx.fillStyle = 'white';
                    const fontSize = '16px';
                    this.ctx.font = `${fontSize} Poppins`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(character.expression, 0, 0); // 새로운 원점(0,0)에 그리기

                    // 플레이어 총 이모지 그리기 (항상 왼손에 고정)
                    this.ctx.font = '20px Poppins'; // 총 이모지 크기
                    this.ctx.fillStyle = 'black'; // 총 색상 검정색으로 변경
                    
                    // 총 이모지를 플레이어의 왼쪽 (캐릭터 중심 기준 왼쪽)에 고정
                    const gunOffsetX = -character.width / 2 - 10; // 캐릭터 왼쪽 끝에서 10px 더 왼쪽
                    const weaponEmoji = (this.currentWeapon === 'melee') ? '🔪' : '🔫';
                    this.ctx.fillText(weaponEmoji, gunOffsetX, 0); // 계산된 오프셋에 총 그리기

                } else {
                    // 비-플레이어 캐릭터 (적, 아군) 그리기 (변환 없음)
                    // 캐릭터 몸체 (글래스 효과)
                    this.ctx.globalAlpha = 0.8;
                    this.ctx.fillStyle = character.color;
                    
                    // 보스는 더 강한 글로우 효과, 유령은 무적 상태 시 다른 효과
                    if (character.type && character.type.startsWith('boss')) { // 모든 보스 타입에 적용
                        this.ctx.shadowBlur = 25;
                        this.ctx.shadowColor = character.color;
                        if (character.type === 'boss_beta' && character.isInvincible) { // 베타 보스 쉴드 시
                            this.ctx.globalAlpha = 0.4;
                            this.ctx.shadowBlur = 15;
                            this.ctx.shadowColor = 'rgba(135, 206, 235, 0.8)'; // 스카이블루 글로우
                        }
                    } else if (character.type === 'ghost' && character.isInvincible) {
                        this.ctx.globalAlpha = 0.4; // 무적 상태 시 반투명
                        this.ctx.shadowBlur = 10;
                        this.ctx.shadowColor = 'rgba(255, 255, 255, 0.7)'; // 흰색 글로우
                    } else if (character.type === 'berserker' && character.isRaging) {
                        this.ctx.shadowBlur = 20;
                        this.ctx.shadowColor = 'red'; // 광전사 광폭화 시 붉은 글로우
                    }
                    else {
                        this.ctx.shadowBlur = 15;
                        this.ctx.shadowColor = character.color;
                    }
                    
                    this.ctx.beginPath();
                    this.ctx.roundRect(character.x, character.y, character.width, character.height, 8);
                    this.ctx.fill();
                    
                    // 글래스 효과
                    this.ctx.globalAlpha = 0.3;
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    this.ctx.beginPath();
                    this.ctx.roundRect(character.x, character.y, character.width, character.height / 2, 8);
                    this.ctx.fill();
                    
                    // 표정 그리기
                    this.ctx.globalAlpha = 1;
                    this.ctx.fillStyle = 'white';
                    
                    // 보스는 더 큰 폰트
                    const fontSize = character.type && character.type.startsWith('boss') ? '20px' : '16px'; // character.type 체크 추가
                    this.ctx.font = `${fontSize} Poppins`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(character.expression, character.x + character.width / 2, character.y + character.height / 2);
                    
                    // 적 타입 표시 (작은 아이콘)
                    if (character.type && character !== this.gameState.player) { // character.type 체크 추가
                        this.ctx.font = '10px Poppins';
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        let typeIcon = '';
                        switch (character.type) {
                            case 'fast': typeIcon = '⚡'; break;
                            case 'tank': typeIcon = '🛡'; break;
                            case 'sniper': typeIcon = '🎯'; break;
                            case 'bomber': typeIcon = '💣'; break;
                            case 'guardian': typeIcon = '🛡️'; break;
                            case 'assassin': typeIcon = '🗡'; break;
                            case 'heavy': typeIcon = '💪'; break;
                            case 'ghost': typeIcon = '👻'; break; 
                            case 'medic': typeIcon = '➕'; break; 
                            case 'summoner': typeIcon = '🌀'; break; 
                            case 'jumper': typeIcon = '⬆️'; break; 
                            case 'shielded': typeIcon = '🛡️'; break; 
                            case 'teleporter': typeIcon = '💫'; break; 
                            case 'drone': typeIcon = '📡'; break; 
                            case 'spitter': typeIcon = '🦠'; break; 
                            case 'berserker': typeIcon = '💢'; break; 
                            case 'boss_alpha': typeIcon = 'α'; break; // 알파 보스 아이콘
                            case 'boss_beta': typeIcon = 'β'; break; // 베타 보스 아이콘
                            case 'boss_gamma': typeIcon = 'γ'; break; // 감마 보스 아이콘
                            case 'ally': typeIcon = '🤖'; break; // 아군 아이콘
                            default: typeIcon = ''; break;
                        }
                        if (typeIcon) {
                            this.ctx.fillText(typeIcon, character.x + character.width - 8, character.y + 8);
                        }
                    }
                    
                    // 체력 바 그리기
                    if (character.health < character.maxHealth || (character.type && character.type.startsWith('boss')) || character.type === 'ally') { // 보스, 아군도 항상 체력바 표시
                        const barWidth = character.width;
                        const barHeight = (character.type && character.type.startsWith('boss')) ? 6 : 4; // character.type 체크 추가
                        const barX = character.x;
                        const barY = character.y - 12;
                        
                        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                        this.ctx.fillRect(barX, barY, barWidth, barHeight);
                        
                        let healthColor;
                        if (character === this.gameState.player) {
                            healthColor = '#22c55e';
                        } else if (character.type && character.type.startsWith('boss')) { // character.type 체크 추가
                            healthColor = '#dc2626';
                        } else if (character.type === 'ally') { // 아군 체력바 색상
                            healthColor = '#90ee90';
                        } else {
                            healthColor = character.color;
                        }
                        
                        this.ctx.fillStyle = healthColor;
                        this.ctx.fillRect(barX, barY, (character.health / character.maxHealth) * barWidth, barHeight);
                    }
                }
                
                this.ctx.restore(); // 저장된 캔버스 상태 복원
            }

            // 회전 칼날 그리기 및 충돌 감지
            drawOrbitingKnives = () => {
                const player = this.gameState.player;
                const now = Date.now();

                player.orbitingKnives.forEach(knife => {
                    // 각도 업데이트 (시간 둔화 효과 적용)
                    knife.angle += knife.speed * (this.gameState.timeSlowEffect < 1 ? this.gameState.timeSlowEffect : 1);

                    // 칼날 위치 계산
                    const knifeX = player.x + player.width / 2 + Math.cos(knife.angle) * knife.radius;
                    const knifeY = player.y + player.height / 2 + Math.sin(knife.angle) * knife.radius;

                    // 칼날 그리기
                    this.ctx.save();
                    this.ctx.globalAlpha = 0.9;
                    this.ctx.fillStyle = knife.color;
                    this.ctx.shadowBlur = 10;
                    this.ctx.shadowColor = knife.color;
                    this.ctx.beginPath();
                    this.ctx.roundRect(knifeX - 5, knifeY - 5, 10, 10, 2); // 작은 사각형으로 칼날 표현
                    this.ctx.fill();
                    this.ctx.globalAlpha = 1;
                    this.ctx.font = '12px Poppins';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(knife.emoji, knifeX, knifeY);
                    this.ctx.restore();

                    // 적과의 충돌 감지
                    this.gameState.enemies = this.gameState.enemies.filter(enemy => {
                        const dx = knifeX - (enemy.x + enemy.width / 2);
                        const dy = knifeY - (enemy.y + enemy.height / 2);
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        // 쿨다운 체크 및 충돌 범위 내에 있는지 확인
                        if (distance < 15 + enemy.width / 2 && now - knife.lastHit > knife.cooldown) { // 15는 칼날의 대략적인 반지름
                            // 유령, 방패병, 베타 보스 쉴드 무적 상태 체크
                            if (enemy.type === 'ghost' && enemy.isInvincible) return true;
                            if (enemy.type === 'boss_beta' && enemy.isInvincible) return true;

                            let actualDamage = knife.damage;
                            if (enemy.type === 'shielded') {
                                const angleToKnife = Math.atan2(dy, dx);
                                const angleDiff = Math.abs(angleToKnife - enemy.facing);
                                if (angleDiff < enemy.shieldAngle || angleDiff > (2 * Math.PI - enemy.shieldAngle)) {
                                    // 방패병이 칼날을 방어하는 방향에 있으면 피해 감소
                                    actualDamage *= 0.1;
                                    this.createFloatingText(enemy.x + enemy.width / 2, enemy.y, `-${actualDamage.toFixed(0)} (방어)`, 'orange');
                                } else {
                                    this.createFloatingText(enemy.x + enemy.width / 2, enemy.y, `-${actualDamage.toFixed(0)}`, 'white');
                                }
                            } else {
                                this.createFloatingText(enemy.x + enemy.width / 2, enemy.y, `-${actualDamage.toFixed(0)}`, 'white');
                            }
                            enemy.health -= actualDamage;

                            this.createHitParticles(knifeX, knifeY);
                            knife.lastHit = now; // 이 칼날의 마지막 공격 시간 업데이트

                            // 생명력 흡수 (Life Steal) 적용
                            if (player.lifeStealPercent > 0) {
                                const healedAmount = actualDamage * player.lifeStealPercent;
                                player.health = Math.min(player.maxHealth, player.health + healedAmount);
                                this.createFloatingText(player.x + player.width / 2, player.y - 20, `+${healedAmount.toFixed(0)} 흡수`, 'lightgreen');
                            }

                            if (enemy.health <= 0) {
                                this.addScore(enemy.points);
                                if (Math.random() < 0.4) this.gameState.items.push(this.createItem(enemy.x, enemy.y));
                                this.gameState.enemies = this.gameState.enemies.filter(e => e !== enemy);
                                return false; // 적 제거
                            }
                        }
                        return true; // 적 유지
                    });
                });
            }
            
            // 발사체 그리기
            drawProjectile = (projectile) => {
                this.ctx.save();
                this.ctx.globalAlpha = 0.8;
                this.ctx.fillStyle = projectile.color;
                this.ctx.shadowBlur = 8;
                this.ctx.shadowColor = projectile.color;
                this.ctx.beginPath();
                this.ctx.arc(projectile.x, projectile.y, projectile.radius, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.restore();
            }
            
            // 아이템 그리기
            drawItem = (item) => {
                this.ctx.save();
                this.ctx.globalAlpha = 0.9;
                this.ctx.fillStyle = item.color;
                this.ctx.shadowBlur = 10;
                this.ctx.shadowColor = item.color;
                this.ctx.beginPath();
                this.ctx.roundRect(item.x, item.y, item.width, item.height, 4);
                this.ctx.fill();
                
                // 아이템 아이콘 그리기
                this.ctx.globalAlpha = 1;
                this.ctx.font = '12px Poppins';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(item.emoji, item.x + item.width / 2, item.y + item.height / 2);
                
                this.ctx.restore();
            }
            
            // 파티클 그리기
            drawParticle = (particle) => {
                this.ctx.save();
                this.ctx.globalAlpha = particle.life / particle.maxLife; // 수명에 따라 투명도 조절
                this.ctx.fillStyle = particle.color;
                this.ctx.beginPath();
                this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.restore();
            }

            // 떠다니는 텍스트 그리기
            drawFloatingText = (text) => {
                this.ctx.save();
                this.ctx.globalAlpha = text.life / text.maxLife; // 수명에 따라 투명도 조절
                this.ctx.fillStyle = text.color;
                this.ctx.font = 'bold 16px Poppins';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(text.text, text.x, text.y);
                this.ctx.restore();
            }
            
            // 배경 그리기
            drawBackground = () => {
                // 배경 그라데이션
                const gradient = this.ctx.createLinearGradient(0, 0, this.canvas.width, this.canvas.height);
                gradient.addColorStop(0, '#667eea');
                gradient.addColorStop(1, '#764ba2');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // 지면 그리기
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                this.ctx.fillRect(0, this.canvas.height - this.GROUND_Y, this.canvas.width, this.GROUND_Y);
            }
            
            // 모든 게임 요소 렌더링
            render = () => {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); // 캔버스 초기화
                
                this.drawBackground(); // 배경 그리기
                
                // 캐릭터 그리기
                this.drawCharacter(this.gameState.player);
                this.gameState.enemies.forEach(enemy => this.drawCharacter(enemy));
                this.gameState.allies.forEach(ally => this.drawCharacter(ally));
                
                // 회전 칼날 그리기 및 충돌
                this.drawOrbitingKnives();
                
                // 파티클 그리기
                this.gameState.particles.forEach(particle => this.drawParticle(particle));
                
                // 발사체 그리기
                this.gameState.projectiles.forEach(projectile => this.drawProjectile(projectile));
                
                // 아이템 그리기
                this.gameState.items.forEach(item => this.drawItem(item));
                
                // 떠다니는 텍스트 그리기
                this.gameState.floatingTexts.forEach(text => this.drawFloatingText(text));
                
                // 파티클 상태 업데이트
                this.updateParticles();
                
                // 발사체 상태 업데이트 및 충돌 감지
                this.updateProjectiles();
                
                // 아이템 상태 업데이트 및 플레이어 충돌 감지
                this.updateItems();
                
                // HUD 업데이트
                this.updateHUD();
                this.updateFloatingTexts();
            }
            // 게임 루프
            gameLoop = () => {
                // 시간 정지/둔화 해제 체크
                const now = Date.now();
                if (now > this.gameState.timeStopEndTime && now > this.gameState.timeSlowEndTime) {
                    this.gameState.timeSlowEffect = 1;
                } else if (now > this.gameState.timeStopEndTime && now < this.gameState.timeSlowEndTime) {
                    this.gameState.timeSlowEffect = 0.5;
                } else if (now < this.gameState.timeStopEndTime) {
                    this.gameState.timeSlowEffect = 0;
                } else if (now < this.gameState.timeSlowEndTime) {
                    this.gameState.timeSlowEffect = 0.5;
                }
                // 1. 상태 업데이트
                this.updateCharacter(this.gameState.player);
                this.gameState.enemies.forEach(e => this.updateCharacter(e));
                this.gameState.allies.forEach(a => this.updateCharacter(a));
                // 2. 웨이브 완료 체크
                this.checkWaveComplete();
                // 3. 렌더링
                this.render();
                // 4. 다음 프레임 예약
                if (this.gameState.gameStatus === 'playing' || this.gameState.gameStatus === 'wave-complete') {
                    requestAnimationFrame(this.gameLoop);
                }
            }

            // 1. Add addScore method to GlassCombatArena
            addScore = (amount) => {
                this.gameState.score += amount;
                this.updateHUD();
                while (this.nextMilestoneIndex < this.scoreMilestones.length && this.gameState.score >= this.scoreMilestones[this.nextMilestoneIndex]) {
                    this.pauseGameForReward();
                    this.nextMilestoneIndex++;
                }
            };

            pauseGameForReward = () => {
                this.gameState.gameStatus = 'reward-selection';
                this.showRewardSelection('score');
            };

            updateShopList = () => {
                const shopList = document.getElementById('shopList');
                shopList.innerHTML = '';
                this.SHOP_ITEMS.forEach(item => {
                    const affordable = this.gameState.score >= item.price;
                    const itemDiv = document.createElement('div');
                    itemDiv.style.display = 'flex';
                    itemDiv.style.justifyContent = 'space-between';
                    itemDiv.style.alignItems = 'center';
                    itemDiv.style.margin = '10px 0';
                    itemDiv.style.padding = '10px 0';
                    itemDiv.style.borderBottom = '1px solid rgba(255,255,255,0.15)';
                    itemDiv.style.color = '#fff';
                    const label = document.createElement('span');
                    label.textContent = `${item.text}`;
                    const price = document.createElement('span');
                    price.textContent = `${item.price}점`;
                    price.style.marginLeft = '16px';
                    price.style.color = affordable ? '#ffe066' : '#aaa';
                    price.style.fontWeight = 'normal';
                    const buyBtn = document.createElement('button');
                    buyBtn.textContent = affordable ? '구매' : '구매불가';
                    buyBtn.disabled = !affordable;
                    buyBtn.style.marginLeft = '18px';
                    buyBtn.style.background = affordable ? '#ffe066' : '#888';
                    buyBtn.style.color = '#222';
                    buyBtn.style.fontWeight = 'bold';
                    buyBtn.style.border = 'none';
                    buyBtn.style.borderRadius = '8px';
                    buyBtn.style.padding = '6px 18px';
                    buyBtn.style.cursor = affordable ? 'pointer' : 'not-allowed';
                    buyBtn.onclick = () => {
                        if (this.gameState.score >= item.price) {
                            this.gameState.score -= item.price;
                            this.applyReward(item.type, item.value);
                            this.updateHUD();
                            this.updateShopList();
                        }
                    };
                    itemDiv.appendChild(label);
                    itemDiv.appendChild(price);
                    itemDiv.appendChild(buyBtn);
                    shopList.appendChild(itemDiv);
                });
            };
        }

        // === Add after GlassCombatArena class definition or at the end of the script ===
        window.onload = function() {
          // Hide startScreen, show introScreen
          document.getElementById('startScreen').style.display = 'none';
          document.getElementById('introScreen').style.display = 'flex';

          // Attach event listener to Solo Play button
          document.getElementById('soloButton').onclick = function() {
            document.getElementById('introScreen').style.display = 'none';
            if (window.game && typeof window.game.startGame === 'function') {
              window.game.startGame();
            }
          };
          // (Optional) Disable multiButton for now
          document.getElementById('multiButton').onclick = function() {
            document.getElementById('multiInfo').style.display = 'block';
          };
          // 상점 열기/닫기 이벤트 리스너
          document.getElementById('shopButton').onclick = function() {
            document.getElementById('shopPopup').style.display = 'block';
            window.game.updateShopList();
          };
          document.getElementById('closeShopButton').onclick = function() {
            document.getElementById('shopPopup').style.display = 'none';
          };
        };

        // === GlassCombatArena 클래스 정의 끝난 후 ===
        window.game = new GlassCombatArena();
    </script>
</body>
</html>
