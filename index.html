<!DOCTYPE html>
<html lang="ko">
<head>
    <!-- Firebase SDK ë° ì„¤ì • -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
    <script>
    const firebaseConfig = {
        apiKey: "AIzaSyBGKn7TDPIQL9E0_IQhWs2NYuqe1jy27P0",
        authDomain: "glasscombatarena.firebaseapp.com",
        databaseURL: "https://glasscombatarena-default-rtdb.asia-southeast1.firebasedatabase.app/",
        projectId: "glasscombatarena",
        storageBucket: "glasscombatarena.firebasestorage.app",
        messagingSenderId: "678597065462",
        appId: "1:678597065462:web:36b0420611e79bf041cad7",
        measurementId: "G-F2PQDZPDBL"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ê¸€ë˜ìŠ¤ ì»´ë±ƒ ì•„ë ˆë‚˜</title>
    <meta name="description" content="2D ë¸Œë¼ìš°ì € ê¸°ë°˜ ì „íˆ¬ ê²Œì„ - ì¤‘ë ¥ ë¬¼ë¦¬í•™, ê¸€ë˜ìŠ¤ëª¨í”¼ì¦˜ UI, ë´‡ ì „íˆ¬ ì‹œìŠ¤í…œ">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="icon" type="image/png" href="icon.png">
    <style>
        /* ì „ì—­ CSS ì¬ì„¤ì • */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* body ìŠ¤íƒ€ì¼: í°íŠ¸, ë°°ê²½, ì˜¤ë²„í”Œë¡œìš° ìˆ¨ê¹€, ì „ì²´ í™”ë©´ */
        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* ê²Œì„ ìº”ë²„ìŠ¤ ìŠ¤íƒ€ì¼: ì ˆëŒ€ ìœ„ì¹˜, ì»¤ì„œ, ë°°ê²½, ë¸”ëŸ¬ ì „í™˜ íš¨ê³¼ */
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); /* ìº”ë²„ìŠ¤ ë°°ê²½ë„ ë™ì¼í•˜ê²Œ ì„¤ì • */
            filter: blur(10px); /* ì´ˆê¸° ë¸”ëŸ¬ íš¨ê³¼ */
            transition: filter 0.5s ease; /* ë¸”ëŸ¬ ì „í™˜ ì• ë‹ˆë©”ì´ì…˜ */
            display: block; /* í•­ìƒ ë³´ì´ë„ë¡ ì„¤ì • */
        }
        
        /* ê¸€ë˜ìŠ¤ ì¹´ë“œ ìŠ¤íƒ€ì¼: ë°°ê²½ íë¦¼, í…Œë‘ë¦¬, ê·¸ë¦¼ì */
        .glass-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            color: #fff;
        }
        
        /* HUD (Head-Up Display) ìŠ¤íƒ€ì¼: ì™¼ìª½ ìƒë‹¨ ê³ ì •, flexboxë¡œ ë‚´ë¶€ ìš”ì†Œ ì •ë ¬ */
        .hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            pointer-events: none;
            z-index: 10;
            display: none;
            flex-direction: row;
            gap: 18px;
            justify-content: center;
            align-items: flex-start;
            padding: 12px 0 0 0;
        }
        
        /* HUD ë‚´ë¶€ ì•„ì´í…œ ìŠ¤íƒ€ì¼: ìƒí˜¸ì‘ìš© ê°€ëŠ¥ */
        .hud-item {
            pointer-events: auto;
            margin: 0 4px;
            min-width: 170px;
            max-width: 260px;
        }
        
        /* ì²´ë ¥/íƒ„ì•½ ë°” ìŠ¤íƒ€ì¼ */
        .health-bar, .ammo-bar {
            width: 150px;
            height: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            overflow: hidden;
            margin: 8px 0;
        }
        
        /* ì²´ë ¥ ë°” ì±„ìš°ê¸° ìŠ¤íƒ€ì¼: ê·¸ë¼ë°ì´ì…˜, ë„ˆë¹„ ì „í™˜ íš¨ê³¼ */
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ef4444, #f87171);
            transition: width 0.3s ease;
        }
        
        /* íƒ„ì•½ ë°” ì±„ìš°ê¸° ìŠ¤íƒ€ì¼: ê·¸ë¼ë°ì´ì…˜, ë„ˆë¹„ ì „í™˜ íš¨ê³¼ */
        .ammo-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #60a5fa);
            transition: width 0.3s ease;
        }
        
        /* ìŠ¤íƒ¯ í…ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ */
        .stats {
            color: white;
            font-size: 14px;
            font-weight: 500;
        }
        
        /* ì ìˆ˜ í…ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ */
        .score {
            color: white;
            font-size: 20px;
            font-weight: bold;
            text-align: center;
        }
        
        /* ì›¨ì´ë¸Œ í…ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ */
        .wave {
            color: white;
            font-size: 16px;
            font-weight: 600;
            text-align: center;
            margin-top: 8px;
        }
        
        /* ì¡°ì‘ë²• í…ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ */
        .controls {
            color: white;
            font-size: 12px;
        }
        
        /* ì¡°ì‘ í‚¤ í‘œì‹œ ìŠ¤íƒ€ì¼ */
        .control-key {
            background: rgba(255, 255, 255, 0.1);
            padding: 4px 8px;
            border-radius: 4px;
            margin: 2px;
            display: inline-block;
        }
        
        /* ê²Œì„ ë©”ì‹œì§€ ì»¨í…Œì´ë„ˆ ìŠ¤íƒ€ì¼ */
        .message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
        }
        
        /* ê²Œì„ ë©”ì‹œì§€ ì£¼ í…ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ */
        .message-text {
            color: white;
            font-size: 32px;
            font-weight: bold;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        /* ê²Œì„ ë©”ì‹œì§€ ë³´ì¡° í…ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ */
        .message-sub {
            color: rgba(255, 255, 255, 0.8);
            font-size: 18px;
            text-align: center;
            margin-top: 8px;
        }
        
        /* ê¹œë¹¡ì„ ì• ë‹ˆë©”ì´ì…˜ */
        .animate-pulse {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* ë¯¸ë‹ˆë§µ ìŠ¤íƒ€ì¼ */
        .minimap {
            width: 120px;
            height: 120px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            position: relative;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        /* ë¯¸ë‹ˆë§µ í”Œë ˆì´ì–´ ë„íŠ¸ ìŠ¤íƒ€ì¼ */
        .minimap-player {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #3b82f6;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        /* ë¯¸ë‹ˆë§µ ì  ë„íŠ¸ ìŠ¤íƒ€ì¼ */
        .minimap-enemy {
            position: absolute;
            width: 3px;
            height: 3px;
            background: #ef4444;
            border-radius: 50%;
        }
        
        /* ë¯¸ë‹ˆë§µ ì•„ì´í…œ ë„íŠ¸ ìŠ¤íƒ€ì¼ */
        .minimap-item {
            position: absolute;
            width: 2px;
            height: 2px;
            background: #fbbf24;
            border-radius: 50%;
        }

        /* ì‹œì‘ í™”ë©´ ìŠ¤íƒ€ì¼ */
        #startScreen {
            position: absolute; /* ìº”ë²„ìŠ¤ ìœ„ì— ì˜¤ë²„ë ˆì´ */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 101; /* HUDë³´ë‹¤ ë†’ê²Œ ì„¤ì • */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
            padding: 40px;
        }

        #startScreen h1 {
            font-size: 4em;
            margin-bottom: 20px;
            text-shadow: 0 0 15px rgba(255,255,255,0.5);
        }

        #startScreen p {
            font-size: 1.2em;
            margin-bottom: 30px;
            opacity: 0.8;
        }

        #startButton {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            padding: 15px 30px;
            font-size: 1.5em;
            font-weight: 600;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        #startButton:hover {
            background: rgba(255, 255, 255, 0.3);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
            transform: translateY(-2px);
        }

        #startButton:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        /* ë³´ìƒ ì„ íƒ í™”ë©´ ìŠ¤íƒ€ì¼ */
        #rewardSelectionScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200; /* ê°€ì¥ ìœ„ì— í‘œì‹œ */
            display: none; /* ì´ˆê¸°ì—ëŠ” ìˆ¨ê¹€ */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
            padding: 30px;
        }

        #rewardSelectionScreen h2 {
            font-size: 2.5em;
            margin-bottom: 25px;
            text-shadow: 0 0 10px rgba(255,255,255,0.4);
        }

        .reward-options {
            display: flex;
            gap: 20px;
            flex-wrap: wrap; /* ì‘ì€ í™”ë©´ì—ì„œ ì¤„ë°”ê¿ˆ */
            justify-content: center;
        }

        .reward-button {
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.25);
            border-radius: 12px;
            padding: 20px 25px;
            font-size: 1.2em;
            font-weight: bold;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(8px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
            min-width: 180px;
        }

        .reward-button:hover {
            background: rgba(255, 255, 255, 0.25);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.25);
            transform: translateY(-3px);
        }

        .reward-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        #shopPopup h2 {
            color: #fff;
            font-weight: bold;
        }

        #shopList {
            color: #fff;
            font-weight: normal;
        }

        /* --- 2. ìƒì  UI/ë¡œì§: ì ìˆ˜ë¡œ íŒ¨ì‹œë¸Œ ì—…ê·¸ë ˆì´ë“œ êµ¬ë§¤ --- */
        /* 1) ìƒì ì— í‘œì‹œí•  ì•„ì´í…œ ëª©ë¡ ë° ê°€ê²© ì„¤ì • (ë³´ìƒ ëª©ë¡ê³¼ ë™ì¼, ê°€ê²©ì€ ì˜ˆì‹œ) */

        /* 2) ìƒì  UIì— ì•„ì´í…œ í‘œì‹œ ë° êµ¬ë§¤ ë¡œì§ êµ¬í˜„ */

        /* 3) ìƒì  ë²„íŠ¼ í´ë¦­ ì‹œ updateShopList í˜¸ì¶œ */
        /* ì´ ë¶€ë¶„ì€ JavaScriptì—ì„œ ì²˜ë¦¬ë©ë‹ˆë‹¤ */
    </style>
</head>
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ê¸€ë˜ìŠ¤ ì»´ë±ƒ ì•„ë ˆë‚˜</title>
    <meta name="description" content="2D ë¸Œë¼ìš°ì € ê¸°ë°˜ ì „íˆ¬ ê²Œì„ - ì¤‘ë ¥ ë¬¼ë¦¬í•™, ê¸€ë˜ìŠ¤ëª¨í”¼ì¦˜ UI, ë´‡ ì „íˆ¬ ì‹œìŠ¤í…œ">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* ì „ì—­ CSS ì¬ì„¤ì • */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* body ìŠ¤íƒ€ì¼: í°íŠ¸, ë°°ê²½, ì˜¤ë²„í”Œë¡œìš° ìˆ¨ê¹€, ì „ì²´ í™”ë©´ */
        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* ê²Œì„ ìº”ë²„ìŠ¤ ìŠ¤íƒ€ì¼: ì ˆëŒ€ ìœ„ì¹˜, ì»¤ì„œ, ë°°ê²½, ë¸”ëŸ¬ ì „í™˜ íš¨ê³¼ */
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); /* ìº”ë²„ìŠ¤ ë°°ê²½ë„ ë™ì¼í•˜ê²Œ ì„¤ì • */
            filter: blur(10px); /* ì´ˆê¸° ë¸”ëŸ¬ íš¨ê³¼ */
            transition: filter 0.5s ease; /* ë¸”ëŸ¬ ì „í™˜ ì• ë‹ˆë©”ì´ì…˜ */
            display: block; /* í•­ìƒ ë³´ì´ë„ë¡ ì„¤ì • */
        }
        
        /* ê¸€ë˜ìŠ¤ ì¹´ë“œ ìŠ¤íƒ€ì¼: ë°°ê²½ íë¦¼, í…Œë‘ë¦¬, ê·¸ë¦¼ì */
        .glass-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            color: #fff;
        }
        
        /* HUD (Head-Up Display) ìŠ¤íƒ€ì¼: ì™¼ìª½ ìƒë‹¨ ê³ ì •, flexboxë¡œ ë‚´ë¶€ ìš”ì†Œ ì •ë ¬ */
        .hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            pointer-events: none;
            z-index: 10;
            display: none;
            flex-direction: row;
            gap: 18px;
            justify-content: center;
            align-items: flex-start;
            padding: 12px 0 0 0;
        }
        
        /* HUD ë‚´ë¶€ ì•„ì´í…œ ìŠ¤íƒ€ì¼: ìƒí˜¸ì‘ìš© ê°€ëŠ¥ */
        .hud-item {
            pointer-events: auto;
            margin: 0 4px;
            min-width: 170px;
            max-width: 260px;
        }
        
        /* ì²´ë ¥/íƒ„ì•½ ë°” ìŠ¤íƒ€ì¼ */
        .health-bar, .ammo-bar {
            width: 150px;
            height: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            overflow: hidden;
            margin: 8px 0;
        }
        
        /* ì²´ë ¥ ë°” ì±„ìš°ê¸° ìŠ¤íƒ€ì¼: ê·¸ë¼ë°ì´ì…˜, ë„ˆë¹„ ì „í™˜ íš¨ê³¼ */
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ef4444, #f87171);
            transition: width 0.3s ease;
        }
        
        /* íƒ„ì•½ ë°” ì±„ìš°ê¸° ìŠ¤íƒ€ì¼: ê·¸ë¼ë°ì´ì…˜, ë„ˆë¹„ ì „í™˜ íš¨ê³¼ */
        .ammo-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #60a5fa);
            transition: width 0.3s ease;
        }
        
        /* ìŠ¤íƒ¯ í…ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ */
        .stats {
            color: white;
            font-size: 14px;
            font-weight: 500;
        }
        
        /* ì ìˆ˜ í…ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ */
        .score {
            color: white;
            font-size: 20px;
            font-weight: bold;
            text-align: center;
        }
        
        /* ì›¨ì´ë¸Œ í…ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ */
        .wave {
            color: white;
            font-size: 16px;
            font-weight: 600;
            text-align: center;
            margin-top: 8px;
        }
        
        /* ì¡°ì‘ë²• í…ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ */
        .controls {
            color: white;
            font-size: 12px;
        }
        
        /* ì¡°ì‘ í‚¤ í‘œì‹œ ìŠ¤íƒ€ì¼ */
        .control-key {
            background: rgba(255, 255, 255, 0.1);
            padding: 4px 8px;
            border-radius: 4px;
            margin: 2px;
            display: inline-block;
        }
        
        /* ê²Œì„ ë©”ì‹œì§€ ì»¨í…Œì´ë„ˆ ìŠ¤íƒ€ì¼ */
        .message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
        }
        
        /* ê²Œì„ ë©”ì‹œì§€ ì£¼ í…ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ */
        .message-text {
            color: white;
            font-size: 32px;
            font-weight: bold;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        /* ê²Œì„ ë©”ì‹œì§€ ë³´ì¡° í…ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ */
        .message-sub {
            color: rgba(255, 255, 255, 0.8);
            font-size: 18px;
            text-align: center;
            margin-top: 8px;
        }
        
        /* ê¹œë¹¡ì„ ì• ë‹ˆë©”ì´ì…˜ */
        .animate-pulse {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* ë¯¸ë‹ˆë§µ ìŠ¤íƒ€ì¼ */
        .minimap {
            width: 120px;
            height: 120px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            position: relative;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        /* ë¯¸ë‹ˆë§µ í”Œë ˆì´ì–´ ë„íŠ¸ ìŠ¤íƒ€ì¼ */
        .minimap-player {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #3b82f6;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        /* ë¯¸ë‹ˆë§µ ì  ë„íŠ¸ ìŠ¤íƒ€ì¼ */
        .minimap-enemy {
            position: absolute;
            width: 3px;
            height: 3px;
            background: #ef4444;
            border-radius: 50%;
        }
        
        /* ë¯¸ë‹ˆë§µ ì•„ì´í…œ ë„íŠ¸ ìŠ¤íƒ€ì¼ */
        .minimap-item {
            position: absolute;
            width: 2px;
            height: 2px;
            background: #fbbf24;
            border-radius: 50%;
        }

        /* ì‹œì‘ í™”ë©´ ìŠ¤íƒ€ì¼ */
        #startScreen {
            position: absolute; /* ìº”ë²„ìŠ¤ ìœ„ì— ì˜¤ë²„ë ˆì´ */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 101; /* HUDë³´ë‹¤ ë†’ê²Œ ì„¤ì • */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
            padding: 40px;
        }

        #startScreen h1 {
            font-size: 4em;
            margin-bottom: 20px;
            text-shadow: 0 0 15px rgba(255,255,255,0.5);
        }

        #startScreen p {
            font-size: 1.2em;
            margin-bottom: 30px;
            opacity: 0.8;
        }

        #startButton {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            padding: 15px 30px;
            font-size: 1.5em;
            font-weight: 600;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        #startButton:hover {
            background: rgba(255, 255, 255, 0.3);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
            transform: translateY(-2px);
        }

        #startButton:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        /* ë³´ìƒ ì„ íƒ í™”ë©´ ìŠ¤íƒ€ì¼ */
        #rewardSelectionScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200; /* ê°€ì¥ ìœ„ì— í‘œì‹œ */
            display: none; /* ì´ˆê¸°ì—ëŠ” ìˆ¨ê¹€ */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
            padding: 30px;
        }

        #rewardSelectionScreen h2 {
            font-size: 2.5em;
            margin-bottom: 25px;
            text-shadow: 0 0 10px rgba(255,255,255,0.4);
        }

        .reward-options {
            display: flex;
            gap: 20px;
            flex-wrap: wrap; /* ì‘ì€ í™”ë©´ì—ì„œ ì¤„ë°”ê¿ˆ */
            justify-content: center;
        }

        .reward-button {
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.25);
            border-radius: 12px;
            padding: 20px 25px;
            font-size: 1.2em;
            font-weight: bold;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(8px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
            min-width: 180px;
        }

        .reward-button:hover {
            background: rgba(255, 255, 255, 0.25);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.25);
            transform: translateY(-3px);
        }

        .reward-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        #shopPopup h2 {
            color: #fff;
            font-weight: bold;
        }

        #shopList {
            color: #fff;
            font-weight: normal;
        }

        /* --- 2. ìƒì  UI/ë¡œì§: ì ìˆ˜ë¡œ íŒ¨ì‹œë¸Œ ì—…ê·¸ë ˆì´ë“œ êµ¬ë§¤ --- */
        /* 1) ìƒì ì— í‘œì‹œí•  ì•„ì´í…œ ëª©ë¡ ë° ê°€ê²© ì„¤ì • (ë³´ìƒ ëª©ë¡ê³¼ ë™ì¼, ê°€ê²©ì€ ì˜ˆì‹œ) */

        /* 2) ìƒì  UIì— ì•„ì´í…œ í‘œì‹œ ë° êµ¬ë§¤ ë¡œì§ êµ¬í˜„ */

        /* 3) ìƒì  ë²„íŠ¼ í´ë¦­ ì‹œ updateShopList í˜¸ì¶œ */
        /* ì´ ë¶€ë¶„ì€ JavaScriptì—ì„œ ì²˜ë¦¬ë©ë‹ˆë‹¤ */
    </style>
</head>
<body>
    <canvas id="gameCanvas" style="z-index: 1; position: relative;"></canvas>

    <!-- ì±„íŒ…ì°½ì„ ë³„ë„ ì»¨í…Œì´ë„ˆë¡œ ë¶„ë¦¬ -->
    <div id="chatContainer" style="
        position:fixed; top:0; left:0; width:100vw; height:100vh; 
        pointer-events:none; z-index:9999; display:flex; justify-content:flex-end; align-items:flex-start; padding:20px;
    ">
        <div id="chatBox" style="
            width:320px; pointer-events:auto;
            background:rgba(255,255,255,0.13);
            border-radius:18px;
            padding:14px 14px 10px 14px;
            color:#222;
            font-size:15px;
            display:flex; flex-direction:column; gap:8px;
            box-shadow:0 8px 32px rgba(0,0,0,0.25);
            border:1.5px solid rgba(255,255,255,0.25);
            backdrop-filter:blur(18px) saturate(1.5);
            -webkit-backdrop-filter:blur(18px) saturate(1.5);
        ">
            <div style="display:flex; gap:6px; margin-bottom:8px;">
                <input id="chatNickname" type="text" maxlength="20" placeholder="ë‹‰ë„¤ì„" style="
                    width:80px; border-radius:8px; border:none; padding:7px 10px; font-size:15px;
                    background:rgba(255,255,255,0.5); color:#222; outline:none;
                    box-shadow:0 1px 4px rgba(0,0,0,0.07);
                ">
                <input id="chatInput" type="text" maxlength="100" placeholder="ì±„íŒ… ì…ë ¥..." style="
                    flex:1; border-radius:8px; border:none; padding:7px 10px; font-size:15px;
                    background:rgba(255,255,255,0.5); color:#222; outline:none;
                    box-shadow:0 1px 4px rgba(0,0,0,0.07);
                ">
                <button id="chatSendBtn" style="
                    background:linear-gradient(90deg,#60a5fa,#818cf8);
                    color:#fff; border:none; border-radius:8px; padding:7px 18px;
                    font-weight:bold; cursor:pointer; font-size:15px;
                    box-shadow:0 2px 8px rgba(0,0,0,0.10);
                    transition:background 0.2s;
                ">ì „ì†¡</button>
            </div>
            <div id="chatMessages" style="
                height:120px; overflow-y:auto;
                background:rgba(255,255,255,0.18);
                border-radius:10px; padding:8px 6px;
                color:#222; font-size:15px;
                box-shadow:0 2px 8px rgba(0,0,0,0.07);
            "></div>
        </div>
    </div>
    
    <!-- HUD ìš”ì†Œë“¤ -->
    <div class="hud">
        <div class="glass-card hud-item" style="display:flex; flex-direction:row; align-items:center; gap:12px; max-width:90vw; overflow-x:auto;">
            <div style="display:flex; align-items:center; gap:8px; flex-wrap:nowrap;">
                <div style="display:flex; align-items:center; gap:4px;">
                    <div style="width:6px; height:6px; background:#ef4444; border-radius:50%; animation:pulse 2s infinite;"></div>
                    <span style="font-size:12px;">ì²´ë ¥</span>
                    <div class="health-bar" style="width:60px; margin:0 2px;"><div class="health-fill" id="healthFill" style="width:100%;"></div></div>
                    <span id="healthText" style="font-size:12px;">100/100</span>
                </div>
                <div style="display:flex; align-items:center; gap:4px; margin-left:8px;">
                    <div style="width:6px; height:6px; background:#3b82f6; border-radius:50%; animation:pulse 2s infinite;"></div>
                    <span style="font-size:12px;">íƒ„ì•½</span>
                    <div class="ammo-bar" style="width:60px; margin:0 2px;"><div class="ammo-fill" id="ammoFill" style="width:100%;"></div></div>
                    <span id="ammoText" style="font-size:12px;">60/60</span>
                </div>
                <div style="display:flex; align-items:center; gap:4px; margin-left:8px;">
                    <div style="width:6px; height:6px; background:#8b5cf6; border-radius:50%;"></div>
                    <span style="font-size:12px;">ì†ë„</span>
                    <span id="speedText" style="font-size:12px;">5</span>
                </div>
                <div style="display:flex; align-items:center; gap:4px; margin-left:8px;">
                    <div style="width:6px; height:6px; background:#dc2626; border-radius:50%;"></div>
                    <span style="font-size:12px;">ê³µê²©ë ¥</span>
                    <span id="damageText" style="font-size:12px;">20</span>
                </div>
                <div style="display:flex; align-items:center; gap:4px; margin-left:8px;">
                    <div style="width:6px; height:6px; background:#7c3aed; border-radius:50%;"></div>
                    <span style="font-size:12px;">ë‹¤ì¤‘</span>
                    <span id="multishotText" style="font-size:12px;">1</span>
                </div>
                <!-- ì ìˆ˜/ì›¨ì´ë¸Œ/ì  ìˆ˜ í‘œì‹œ -->
                <span id="scoreText" style="margin-left:12px; color:#fff; font-size:12px; font-weight:600;"></span>
                <span id="waveText" style="margin-left:8px; color:#fff; font-size:12px; font-weight:600;"></span>
                <span id="enemyCount" style="margin-left:8px; color:#fff; font-size:12px; font-weight:600;"></span>
                <!-- XPì™€ ë²„íŠ¼ë“¤ -->
                <span id="xpText" style="margin-left:12px; color:#ffe066; font-size:12px; font-weight:600;"></span>
                <button id="shopButton" style="margin-left:8px; font-size:11px; border-radius:4px; border:none; background:#ffe066; color:#222; padding:3px 12px; cursor:pointer;">ìƒì </button>
                <button id="testZoneHUDButton" style="margin-left:8px; font-size:11px; border-radius:4px; border:none; background:#ff6b6b; color:#fff; padding:3px 12px; cursor:pointer; display:none;">í…ŒìŠ¤íŠ¸</button>
                <button id="enemyDexHUDButton" style="margin-left:8px; font-size:11px; border-radius:4px; border:none; background:#8b5cf6; color:#fff; padding:3px 12px; cursor:pointer;">ë„ê°</button>
            </div>
        </div>
    </div>
    
    <!-- í™œì„± íš¨ê³¼ í‘œì‹œ (ë³„ë„ í–‰) -->
    <div id="activeEffectsContainer" style="position:fixed; top:50px; left:50%; transform:translateX(-50%); z-index:30; display:none;">
        <div id="activeEffects" style="font-size:11px; display:flex; gap:6px; flex-wrap:wrap; align-items:center; background:rgba(255,255,255,0.1); padding:4px 8px; border-radius:6px; backdrop-filter:blur(10px);">
            <div id="invincibilityEffect"></div>
            <div id="shieldBoostEffect"></div>
            <div id="timeSlowEffect"></div>
            <div id="magnetEffect"></div>
            <div id="healthRegenEffect"></div>
            <div id="rapidFireEffect"></div>
            <div id="piercingShotEffect"></div>
            <div id="explosiveShotEffect"></div>
            <div id="orbitingKnivesEffect"></div>
            <div id="ricochetShotEffect"></div>
            <div id="homingShotEffect"></div>
            <div id="splitShotEffect"></div>
            <div id="ammoRegenEffect"></div>
            <div id="timeStopEffect"></div>
            <div id="dashEffect"></div>
            <div id="lifeStealEffect"></div>
            <div id="critChanceEffect"></div>
            <div id="cooldownReductionEffect"></div>
            <div id="armorEffect"></div>
        </div>
    </div>
    
    <!-- í”Œë ˆì´ì–´2 HUD (ë©€í‹°í”Œë ˆì´ ëª¨ë“œì—ì„œë§Œ í‘œì‹œ) -->
    <div id="player2HUD" class="glass-card hud-item" style="display:none; position:fixed; top:80px; left:24px; z-index:20; flex-direction:row; align-items:center; gap:22px; min-width:unset; max-width:unset;">
        <div style="display:flex; align-items:center; gap:10px;">
            <div style="display:flex; align-items:center; gap:6px;">
                <div style="width:8px; height:8px; background:#ef4444; border-radius:50%; animation:pulse 2s infinite;"></div>
                <span style="color:#fff;">P2 ì²´ë ¥</span>
                <div class="health-bar" style="width:70px; margin:0 4px;"><div class="health-fill" id="healthFill2" style="width:100%;"></div></div>
                <span id="healthText2" style="color:#fff;">100/100</span>
            </div>
            <div style="display:flex; align-items:center; gap:6px; margin-left:16px;">
                <div style="width:8px; height:8px; background:#ef4444; border-radius:50%; animation:pulse 2s infinite;"></div>
                <span style="color:#fff;">P2 íƒ„ì•½</span>
                <div class="ammo-bar" style="width:70px; margin:0 4px;"><div class="ammo-fill" id="ammoFill2" style="width:100%;"></div></div>
                <span id="ammoText2" style="color:#fff;">60/60</span>
            </div>
        </div>
    </div>
    
    <!-- ë‚˜ë¨¸ì§€ HUD(ì›¨ì´ë¸Œ, ì¡°ì‘ë²•, ë¯¸ë‹ˆë§µ ë“±)ëŠ” ì•„ë˜/ì˜¤ë¥¸ìª½ ë“± ë³„ë„ ë°°ì¹˜ í•„ìš”ì‹œ ì¶”ê°€ -->
    
    <!-- ê²Œì„ ë©”ì‹œì§€ -->
    <div class="message" id="gameMessage" style="display: none;">
        <div class="glass-card">
            <div class="message-text" id="messageText"></div>
            <div class="message-sub" id="messageSubText"></div>
            <button id="restartButton" style="display:none; margin-top:18px; font-size:1.2em; padding:10px 30px; border-radius:8px; background:#6366f1; color:white; border:none; cursor:pointer;">ì¬ì‹œì‘</button>
        </div>
    </div>

    <!-- ì‹œì‘ í™”ë©´ -->
    <div id="startScreen" class="glass-card">
        <h1>ê¸€ë˜ìŠ¤ ì»´ë±ƒ ì•„ë ˆë‚˜</h1>
        <p>2D ë¸Œë¼ìš°ì € ê¸°ë°˜ ì „íˆ¬ ê²Œì„ - ì¤‘ë ¥ ë¬¼ë¦¬í•™, ê¸€ë˜ìŠ¤ëª¨í”¼ì¦˜ UI, ë´‡ ì „íˆ¬ ì‹œìŠ¤í…œ</p>
        <button id="startButton">ì‹œì‘í•˜ê¸°</button>
        <button id="enemyDexButton">ì  ë„ê°</button>
    </div>

    <!-- ë³´ìƒ ì„ íƒ í™”ë©´ -->
    <div id="rewardSelectionScreen" class="glass-card">
        <h2 id="rewardSelectionTitle">ë³´ìƒ ì„ íƒ</h2>
        <div class="reward-options" id="rewardOptions">
            <!-- ë³´ìƒ ë²„íŠ¼ë“¤ì´ ì—¬ê¸°ì— ë™ì ìœ¼ë¡œ ì¶”ê°€ë©ë‹ˆë‹¤. -->
        </div>
    </div>

    <!-- ì  ë„ê° í™”ë©´ -->
    <div id="enemyDexScreen" class="glass-card" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); z-index:300; min-width:600px; min-height:400px; max-width:90vw; max-height:80vh; flex-direction:row; align-items:stretch; padding:0; overflow:hidden; backdrop-filter:blur(20px); background:rgba(255,255,255,0.15); border:1px solid rgba(255,255,255,0.2); box-shadow:0 8px 32px rgba(0,0,0,0.3);">
        <!-- ì¢Œì¸¡ ë¦¬ìŠ¤íŠ¸ -->
        <div id="enemyDexList" style="width:200px; background:rgba(255,255,255,0.1); border-right:1px solid rgba(255,255,255,0.2); overflow-y:auto; max-height:80vh; min-height:400px; display:flex; flex-direction:column; backdrop-filter:blur(10px);"></div>
        <!-- ìš°ì¸¡ ìƒì„¸ -->
        <div id="enemyDexDetail" style="flex:1; display:flex; flex-direction:column; align-items:center; justify-content:flex-start; min-width:300px; padding:32px 16px 16px 16px; overflow-y:auto; background:rgba(255,255,255,0.05); backdrop-filter:blur(5px);"></div>
        <button id="closeEnemyDexButton" style="position:absolute; top:12px; right:16px; background:rgba(255,255,255,0.2); border:1px solid rgba(255,255,255,0.3); border-radius:8px; padding:8px 16px; color:#fff; cursor:pointer; backdrop-filter:blur(10px); transition:all 0.3s ease;">ë‹«ê¸°</button>
    </div>

    <!-- í€˜ìŠ¤íŠ¸ ë²„íŠ¼ ë° í€˜ìŠ¤íŠ¸ íŒì—… -->
    <button id="questButton" style="position:absolute; top:24px; left:220px; z-index:20; background:rgba(255,255,255,0.18); color:white; border:none; border-radius:8px; padding:8px 18px; font-size:15px; cursor:pointer;">í€˜ìŠ¤íŠ¸</button>
    <div id="questPopup" class="glass-card" style="display:none; position:absolute; top:60px; left:220px; z-index:30; min-width:260px; min-height:180px;">
        <h3 style="color:white; margin-bottom:12px;">í€˜ìŠ¤íŠ¸</h3>
        <div id="questList" style="color:white; font-size:15px;"></div>
        <button id="closeQuestButton" style="margin-top:18px;">ë‹«ê¸°</button>
    </div>

    <!-- ì¸íŠ¸ë¡œ í™”ë©´: ì†”ë¡œ/í•¨ê»˜ í”Œë ˆì´/í…ŒìŠ¤íŒ… ì¡´ ì„ íƒ -->
    <div id="introScreen" class="glass-card" style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); z-index:200; display:flex; flex-direction:column; align-items:center; justify-content:center; min-width:340px; min-height:280px;">
        <h1 style="font-size:2.5em; margin-bottom:18px;">ê¸€ë˜ìŠ¤ ì»´ë±ƒ ì•„ë ˆë‚˜</h1>
        <div class="reward-options" style="margin-bottom:20px;">
            <button id="soloButton" class="reward-button" style="min-width:200px;">ì†”ë¡œ í”Œë ˆì´</button>
            <button id="multiButton" class="reward-button" style="min-width:200px;">í•¨ê»˜ í”Œë ˆì´</button>
            <button id="testZoneButton" class="reward-button" style="min-width:200px;">í…ŒìŠ¤íŒ… ì¡´</button>
        </div>
        <div style="margin-bottom:15px; display:flex; align-items:center; gap:8px;">
            <input type="checkbox" id="mobileModeCheckbox" style="width:18px; height:18px; cursor:pointer;">
            <label for="mobileModeCheckbox" style="color:#fff; font-size:1.1em; cursor:pointer;">ğŸ“± ëª¨ë°”ì¼ ëª¨ë“œ</label>
        </div>
        <div id="multiInfo" style="display:none; color:#fff; margin-top:18px; font-size:1.1em;">í•¨ê»˜ í”Œë ˆì´(ì˜¨ë¼ì¸)ëŠ” ì¶”í›„ ì§€ì› ì˜ˆì •ì…ë‹ˆë‹¤.</div>
    </div>

    <div id="multiJoinPopup" class="glass-card" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); z-index:300;">
        <h2>ì˜¨ë¼ì¸ ë°© ì…ì¥</h2>
        <input id="multiNickname" placeholder="ë‹‰ë„¤ì„" style="margin-bottom:8px; width:90%;" />
        <input id="multiRoomId" placeholder="ë°© ì½”ë“œ(ì•„ë¬´ê±°ë‚˜)" style="margin-bottom:8px; width:90%;" />
        <button id="multiJoinBtn">ì…ì¥</button>
        <button id="multiJoinCancel">ì·¨ì†Œ</button>
    </div>

    <div id="mobileControls" style="display:none; position:fixed; bottom:0; left:0; right:0; z-index:100; pointer-events:none;">
        <!-- ì™¼ìª½(ì´ë™) ì¡°ì´ìŠ¤í‹± - íŒŒë€ìƒ‰ ê¸€ë˜ìŠ¤ëª¨í”¼ì¦˜ -->
        <div id="joystickContainer" style="position:absolute; bottom:80px; left:80px; width:120px; height:120px; pointer-events:auto;">
            <div id="joystickBase" style="width:100%; height:100%; background:rgba(59,130,246,0.25); border:2px solid rgba(59,130,246,0.3); border-radius:50%; display:flex; align-items:center; justify-content:center; backdrop-filter:blur(10px);">
                <div id="joystickThumb" style="width:50px; height:50px; background:rgba(59,130,246,0.7); border-radius:50%; position:absolute; transform:translate(-50%, -50%);"></div>
            </div>
        </div>
    
        <!-- ì˜¤ë¥¸ìª½(ì¡°ì¤€) ì¡°ì´ìŠ¤í‹± - ë¹¨ê°„ìƒ‰ ê¸€ë˜ìŠ¤ëª¨í”¼ì¦˜ -->
        <div id="aimJoystickContainer" style="position:absolute; bottom:80px; right:80px; width:120px; height:120px; pointer-events:auto;">
            <div id="aimJoystickBase" style="width:100%; height:100%; background:rgba(239,68,68,0.25); border:2px solid rgba(239,68,68,0.3); border-radius:50%; display:flex; align-items:center; justify-content:center; backdrop-filter:blur(10px);">
                <div id="aimJoystickThumb" style="width:50px; height:50px; background:rgba(239,68,68,0.7); border-radius:50%; position:absolute; transform:translate(-50%, -50%);"></div>
            </div>
        </div>
    
        <!-- ì•¡ì…˜ ë²„íŠ¼ë“¤ - ì¤‘ì•™ í•˜ë‹¨ì— ë°°ì¹˜ -->
        <div id="actionButtons" style="position:absolute; bottom:30px; left:50%; transform:translateX(-50%); display:flex; flex-direction:row; gap:15px; pointer-events:auto;">
            <button id="jumpButton" class="mobile-button" style="width:60px; height:60px; background:rgba(34,197,94,0.8); border:2px solid rgba(255,255,255,0.3); border-radius:50%; color:#fff; font-size:20px; cursor:pointer; backdrop-filter:blur(10px);">â†‘</button>
            <button id="fireButton" class="mobile-button" style="width:80px; height:80px; background:rgba(239,68,68,0.8); border:2px solid rgba(255,255,255,0.3); border-radius:50%; color:#fff; font-size:24px; cursor:pointer; backdrop-filter:blur(10px);">â—</button>
            <button id="reloadButton" class="mobile-button" style="width:60px; height:60px; background:rgba(59,130,246,0.8); border:2px solid rgba(255,255,255,0.3); border-radius:50%; color:#fff; font-size:18px; cursor:pointer; backdrop-filter:blur(10px);">R</button>
        </div>
    </div>

    <!-- ë©€í‹°í”Œë ˆì´ ëª¨ë“œ ì„ íƒ -->
    <div id="multiplayerModeSelect" class="glass-card" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); z-index:200; min-width:400px;">
        <h2 style="text-align:center; margin-bottom:20px; color:#fff;">ë©€í‹°í”Œë ˆì´ ëª¨ë“œ ì„ íƒ</h2>
        <div style="display:flex; flex-direction:column; gap:15px;">
            <button id="leaderSystemButton" class="mode-button" style="background:rgba(99, 102, 241, 0.8); border:none; border-radius:8px; padding:15px; color:#fff; cursor:pointer; text-align:left;">
                <h3 style="margin:0 0 8px 0;">ë¦¬ë” ì‹œìŠ¤í…œ</h3>
                <p style="margin:0; font-size:14px; opacity:0.9;">í”Œë ˆì´ì–´1ì´ ë¦¬ë”ê°€ ë˜ì–´ ì¡°ì¤€ ë°©í–¥ì„ ê²°ì •í•˜ê³ , í”Œë ˆì´ì–´2ê°€ ë”°ë¼ê°‘ë‹ˆë‹¤.</p>
            </button>
            <button id="hybridSystemButton" class="mode-button" style="background:rgba(34, 197, 94, 0.8); border:none; border-radius:8px; padding:15px; color:#fff; cursor:pointer; text-align:left;">
                <h3 style="margin:0 0 8px 0;">í•˜ì´ë¸Œë¦¬ë“œ ì‹œìŠ¤í…œ</h3>
                <p style="margin:0; font-size:14px; opacity:0.9;">í”Œë ˆì´ì–´1ì€ ë§ˆìš°ìŠ¤ ì¡°ì¤€, í”Œë ˆì´ì–´2ëŠ” ìë™ ì¡°ì¤€ìœ¼ë¡œ í”Œë ˆì´í•©ë‹ˆë‹¤.</p>
            </button>
            <button id="onlineMultiplayerButton" class="mode-button" style="background:rgba(14, 165, 233, 0.8); border:none; border-radius:8px; padding:15px; color:#fff; cursor:pointer; text-align:left;">
                <h3 style="margin:0 0 8px 0;">ì˜¨ë¼ì¸ìœ¼ë¡œ í”Œë ˆì´</h3>
                <p style="margin:0; font-size:14px; opacity:0.9;">ì‹¤ì‹œê°„ ì˜¨ë¼ì¸ ë©€í‹°í”Œë ˆì´(ë² íƒ€)</p>
            </button>
            <button id="backToIntro" class="back-button" style="background:rgba(255,255,255,0.2); border:none; border-radius:6px; padding:10px; color:#fff; cursor:pointer;">â† ë’¤ë¡œê°€ê¸°</button>
        </div>
    </div>

    <!-- ë°˜ë“œì‹œ ë°”ê¹¥ì— ìœ„ì¹˜! -->
    <div id="onlineMultiplayerPopup" class="glass-card" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); z-index:220; min-width:340px; min-height:180px; text-align:center;">
        <h2 style="color:#0ea5e9; margin-bottom:12px;">ì˜¨ë¼ì¸ ë©€í‹°í”Œë ˆì´</h2>
        <div style="color:white; font-size:1.1em; margin-bottom:18px;">
            ì˜¨ë¼ì¸ ë°©ì„ ë§Œë“¤ê±°ë‚˜, ì•„ë˜ ë¦¬ìŠ¤íŠ¸ì—ì„œ ì…ì¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        </div>
        <div style="margin-bottom:12px;">
            <input id="roomNameInput" type="text" placeholder="ë°© ì´ë¦„ ì…ë ¥" style="padding:7px; border-radius:5px; border:none; width:140px;">
            <button id="createRoomButton" style="padding:7px 16px; border-radius:5px; border:none; background:#22c55e; color:white; margin-left:6px; cursor:pointer;">ë°© ë§Œë“¤ê¸°</button>
        </div>
        <div id="roomListContainer" style="margin-bottom:18px; text-align:left; max-height:180px; overflow-y:auto; background:rgba(0,0,0,0.08); border-radius:8px; padding:10px 8px; color:#fff; font-size:1em; min-width:220px;">
            <b>ë°© ë¦¬ìŠ¤íŠ¸</b>
            <div id="roomList"></div>
        </div>
        <button id="closeOnlineMultiplayerPopup" style="margin-top:8px;">ë‹«ê¸°</button>
    </div>

    <!-- ë¦¬ë” ì‹œìŠ¤í…œ ì„¤ì • -->
    <div id="leaderSetup" class="glass-card" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); z-index:200; min-width:400px;">
        <h2 style="text-align:center; margin-bottom:20px; color:#fff;">ë¦¬ë” ì‹œìŠ¤í…œ ì„¤ì •</h2>
        <div style="display:flex; flex-direction:column; gap:15px;">
            <div>
                <label style="color:#fff; display:block; margin-bottom:5px;">ë¦¬ë” ì´ë¦„:</label>
                <input id="leaderName" type="text" placeholder="ë¦¬ë”" style="width:100%; padding:8px; border-radius:4px; border:none;">
            </div>
            <div>
                <label style="color:#fff; display:block; margin-bottom:5px;">ë¦¬ë” ìƒ‰ìƒ:</label>
                <input id="leaderColor" type="color" value="#3b82f6" style="width:100%; height:40px; border:none; border-radius:4px;">
            </div>
            <div>
                <label style="color:#fff; display:block; margin-bottom:5px;">ë”°ë¥´ëŠ”ì ì´ë¦„:</label>
                <input id="followerName" type="text" placeholder="ë”°ë¥´ëŠ”ì" style="width:100%; padding:8px; border-radius:4px; border:none;">
            </div>
            <div>
                <label style="color:#fff; display:block; margin-bottom:5px;">ë”°ë¥´ëŠ”ì ìƒ‰ìƒ:</label>
                <input id="followerColor" type="color" value="#ef4444" style="width:100%; height:40px; border:none; border-radius:4px;">
            </div>
            <button id="leaderStartButton" class="start-button" style="background:#6366f1; border:none; border-radius:6px; padding:12px; color:#fff; cursor:pointer; font-weight:bold;">ê²Œì„ ì‹œì‘</button>
            <button id="backToModeSelect" class="back-button" style="background:rgba(255,255,255,0.2); border:none; border-radius:6px; padding:10px; color:#fff; cursor:pointer;">â† ë’¤ë¡œê°€ê¸°</button>
        </div>
    </div>

    <!-- í•˜ì´ë¸Œë¦¬ë“œ ì‹œìŠ¤í…œ ì„¤ì • -->
    <div id="hybridSetup" class="glass-card" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); z-index:200; min-width:400px;">
        <h2 style="text-align:center; margin-bottom:20px; color:#fff;">í•˜ì´ë¸Œë¦¬ë“œ ì‹œìŠ¤í…œ ì„¤ì •</h2>
        <div style="display:flex; flex-direction:column; gap:15px;">
            <div>
                <label style="color:#fff; display:block; margin-bottom:5px;">í”Œë ˆì´ì–´1 ì´ë¦„:</label>
                <input id="player1Name" type="text" placeholder="í”Œë ˆì´ì–´1" style="width:100%; padding:8px; border-radius:4px; border:none;">
            </div>
            <div>
                <label style="color:#fff; display:block; margin-bottom:5px;">í”Œë ˆì´ì–´1 ìƒ‰ìƒ:</label>
                <input id="player1Color" type="color" value="#3b82f6" style="width:100%; height:40px; border:none; border-radius:4px;">
            </div>
            <div>
                <label style="color:#fff; display:block; margin-bottom:5px;">í”Œë ˆì´ì–´2 ì´ë¦„:</label>
                <input id="player2Name" type="text" placeholder="í”Œë ˆì´ì–´2" style="width:100%; padding:8px; border-radius:4px; border:none;">
            </div>
            <div>
                <label style="color:#fff; display:block; margin-bottom:5px;">í”Œë ˆì´ì–´2 ìƒ‰ìƒ:</label>
                <input id="player2Color" type="color" value="#ef4444" style="width:100%; height:40px; border:none; border-radius:4px;">
            </div>
            <div>
                <label style="color:#fff; display:block; margin-bottom:5px;">í•˜ì´ë¸Œë¦¬ë“œ í”Œë ˆì´ì–´ ì„ íƒ:</label>
                <select id="hybridPlayer" style="width:100%; padding:8px; border-radius:4px; border:none;">
                    <option value="player1">í”Œë ˆì´ì–´1 (ë§ˆìš°ìŠ¤ ì¡°ì¤€)</option>
                    <option value="player2">í”Œë ˆì´ì–´2 (ìë™ ì¡°ì¤€)</option>
                </select>
            </div>
            <button id="hybridStartButton" class="start-button" style="background:#22c55e; border:none; border-radius:6px; padding:12px; color:#fff; cursor:pointer; font-weight:bold;">ê²Œì„ ì‹œì‘</button>
            <button id="backToModeSelect" class="back-button" style="background:rgba(255,255,255,0.2); border:none; border-radius:6px; padding:10px; color:#fff; cursor:pointer;">â† ë’¤ë¡œê°€ê¸°</button>
        </div>
    </div>
    </div>

    <!-- ë­í‚¹ í™”ë©´ -->
    <div id="rankingScreen" class="glass-card" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); z-index:250; min-width:340px; min-height:320px;">
        <h2 style="color:white; margin-bottom:12px;">ë­í‚¹</h2>
        <div id="rankingList" style="color:white; font-size:15px; min-height:180px;"></div>
        <button id="closeRankingButton" style="margin-top:18px;">ë‹«ê¸°</button>
    </div>

    <!-- ë³´ìŠ¤ ì²´ë ¥ë°” ë° ì´ë¦„ í‘œì‹œìš© -->
    <div id="bossBarContainer" style="display:none; position:fixed; top:38px; left:50%; transform:translateX(-50%); z-index:30; min-width:320px; max-width:60vw;">
        <div id="bossName" style="color:#fff; font-size:2em; font-weight:700; text-align:center; text-shadow:0 2px 8px #000; margin-bottom:6px;"></div>
        <div style="background:rgba(0,0,0,0.3); border-radius:8px; width:100%; height:22px; box-shadow:0 2px 8px #000;">
            <div id="bossBar" style="height:100%; background:linear-gradient(90deg,#ff007f,#ff8c00); border-radius:8px; width:100%; transition:width 0.3s;"></div>
        </div>
    </div>

    <!-- ë¯¸ë‹ˆë§µ (HUD ì•„ë˜ ì˜¤ë¥¸ìª½ ë“± ì›í•˜ëŠ” ìœ„ì¹˜ë¡œ ì¡°ì • ê°€ëŠ¥) -->
    <div class="minimap" id="minimap" style="position:fixed; top:60px; left:32px; z-index:10;">
        <div class="minimap-player" id="minimapPlayer"></div>
    </div>

    <!-- 2. ìƒì  íŒì—… UI ì¶”ê°€ (body í•˜ë‹¨) -->
    <div id="shopPopup" class="glass-card" style="display:none; position:fixed; top:80px; left:50%; transform:translateX(-50%); z-index:200; min-width:340px; min-height:220px;">
        <h2 style="color:#222; margin-bottom:12px;">ìƒì  (XPë¡œ ì—…ê·¸ë ˆì´ë“œ)</h2>
        <div id="shopList" style="color:#222; font-size:15px; min-height:120px;"></div>
        <button id="closeShopButton" style="margin-top:18px;">ë‹«ê¸°</button>
    </div>

    <!-- 3. í…ŒìŠ¤íŠ¸ ì¡´ UI ì¶”ê°€ -->
    <div id="testZonePopup" class="glass-card" style="display:none; position:fixed; top:80px; left:50%; transform:translateX(-50%); z-index:200; min-width:800px; min-height:500px;">
        <h2 style="color:#222; margin-bottom:12px;">í…ŒìŠ¤íŠ¸ ì¡´</h2>
        <div style="display:flex; gap:20px; flex-wrap:wrap;">
            <!-- ì  ì†Œí™˜ íŒ¨ë„ -->
            <div style="flex:1; min-width:200px;">
                <h3 style="color:#222; margin-bottom:8px;">ì  ì†Œí™˜</h3>
                <div id="enemySpawnList" style="color:#222; font-size:14px; max-height:200px; overflow-y:auto;"></div>
            </div>
            <!-- ë³´ìŠ¤ ì†Œí™˜ íŒ¨ë„ -->
            <div style="flex:1; min-width:200px;">
                <h3 style="color:#222; margin-bottom:8px;">ë³´ìŠ¤ ì†Œí™˜</h3>
                <div id="bossSpawnList" style="color:#222; font-size:14px; max-height:200px; overflow-y:auto;"></div>
            </div>
            <!-- ëŠ¥ë ¥ ë¶€ì—¬ íŒ¨ë„ -->
            <div style="flex:1; min-width:200px;">
                <h3 style="color:#222; margin-bottom:8px;">ëŠ¥ë ¥ ë¶€ì—¬</h3>
                <div id="abilityList" style="color:#222; font-size:14px; max-height:200px; overflow-y:auto;"></div>
            </div>
        </div>
        <div style="display:flex; gap:10px; margin-top:18px;">
            <button id="returnToMenuButton" style="background:#ff6b6b; color:#fff;">ë©”ì¸ ë©”ë‰´</button>
        </div>
    </div>

    <!-- ì†”ë¡œ ëª¨ë“œ ì„ íƒ íŒì—… -->
    <div id="soloModeSelect" class="glass-card" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); z-index:210; min-width:340px;">
        <h2 style="text-align:center; margin-bottom:20px; color:#fff;">ì†”ë¡œ ëª¨ë“œ ì„ íƒ</h2>
        <div style="display:flex; flex-direction:column; gap:15px;">
            <button id="normalModeButton" class="mode-button" style="background:rgba(99, 102, 241, 0.8); border:none; border-radius:8px; padding:15px; color:#fff; cursor:pointer; text-align:left; font-size:1.1em;">ì¼ë°˜ ëª¨ë“œ</button>
            <button id="bossRushModeButton" class="mode-button" style="background:rgba(239, 68, 68, 0.8); border:none; border-radius:8px; padding:15px; color:#fff; cursor:pointer; text-align:left; font-size:1.1em;">ë³´ìŠ¤ ëŸ¬ì‹œ ëª¨ë“œ</button>
            <button id="backToIntroFromSolo" class="back-button" style="background:rgba(255,255,255,0.2); border:none; border-radius:6px; padding:10px; color:#fff; cursor:pointer;">â† ë’¤ë¡œê°€ê¸°</button>
        </div>
    </div>
    <div id="enterRoomPopup" class="glass-card" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); z-index:230; min-width:320px; text-align:center;">
        <h2 style="color:#0ea5e9; margin-bottom:12px;">ë°© ì…ì¥</h2>
        <div style="margin-bottom:12px;">
            <input id="playerNameInput" type="text" placeholder="í”Œë ˆì´ì–´ ì´ë¦„ ì…ë ¥" style="padding:7px; border-radius:5px; border:none; width:140px;">
        </div>
        <button id="enterRoomButton" style="padding:7px 16px; border-radius:5px; border:none; background:#6366f1; color:white; margin-right:8px; cursor:pointer;">ì…ì¥</button>
        <button id="cancelEnterRoomButton" style="padding:7px 16px; border-radius:5px; border:none; background:#aaa; color:white; cursor:pointer;">ì·¨ì†Œ</button>
    </div>
    <div id="roomLobbyPopup" class="glass-card" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); z-index:240; min-width:340px; text-align:center;">
        <h2 style="color:#0ea5e9; margin-bottom:12px;">ë°© ë¡œë¹„</h2>
        <div id="lobbyRoomName" style="color:#fff; margin-bottom:10px;"></div>
        <div id="lobbyPlayerList" style="margin-bottom:16px; color:#fff; text-align:left; min-width:180px;"></div>
        <button id="readyButton" style="padding:7px 16px; border-radius:5px; border:none; background:#22c55e; color:white; margin-right:8px; cursor:pointer;">ì¤€ë¹„</button>
        <button id="leaveLobbyButton" style="padding:7px 16px; border-radius:5px; border:none; background:#aaa; color:white; cursor:pointer;">ë‚˜ê°€ê¸°</button>
        <div id="lobbyStatusMsg" style="margin-top:12px; color:#0ea5e9;"></div>
    </div>
    <div id="playerNamesBar" style="position:fixed; top:10px; left:50%; transform:translateX(-50%); color:#fff; font-size:1.2em; z-index:300;"></div>

    <script>
        // GlassCombatArena ê²Œì„ í´ë˜ìŠ¤ ì •ì˜
        class GlassCombatArena {
            constructor() {
                // ìº”ë²„ìŠ¤ ë° 2D ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™”
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.resizeCanvas(); // ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì •
                
                // ê²Œì„ ìƒíƒœ ì´ˆê¸°í™”
                this.gameState = {
                    player: { // í”Œë ˆì´ì–´ ê°ì²´
                        x: this.canvas.width / 2, // ì´ˆê¸° X ìœ„ì¹˜ (ìº”ë²„ìŠ¤ ì¤‘ì•™)
                        y: this.canvas.height / 2, // ì´ˆê¸° Y ìœ„ì¹˜ (ìº”ë²„ìŠ¤ ì¤‘ì•™)
                        width: 40, // ë„ˆë¹„
                        height: 40, // ë†’ì´
                        vx: 0, // Xì¶• ì†ë„
                        vy: 0, // Yì¶• ì†ë„
                        health: 200, // í˜„ì¬ ì²´ë ¥ (150 -> 200ìœ¼ë¡œ ë³€ê²½)
                        maxHealth: 200, // ìµœëŒ€ ì²´ë ¥ (150 -> 200ìœ¼ë¡œ ë³€ê²½)
                        ammo: 30, // í˜„ì¬ íƒ„ì•½ (30ë°œë¡œ ê³ ì •)
                        maxAmmo: 30, // ìµœëŒ€ íƒ„ì•½ (30ë°œë¡œ ê³ ì •)
                        speed: 5, // ì´ë™ ì†ë„
                        jumpPower: 15, // ì í”„ë ¥
                        onGround: false, // ì§€ë©´ ì ‘ì´‰ ì—¬ë¶€
                        facing: 0, // ë°”ë¼ë³´ëŠ” ë°©í–¥ (ë¼ë””ì•ˆ)
                        expression: ':D', // í‘œì •
                        color: '#6366f1', // ìƒ‰ìƒ
                        baseDamage: 10, // ê¸°ë³¸ ê³µê²©ë ¥ (20 -> 25ë¡œ ìƒí–¥)
                        multishot: 1, // ë‹¤ì¤‘ ë°œì‚¬ íšŸìˆ˜
                        rapidFireTime: 0, // ì—°ë°œ ëª¨ë“œ ì¢…ë£Œ ì‹œê°„
                        damageReductionFactor: 1, // í”¼í•´ ê°ì†Œìœ¨ (1 = 100% í”¼í•´, 0.5 = 50% í”¼í•´)
                        shieldBoostEndTime: 0, // ì‰´ë“œ ê°•í™” ì¢…ë£Œ ì‹œê°„
                        healthRegenEndTime: 0, // ì²´ë ¥ ì¬ìƒ ì¢…ë£Œ ì‹œê°„
                        lastRegenTick: 0, // ë§ˆì§€ë§‰ ì²´ë ¥ ì¬ìƒ í‹± ì‹œê°„
                        magnetEndTime: 0, // ìì„ íš¨ê³¼ ì¢…ë£Œ ì‹œê°„
                        magnetRadius: 200, // ìì„ íš¨ê³¼ ë²”ìœ„
                        lastHitById: null, // ë§ˆì§€ë§‰ìœ¼ë¡œ í”Œë ˆì´ì–´ì—ê²Œ í”¼í•´ë¥¼ ì¤€ ì—”í‹°í‹°ì˜ ID
                        type: 'player', // í”Œë ˆì´ì–´ íƒ€ì… ì¶”ê°€
                        orbitingKnives: [], // íšŒì „ ì¹¼ë‚  ë°°ì—´ ì¶”ê°€
                        piercingShot: 0, // ê´€í†µ ì‚¬ê²© ë ˆë²¨ (0: ì—†ìŒ, 1+: ê´€í†µ íšŸìˆ˜)
                        explosiveShot: 0, // í­ë°œ ì‚¬ê²© ë ˆë²¨ (0: ì—†ìŒ, 1+: ë ˆë²¨)
                        ricochetLevel: 0, // ë„íƒ„ ì‚¬ê²© ë ˆë²¨
                        homingLevel: 0, // ìœ ë„ ì‚¬ê²© ë ˆë²¨
                        splitLevel: 0, // ë¶„ì—´ ì‚¬ê²© ë ˆë²¨
                        lifeStealPercent: 0, // ìƒëª…ë ¥ í¡ìˆ˜ìœ¨
                        critChance: 0, // ì¹˜ëª…íƒ€ í™•ë¥ 
                        critMultiplier: 1.5, // ì¹˜ëª…íƒ€ ë°°ìœ¨
                        cooldownReduction: 0, // ì¬ì‚¬ìš© ëŒ€ê¸°ì‹œê°„ ê°ì†Œìœ¨
                        armor: 0, // ë°©ì–´ë ¥ (ê³ ì • í”¼í•´ ê°ì†Œ)
                        timeStopEndTime: 0, // ì‹œê°„ ì •ì§€ ì¢…ë£Œ ì‹œê°„
                        ammoRegenEndTime: 0, // íƒ„ì•½ ì¬ìƒ ì¢…ë£Œ ì‹œê°„
                        lastAmmoRegenTick: 0, // ë§ˆì§€ë§‰ íƒ„ì•½ ì¬ìƒ í‹±
                        ammoRegenAmount: 0, // íƒ„ì•½ ì¬ìƒëŸ‰
                        dashCooldown: 0, // ë§ˆì§€ë§‰ ëŒ€ì‹œ ì‹œê°
                        dashEndTime: 0, // ëŒ€ì‹œ ì¢…ë£Œ ì‹œê°
                        isDashing: false, // ëŒ€ì‹œ ì¤‘ ì—¬ë¶€
                        reloadTime: 1500, // ê¸°ë³¸ ì¬ì¥ì „ ì‹œê°„(ms)
                        isReloading: false,
                        machineGunMode: false, // ê¸°ê´€ë‹¨ì´ íŒ¨ì‹œë¸Œ
                        machineGunPenalty: false, // ê¸°ê´€ë‹¨ì´ íŒ¨ë„í‹°
                        reloadPenalty: 0, // íŒ¨ì‹œë¸Œë¡œ ì¸í•œ ì¶”ê°€ ì¬ì¥ì „ ì‹œê°„(ms)
                        gunRecoil: 0,
                        gunRecoilTarget: 0,
                    },
                    player2: null, // í”Œë ˆì´ì–´2 ê°ì²´ (ë©€í‹°í”Œë ˆì´ìš©)
                    multiplayerMode: null, // ë©€í‹°í”Œë ˆì´ ëª¨ë“œ ('leader', 'hybrid', null)
                    multiplayerConfig: null, // ë©€í‹°í”Œë ˆì´ ì„¤ì •
                    // ë¶€í™œ ì‹œìŠ¤í…œ ê´€ë ¨ ì†ì„±ë“¤
                    player1Dead: false, // í”Œë ˆì´ì–´1 ì‚¬ë§ ì—¬ë¶€
                    player2Dead: false, // í”Œë ˆì´ì–´2 ì‚¬ë§ ì—¬ë¶€
                    lastDeathWave: 0, // ë§ˆì§€ë§‰ ì‚¬ë§í•œ ì›¨ì´ë¸Œ
                    revivalWaveCount: 0, // ë¶€í™œì„ ìœ„í•œ ì›¨ì´ë¸Œ ì¹´ìš´íŠ¸
                    enemies: [], // ì  ë°°ì—´
                    projectiles: [], // ë°œì‚¬ì²´ ë°°ì—´
                    items: [], // ì•„ì´í…œ ë°°ì—´
                    particles: [], // íŒŒí‹°í´ ë°°ì—´
                    floatingTexts: [], // ë– ë‹¤ë‹ˆëŠ” í…ìŠ¤íŠ¸ ë°°ì—´ (ì²´ë ¥ ë³€í™” ë“±)
                    allies: [], // ì•„êµ° ë°°ì—´ ì¶”ê°€
                    score: 0, // í˜„ì¬ ì ìˆ˜
                    wave: 1, // í˜„ì¬ ì›¨ì´ë¸Œ
                    gameStatus: 'start', // ê²Œì„ ìƒíƒœ ('start', 'playing', 'wave-complete', 'game-over', 'reward-selection')
                    message: '', // í˜„ì¬ í‘œì‹œë˜ëŠ” ë©”ì‹œì§€ í…ìŠ¤íŠ¸
                    messageTimer: 0, // ë©”ì‹œì§€ íƒ€ì´ë¨¸
                    playerSlowedEndTime: 0, // í”Œë ˆì´ì–´ ë‘”í™” íš¨ê³¼ ì¢…ë£Œ ì‹œê°„
                    timeSlowEndTime: 0, // ì‹œê°„ ë‘”í™” íš¨ê³¼ ì¢…ë£Œ ì‹œê°„ (ì  ëŠë ¤ì§)
                    timeSlowEffect: 1 // ì‹œê°„ ë‘”í™” íš¨ê³¼ (1 = ì •ìƒ ì†ë„, 0 = ì •ì§€)
                };
                
                // ì…ë ¥ ìƒíƒœ ì´ˆê¸°í™”
                this.keys = {}; // ëˆŒë¦° í‚¤ ìƒíƒœ ì €ì¥ ê°ì²´
                this.mouse = { x: 0, y: 0 }; // ë§ˆìš°ìŠ¤ í˜„ì¬ ìœ„ì¹˜
                
                // ëª¨ë°”ì¼ ëª¨ë“œ ê´€ë ¨ ë³€ìˆ˜
                this.mobileMode =  false; // ëª¨ë°”ì¼ ëª¨ë“œ í™œì„±í™” ì—¬ë¶€
                this.touchControls = {
                    joystick: { x: 0, y: 0, active: false, centerX: 0, centerY: 0 },
                    aimJoystick: { x: 0, y: 0, active: false, centerX: 0, centerY: 0 },
                    fireButton: { pressed: false },
                    jumpButton: { pressed: false },
                    reloadButton: { pressed: false },
                };
                
                // ê²Œì„ ìƒìˆ˜ ì •ì˜ (ë‚œì´ë„ ë° ê²Œì„ í”Œë ˆì´ ì¡°ì •)
                this.GRAVITY = 0.8; // ì¤‘ë ¥ ê°€ì†ë„
                this.FRICTION = 0.85; // ë§ˆì°° ê³„ìˆ˜
                this.GROUND_Y = 50; // ì§€ë©´ì˜ Y ì¢Œí‘œ (ìº”ë²„ìŠ¤ í•˜ë‹¨ìœ¼ë¡œë¶€í„°ì˜ ê±°ë¦¬)
                
                // í€˜ìŠ¤íŠ¸ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
                this.questSystem = {
                    activeQuests: [],
                    completedQuests: [],
                    questTypes: [
                        {
                            id: 'wave_clear',
                            name: 'ì›¨ì´ë¸Œ ëŒíŒŒ',
                            description: '{target}ì›¨ì´ë¸Œê¹Œì§€ í´ë¦¬ì–´',
                            type: 'wave',
                            rewards: { score: 500, health: 50 }
                        },
                        {
                            id: 'score_reach',
                            name: 'ì ìˆ˜ ë‹¬ì„±',
                            description: '{target}ì  ë‹¬ì„±',
                            type: 'score',
                            rewards: { score: 300, ammo: 30 }
                        },
                        {
                            id: 'boss_kill',
                            name: 'ë³´ìŠ¤ ì²˜ì¹˜',
                            description: 'ë³´ìŠ¤ {target}ë§ˆë¦¬ ì²˜ì¹˜',
                            type: 'boss_kill',
                            rewards: { score: 1000, health: 100, ammo: 50 }
                        },
                        {
                            id: 'enemy_kill',
                            name: 'ì  ì²˜ì¹˜',
                            description: 'ì  {target}ë§ˆë¦¬ ì²˜ì¹˜',
                            type: 'enemy_kill',
                            rewards: { score: 200, health: 30 }
                        },
                        {
                            id: 'item_collect',
                            name: 'ì•„ì´í…œ ìˆ˜ì§‘',
                            description: 'ì•„ì´í…œ {target}ê°œ ìˆ˜ì§‘',
                            type: 'item_collect',
                            rewards: { score: 150, ammo: 20 }
                        }
                    ]
                };
                // ì‚¬ìš©ì ìš”ì²­ì— ë”°ë¼ í‘œì • ë°°ì—´ì— ': @' ì¶”ê°€
                this.EXPRESSIONS = [':D', ':>', ':<', ':O', ':/', ':#', 'XD', 'X>', ':V', ':@']; // ìºë¦­í„° í‘œì • ë°°ì—´
                
                // ì•„ì´í…œ íƒ€ì… ì •ì˜ (ìƒˆë¡œìš´ ì•„ì´í…œ ì¶”ê°€)
                this.ITEM_TYPES = [
                    { type: 'health', effect: 50, color: '#22c55e', emoji: 'â¤ï¸' }, // ì²´ë ¥ íšŒë³µ
                    { type: 'ammo', effect: 30, color: '#f59e0b', emoji: 'ğŸ”‹' }, // íƒ„ì•½ íšŒë³µ
                    { type: 'speed', effect: 2, color: '#8b5cf6', emoji: 'ğŸš€' }, // ì´ë™ ì†ë„ ì¦ê°€
                    { type: 'shield', effect: 50, color: '#3b82f6', emoji: 'ğŸ›¡ï¸' }, // ìµœëŒ€ ì²´ë ¥ ì¦ê°€
                    { type: 'damage', effect: 10, color: '#dc2626', emoji: 'âš”ï¸' }, // ê³µê²©ë ¥ ì¦ê°€
                    { type: 'multishot', effect: 3, color: '#7c3aed', emoji: 'ğŸ’¥' }, // ë‹¤ì¤‘ ë°œì‚¬
                    { type: 'megahealth', effect: 100, color: '#059669', emoji: 'ğŸ’š' }, // ëŒ€ëŸ‰ ì²´ë ¥ íšŒë³µ
                    { type: 'rapid', effect: 5, color: '#ea580c', emoji: 'âš¡' }, // ì—°ë°œ ëª¨ë“œ
                    { type: 'invincibility', effect: 5000, color: '#ffd700', emoji: 'âœ¨' }, // ë¬´ì  (5ì´ˆ)
                    { type: 'grenade', effect: 1, color: '#6b7280', emoji: 'ğŸ’£' }, // ìˆ˜ë¥˜íƒ„
                    { type: 'shield_boost', effect: 0.5, duration: 10000, color: '#87ceeb', emoji: 'ğŸ”µ' }, // ì‰´ë“œ ê°•í™” (10ì´ˆ, 50% í”¼í•´ ê°ì†Œ)
                    { type: 'time_slow', effect: 0.5, duration: 5000, color: '#800080', emoji: 'â³' }, // ì‹œê°„ ë‘”í™” (5ì´ˆ, 50% ëŠë ¤ì§)
                    { type: 'magnet', effect: 200, duration: 8000, color: '#8b4513', emoji: '  ' }, // ìì„ (8ì´ˆ, 200px ë²”ìœ„)
                    { type: 'health_regen', effect: 5, duration: 10000, tickInterval: 500, color: '#32cd32', emoji: 'âš•ï¸' }, // ì²´ë ¥ ì¬ìƒ (10ì´ˆ, 0.5ì´ˆë§ˆë‹¤ 5íšŒë³µ)
                    { type: 'ally_summon', effect: 1, color: '#90ee90', emoji: 'ğŸ¤–' }, // ì•„êµ° ì†Œí™˜ ì•„ì´í…œ
                    { type: 'orbiting_knife', effect: 1, color: '#c0c0c0', emoji: 'ğŸ”ª' }, // íšŒì „ ì¹¼ë‚  ì•„ì´í…œ
                    { type: 'piercing_shot', effect: 1, color: '#800080', emoji: 'âœ¨' }, // ê´€í†µ ì‚¬ê²© ì•„ì´í…œ
                    { type: 'explosive_shot', effect: 1, color: '#ff4500', emoji: 'ğŸ’¥' }, // í­ë°œ ì‚¬ê²© ì•„ì´í…œ
                    { type: 'ricochet_shot', effect: 1, color: '#00ced1', emoji: 'â†©ï¸' }, // ë„íƒ„ ì‚¬ê²©
                    { type: 'homing_shot', effect: 1, color: '#ff1493', emoji: 'ğŸ§­' }, // ìœ ë„ ì‚¬ê²©
                    { type: 'split_shot', effect: 1, color: '#9932cc', emoji: 'â•' }, // ë¶„ì—´ ì‚¬ê²©
                    { type: 'time_stop', effect: 3000, color: '#4b0082', emoji: 'ğŸ›‘' }, // ì‹œê°„ ì •ì§€ (3ì´ˆ)
                    { type: 'ammo_regen', effect: 10, duration: 5000, tickInterval: 200, color: '#ffd700', emoji: 'ğŸŸ¡' } // íƒ„ì•½ ì¬ìƒ (5ì´ˆ, 0.2ì´ˆë§ˆë‹¤ 10íšŒë³µ)
                ];
                
                // ì  íƒ€ì… ì •ì˜ (ìƒˆë¡œìš´ ì  ì¶”ê°€ë¨)
                this.ENEMY_TYPES = {
                    boss: {
                        name: 'ê¸€ë˜ìŠ¤ ë³´ìŠ¤',
                        health: 800,
                        speed: 2.5,
                        damage: 40,
                        color: '#ff007f',
                        size: 90,
                        shootInterval: 900,
                        points: 3000,
                        missileCooldown: 3000, lastMissile: 0, // ë¯¸ì‚¬ì¼ ë‚œì‚¬
                        teleportCooldown: 6000, lastTeleport: 0, // ìˆœê°„ì´ë™
                        explosionCooldown: 7000, lastExplosion: 0, // ê´‘ì—­ í­ë°œ
                        summonCooldown: 9000, lastSummon: 0, // ì†Œí™˜
                        shieldCooldown: 12000, lastShield: 0, shieldDuration: 3000, isInvincible: false, invincibleEndTime: 0, // ì‰´ë“œ
                        blackholeCooldown: 15000, lastBlackhole: 0, // ë¸”ë™í™€
                        description: 'ëª¨ë“  ë³´ìŠ¤ ëŠ¥ë ¥ì„ ê°€ì§„ ê¶ê·¹ì˜ ë³´ìŠ¤. ì›¨ì´ë¸Œê°€ ì˜¤ë¥¼ìˆ˜ë¡ ë”ìš± ê°•í•´ì§„ë‹¤.',
                        dexInfo: {
                            category: 'ë³´ìŠ¤',
                            difficulty: 'â˜…â˜…â˜…â˜…â˜…',
                            abilities: ['ë¯¸ì‚¬ì¼ ë‚œì‚¬', 'ìˆœê°„ì´ë™', 'ê´‘ì—­ í­ë°œ', 'ì†Œí™˜', 'ì‰´ë“œ', 'ë¸”ë™í™€'],
                            strategy: 'ëª¨ë“  ëŠ¥ë ¥ì„ ê°€ì§„ ìµœì¢… ë³´ìŠ¤. ì²´ë ¥ì´ ë†’ê³  ë‹¤ì–‘í•œ ê³µê²© íŒ¨í„´ì„ ì‚¬ìš©í•©ë‹ˆë‹¤. ì‰´ë“œ ìƒíƒœì¼ ë•ŒëŠ” ë¬´ì ì´ë¯€ë¡œ ê¸°ë‹¤ë ¤ì•¼ í•©ë‹ˆë‹¤.',
                            weakness: 'ì‰´ë“œê°€ ëë‚œ í›„ ì§‘ì¤‘ ê³µê²©'
                        }
                    },
                    basic: {
                        name: 'ê¸°ë³¸ ì ', 
                        health: 40, 
                        speed: 2, 
                        damage: 15, 
                        color: '#ef4444', 
                        size: 35, 
                        shootInterval: 2000, 
                        points: 100,
                        description: 'ê°€ì¥ ê¸°ë³¸ì ì¸ ì . íŠ¹ë³„í•œ ëŠ¥ë ¥ì€ ì—†ì§€ë§Œ ê· í˜•ì¡íŒ ìŠ¤íƒ¯ì„ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤.',
                        dexInfo: {
                            category: 'ì¼ë°˜',
                            difficulty: 'â˜…â˜†â˜†â˜†â˜†',
                            abilities: ['ê¸°ë³¸ ë°œì‚¬'],
                            strategy: 'ê°€ì¥ ê¸°ë³¸ì ì¸ ì ìœ¼ë¡œ, íŠ¹ë³„í•œ íŒ¨í„´ ì—†ì´ ë‹¨ìˆœíˆ í”Œë ˆì´ì–´ë¥¼ í–¥í•´ ë°œì‚¬í•©ë‹ˆë‹¤.',
                            weakness: 'ì²´ë ¥ì´ ë‚®ì•„ ë¹ ë¥´ê²Œ ì²˜ì¹˜ ê°€ëŠ¥'
                        }
                    },
                    fast: {
                        name: 'ë¹ ë¥¸ ì ', 
                        health: 25, 
                        speed: 4, 
                        damage: 12, 
                        color: '#f97316', 
                        size: 30, 
                        shootInterval: 1500, 
                        points: 150,
                        description: 'ë¹ ë¥¸ ì†ë„ë¡œ ì›€ì§ì´ë©° ìì£¼ ë°œì‚¬í•˜ëŠ” ì . ì²´ë ¥ì€ ë‚®ì§€ë§Œ íšŒí”¼í•˜ê¸° ì–´ë ¤ìš¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
                        dexInfo: {
                            category: 'ì¼ë°˜',
                            difficulty: 'â˜…â˜…â˜†â˜†â˜†',
                            abilities: ['ë¹ ë¥¸ ì´ë™', 'ë¹ ë¥¸ ë°œì‚¬'],
                            strategy: 'ì†ë„ê°€ ë¹ ë¥´ê³  ë°œì‚¬ ê°„ê²©ì´ ì§§ì•„ íšŒí”¼í•˜ê¸° ì–´ë µìŠµë‹ˆë‹¤. ìš°ì„  ì²˜ì¹˜í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.',
                            weakness: 'ì²´ë ¥ì´ ë§¤ìš° ë‚®ì•„ í•œ ë²ˆì˜ ê³µê²©ìœ¼ë¡œ ì²˜ì¹˜ ê°€ëŠ¥'
                        }
                    },
                    tank: {
                        name: 'íƒ±í¬ ì ', 
                        health: 80, 
                        speed: 1, 
                        damage: 25, 
                        color: '#7c3aed', 
                        size: 45, 
                        shootInterval: 3000, 
                        points: 250,
                        description: 'ë†’ì€ ì²´ë ¥ê³¼ ê³µê²©ë ¥ì„ ê°€ì§„ ì¤‘ì¥ê°‘ ì . ëŠë¦¬ì§€ë§Œ ê°•ë ¥í•œ ê³µê²©ì„ í•©ë‹ˆë‹¤.',
                        dexInfo: {
                            category: 'ì¼ë°˜',
                            difficulty: 'â˜…â˜…â˜…â˜†â˜†',
                            abilities: ['ë†’ì€ ì²´ë ¥', 'ê°•ë ¥í•œ ê³µê²©'],
                            strategy: 'ì²´ë ¥ì´ ë†’ê³  ê³µê²©ë ¥ì´ ê°•í•˜ì§€ë§Œ ì†ë„ê°€ ëŠë¦½ë‹ˆë‹¤. ê±°ë¦¬ë¥¼ ë‘ê³  ê³µê²©í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.',
                            weakness: 'ì†ë„ê°€ ë§¤ìš° ëŠë ¤ íšŒí”¼í•˜ê¸° ì‰¬ì›€'
                        }
                    },
                    sniper: {
                        name: 'ì €ê²©ìˆ˜', 
                        health: 30, 
                        speed: 1.5, 
                        damage: 30, 
                        color: '#06b6d4', 
                        size: 32, 
                        shootInterval: 4000, 
                        points: 200,
                        description: 'ë†’ì€ ê³µê²©ë ¥ê³¼ ê¸´ ì‚¬ê±°ë¦¬ë¥¼ ê°€ì§„ ì €ê²© ì . ë°œì‚¬ ê°„ê²©ì´ ê¸¸ì§€ë§Œ í•œ ë²ˆ ë§ìœ¼ë©´ í° í”¼í•´ë¥¼ ì…ìŠµë‹ˆë‹¤.',
                        dexInfo: {
                            category: 'ì¼ë°˜',
                            difficulty: 'â˜…â˜…â˜†â˜†â˜†',
                            abilities: ['ë†’ì€ ê³µê²©ë ¥', 'ê¸´ ì‚¬ê±°ë¦¬'],
                            strategy: 'ê³µê²©ë ¥ì´ ë†’ì§€ë§Œ ë°œì‚¬ ê°„ê²©ì´ ê¸¸ì–´ ì˜ˆì¸¡í•˜ê¸° ì‰½ìŠµë‹ˆë‹¤. ë°œì‚¬ íƒ€ì´ë°ì„ ë…¸ë ¤ ê³µê²©í•˜ì„¸ìš”.',
                            weakness: 'ì²´ë ¥ì´ ë‚®ê³  ë°œì‚¬ ê°„ê²©ì´ ê¸¸ì–´ íšŒí”¼í•˜ê¸° ì‰¬ì›€'
                        }
                    },
                    bomber: {
                        name: 'í­ê²©ë³‘', 
                        health: 45, 
                        speed: 1.5, 
                        damage: 30, 
                        color: '#b91c1c', 
                        size: 38, 
                        shootInterval: 3000, 
                        points: 220,
                        description: 'ê°•ë ¥í•œ í­ë°œ ê³µê²©ì„ í•˜ëŠ” ì . ì²´ë ¥ì€ ë³´í†µì´ì§€ë§Œ ê³µê²©ë ¥ì´ ë†’ìŠµë‹ˆë‹¤.',
                        dexInfo: {
                            category: 'ì¼ë°˜',
                            difficulty: 'â˜…â˜…â˜…â˜†â˜†',
                            abilities: ['í­ë°œ ê³µê²©', 'ë†’ì€ ê³µê²©ë ¥'],
                            strategy: 'ê³µê²©ë ¥ì´ ë†’ì•„ ì£¼ì˜ê°€ í•„ìš”í•©ë‹ˆë‹¤. ìš°ì„  ì²˜ì¹˜í•˜ê±°ë‚˜ ê±°ë¦¬ë¥¼ ë‘ê³  ì‹¸ìš°ì„¸ìš”.',
                            weakness: 'ì²´ë ¥ì´ ë³´í†µì´ê³  ì†ë„ê°€ ëŠë¦¼'
                        }
                    },
                    guardian: {
                        name: 'ìˆ˜í˜¸ì', 
                        health: 200, 
                        speed: 1.2, 
                        damage: 45, 
                        color: '#1e40af', 
                        size: 55, 
                        shootInterval: 1800, 
                        points: 400,
                        description: 'ë§¤ìš° ë†’ì€ ì²´ë ¥ê³¼ ê°•ë ¥í•œ ê³µê²©ë ¥ì„ ê°€ì§„ ì •ì˜ˆ ì . ì²˜ì¹˜í•˜ê¸° ì–´ë µì§€ë§Œ ë†’ì€ ì ìˆ˜ë¥¼ ì œê³µí•©ë‹ˆë‹¤.',
                        dexInfo: {
                            category: 'ì •ì˜ˆ',
                            difficulty: 'â˜…â˜…â˜…â˜…â˜†',
                            abilities: ['ë§¤ìš° ë†’ì€ ì²´ë ¥', 'ê°•ë ¥í•œ ê³µê²©', 'ë¹ ë¥¸ ë°œì‚¬'],
                            strategy: 'ì²´ë ¥ì´ ë§¤ìš° ë†’ê³  ê³µê²©ë ¥ë„ ê°•í•©ë‹ˆë‹¤. ìš°ì„ ìˆœìœ„ë¥¼ ë‘ê³  ì§‘ì¤‘ ê³µê²©í•˜ê±°ë‚˜, ë‹¤ë¥¸ ì ë“¤ì„ ë¨¼ì € ì²˜ì¹˜í•œ í›„ ìƒëŒ€í•˜ì„¸ìš”.',
                            weakness: 'ì†ë„ê°€ ëŠë ¤ íšŒí”¼í•˜ê¸° ì‰¬ì›€'
                        }
                    },
                    assassin: {
                        name: 'ì•”ì‚´ì', 
                        health: 35, 
                        speed: 5, 
                        damage: 20, 
                        color: '#6b21a8', 
                        size: 28, 
                        shootInterval: 1200, 
                        points: 180,
                        description: 'ë§¤ìš° ë¹ ë¥¸ ì†ë„ë¡œ ì›€ì§ì´ë©° ìì£¼ ê³µê²©í•˜ëŠ” ì . ì²´ë ¥ì€ ë‚®ì§€ë§Œ íšŒí”¼í•˜ê¸° ë§¤ìš° ì–´ë µìŠµë‹ˆë‹¤.',
                        dexInfo: {
                            category: 'ì¼ë°˜',
                            difficulty: 'â˜…â˜…â˜…â˜…â˜†',
                            abilities: ['ë§¤ìš° ë¹ ë¥¸ ì´ë™', 'ë¹ ë¥¸ ë°œì‚¬'],
                            strategy: 'ì†ë„ê°€ ë§¤ìš° ë¹ ë¥´ê³  ë°œì‚¬ ê°„ê²©ì´ ì§§ì•„ ê°€ì¥ ìœ„í—˜í•œ ì  ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤. ìš°ì„  ì²˜ì¹˜í•˜ëŠ” ê²ƒì´ í•„ìˆ˜ì…ë‹ˆë‹¤.',
                            weakness: 'ì²´ë ¥ì´ ë§¤ìš° ë‚®ì•„ í•œ ë²ˆì˜ ê³µê²©ìœ¼ë¡œ ì²˜ì¹˜ ê°€ëŠ¥'
                        }
                    },
                    heavy: {
                        name: 'ì¤‘ì¥ë³‘', 
                        health: 100, 
                        speed: 0.8, 
                        damage: 40, 
                        color: '#92400e', 
                        size: 50, 
                        shootInterval: 2500, 
                        points: 300,
                        description: 'ë†’ì€ ì²´ë ¥ê³¼ ê°•ë ¥í•œ ê³µê²©ë ¥ì„ ê°€ì§„ ì¤‘ì¥ê°‘ ì . ë§¤ìš° ëŠë¦¬ì§€ë§Œ í•œ ë²ˆ ë§ìœ¼ë©´ í° í”¼í•´ë¥¼ ì…ìŠµë‹ˆë‹¤.',
                        dexInfo: {
                            category: 'ì¼ë°˜',
                            difficulty: 'â˜…â˜…â˜…â˜†â˜†',
                            abilities: ['ë†’ì€ ì²´ë ¥', 'ê°•ë ¥í•œ ê³µê²©'],
                            strategy: 'ì²´ë ¥ì´ ë†’ê³  ê³µê²©ë ¥ì´ ê°•í•˜ì§€ë§Œ ì†ë„ê°€ ë§¤ìš° ëŠë¦½ë‹ˆë‹¤. ê±°ë¦¬ë¥¼ ë‘ê³  ì•ˆì „í•˜ê²Œ ê³µê²©í•˜ì„¸ìš”.',
                            weakness: 'ì†ë„ê°€ ë§¤ìš° ëŠë ¤ íšŒí”¼í•˜ê¸° ë§¤ìš° ì‰¬ì›€'
                        }
                    },
                    ghost: {
                        name: 'ìœ ë ¹', 
                        health: 20, 
                        speed: 6, 
                        damage: 10, 
                        color: '#a8a29e', 
                        size: 25, 
                        shootInterval: 2500, 
                        points: 200, 
                        isInvincible: false, 
                        invincibilityDuration: 1000, // ìœ ë ¹ ì „ìš© ì†ì„±
                        description: 'ì¼ì‹œì ìœ¼ë¡œ ë¬´ì ì´ ë˜ëŠ” ëŠ¥ë ¥ì„ ê°€ì§„ ë¹ ë¥¸ ì .',
                        dexInfo: {
                            category: 'íŠ¹ìˆ˜',
                            difficulty: 'â˜…â˜…â˜†â˜†â˜†',
                            abilities: ['ì¼ì‹œ ë¬´ì ', 'ë¹ ë¥¸ ì´ë™'],
                            strategy: 'ë¬´ì  ìƒíƒœì¼ ë•ŒëŠ” ê³µê²©ì´ í†µí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë¬´ì ì´ ëë‚  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¬ê±°ë‚˜ ë‹¤ë¥¸ ì ì„ ê³µê²©í•˜ì„¸ìš”.',
                            weakness: 'ì²´ë ¥ì´ ë§¤ìš° ë‚®ì•„ í•œ ë²ˆì˜ ê³µê²©ìœ¼ë¡œ ì²˜ì¹˜ ê°€ëŠ¥'
                        }
                    },
                    medic: {
                        name: 'ì¹˜ìœ ì‚¬', 
                        health: 50, 
                        speed: 1.5, 
                        damage: 0, 
                        color: '#10b981', 
                        size: 30, 
                        shootInterval: 5000, 
                        points: 300, 
                        healAmount: 20, 
                        healRadius: 150,
                        description: 'ë‹¤ë¥¸ ì ë“¤ì„ ì¹˜ë£Œí•˜ëŠ” ëŠ¥ë ¥ì„ ê°€ì§„ ì . ì§ì ‘ ê³µê²©ë ¥ì€ ì—†ì§€ë§Œ ë‹¤ë¥¸ ì ë“¤ì„ ê°•í™”ì‹œí‚µë‹ˆë‹¤.',
                        dexInfo: {
                            category: 'ì§€ì›',
                            difficulty: 'â˜…â˜…â˜†â˜†â˜†',
                            abilities: ['ì  ì¹˜ë£Œ', 'ì§€ì†ì ì¸ ìœ„í˜‘'],
                            strategy: 'ì¹˜ìœ ì‚¬ê°€ ì‚´ì•„ìˆìœ¼ë©´ ë‹¤ë¥¸ ì ë“¤ì´ ê³„ì† íšŒë³µë©ë‹ˆë‹¤. ìš°ì„  ì²˜ì¹˜í•˜ëŠ” ê²ƒì´ í•„ìˆ˜ì…ë‹ˆë‹¤.',
                            weakness: 'ì§ì ‘ ê³µê²©ë ¥ì´ ì—†ê³  ì²´ë ¥ì´ ë³´í†µì„'
                        }
                    },
                    summoner: {
                        name: 'ì†Œí™˜ì‚¬', 
                        health: 70, 
                        speed: 1, 
                        damage: 5, 
                        color: '#9333ea', 
                        size: 40, 
                        shootInterval: 8000, 
                        points: 400, 
                        summonCount: 1, 
                        summonType: 'basic',
                        description: 'ë‹¤ë¥¸ ì ë“¤ì„ ì†Œí™˜í•˜ëŠ” ëŠ¥ë ¥ì„ ê°€ì§„ ì . ì§ì ‘ ê³µê²©ë ¥ì€ ë‚®ì§€ë§Œ ì†Œí™˜ëœ ì ë“¤ì´ ìœ„í—˜í•©ë‹ˆë‹¤.',
                        dexInfo: {
                            category: 'íŠ¹ìˆ˜',
                            difficulty: 'â˜…â˜…â˜…â˜†â˜†',
                            abilities: ['ì  ì†Œí™˜', 'ì§€ì†ì ì¸ ìœ„í˜‘'],
                            strategy: 'ì†Œí™˜ì‚¬ê°€ ì‚´ì•„ìˆìœ¼ë©´ ê³„ì†í•´ì„œ ì ì„ ì†Œí™˜í•©ë‹ˆë‹¤. ìš°ì„  ì²˜ì¹˜í•˜ëŠ” ê²ƒì´ í•„ìˆ˜ì…ë‹ˆë‹¤.',
                            weakness: 'ì§ì ‘ ê³µê²©ë ¥ì´ ë§¤ìš° ë‚®ìŒ'
                        }
                    },
                    jumper: {
                        name: 'ì í¼', 
                        health: 30, 
                        speed: 3, 
                        damage: 18, 
                        color: '#facc15', 
                        size: 35, 
                        shootInterval: 2000, 
                        points: 120, 
                        jumpCooldown: 2000, 
                        lastJump: 0,
                        description: 'ì í”„ ëŠ¥ë ¥ì„ ê°€ì§„ ì . ê°‘ìê¸° ì í”„í•˜ì—¬ ì˜ˆìƒì¹˜ ëª»í•œ ìœ„ì¹˜ì—ì„œ ê³µê²©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
                        dexInfo: {
                            category: 'íŠ¹ìˆ˜',
                            difficulty: 'â˜…â˜…â˜†â˜†â˜†',
                            abilities: ['ì í”„', 'ì˜ˆì¸¡ ë¶ˆê°€ëŠ¥í•œ ì´ë™'],
                            strategy: 'ì í”„ë¡œ ê°‘ìê¸° ìœ„ì¹˜ë¥¼ ë°”ê¿€ ìˆ˜ ìˆì–´ íšŒí”¼í•˜ê¸° ì–´ë ¤ìš¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì í”„ íŒ¨í„´ì„ íŒŒì•…í•˜ì„¸ìš”.',
                            weakness: 'ì²´ë ¥ì´ ë‚®ê³  ì í”„ í›„ ê³µê²©ê¹Œì§€ ì‹œê°„ì´ í•„ìš”'
                        }
                    },
                    shielded: {
                        name: 'ë°©íŒ¨ë³‘', 
                        health: 120, 
                        speed: 0.7, 
                        damage: 20, 
                        color: '#6b7280', 
                        size: 45, 
                        shootInterval: 2800, 
                        points: 280, 
                        shieldAngle: Math.PI / 3,
                        description: 'ë°©íŒ¨ë¥¼ ê°€ì§„ ì . íŠ¹ì • ë°©í–¥ì—ì„œì˜ ê³µê²©ì„ ë§‰ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
                        dexInfo: {
                            category: 'íŠ¹ìˆ˜',
                            difficulty: 'â˜…â˜…â˜…â˜†â˜†',
                            abilities: ['ë°©íŒ¨', 'ê³µê²© ë°©ì–´'],
                            strategy: 'ë°©íŒ¨ë¡œ íŠ¹ì • ë°©í–¥ì˜ ê³µê²©ì„ ë§‰ìŠµë‹ˆë‹¤. ë°©íŒ¨ê°€ ì—†ëŠ” ë°©í–¥ì—ì„œ ê³µê²©í•˜ì„¸ìš”.',
                            weakness: 'ì†ë„ê°€ ë§¤ìš° ëŠë¦¬ê³  ë°©íŒ¨ê°€ ëª¨ë“  ë°©í–¥ì„ ë§‰ì§€ ëª»í•¨'
                        }
                    },
                    teleporter: {
                        name: 'ìˆœê°„ì´ë™ë³‘', 
                        health: 35, 
                        speed: 1, 
                        damage: 25, 
                        color: '#a78bfa', 
                        size: 30, 
                        shootInterval: 3500, 
                        points: 220, 
                        teleportCooldown: 4000, 
                        lastTeleport: 0, // ìˆœê°„ì´ë™ë³‘ ì „ìš© ì†ì„±
                        description: 'ìˆœê°„ì´ë™ ëŠ¥ë ¥ì„ ê°€ì§„ ì . ê°‘ìê¸° ì‚¬ë¼ì¡Œë‹¤ê°€ ë‹¤ë¥¸ ìœ„ì¹˜ì—ì„œ ë‚˜íƒ€ë‚©ë‹ˆë‹¤.',
                        dexInfo: {
                            category: 'íŠ¹ìˆ˜',
                            difficulty: 'â˜…â˜…â˜…â˜†â˜†',
                            abilities: ['ìˆœê°„ì´ë™', 'ì˜ˆì¸¡ ë¶ˆê°€ëŠ¥í•œ ìœ„ì¹˜'],
                            strategy: 'ìˆœê°„ì´ë™ìœ¼ë¡œ ê°‘ìê¸° ìœ„ì¹˜ë¥¼ ë°”ê¿€ ìˆ˜ ìˆì–´ íšŒí”¼í•˜ê¸° ì–´ë ¤ìš¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ìˆœê°„ì´ë™ í›„ ê³µê²©ê¹Œì§€ ì‹œê°„ì´ í•„ìš”í•˜ë‹ˆ ê·¸ íƒ€ì´ë°ì„ ë…¸ë¦¬ì„¸ìš”.',
                            weakness: 'ìˆœê°„ì´ë™ í›„ ê³µê²©ê¹Œì§€ ì‹œê°„ì´ í•„ìš”í•˜ê³  ì²´ë ¥ì´ ë³´í†µì„'
                        }
                    },
                    drone: {
                        name: 'ë“œë¡ ', 
                        health: 20, 
                        speed: 7, 
                        damage: 10, 
                        color: '#94a3b8', 
                        size: 20, 
                        shootInterval: 1000, 
                        points: 80, 
                        flies: true, // ë“œë¡  ì „ìš© ì†ì„±
                        description: 'ë§¤ìš° ë¹ ë¥¸ ì†ë„ë¡œ ì›€ì§ì´ëŠ” ì†Œí˜• ì . ê³µê²©ë ¥ì€ ë‚®ì§€ë§Œ ë¹ ë¥¸ ì†ë„ë¡œ ìœ„í˜‘ì ì…ë‹ˆë‹¤.',
                        dexInfo: {
                            category: 'ê¸°ë³¸',
                            difficulty: 'â˜…â˜…â˜†â˜†â˜†',
                            abilities: ['ë¹ ë¥¸ ì´ë™', 'ë¹ ë¥¸ ê³µê²©'],
                            strategy: 'ë§¤ìš° ë¹ ë¥¸ ì†ë„ë¡œ ì›€ì§ì´ë¯€ë¡œ ì˜ˆì¸¡í•˜ê¸° ì–´ë µìŠµë‹ˆë‹¤. ë¹ ë¥¸ ë°˜ì‘ìœ¼ë¡œ íšŒí”¼í•˜ì„¸ìš”.',
                            weakness: 'ì²´ë ¥ì´ ë§¤ìš° ë‚®ì•„ í•œ ë²ˆì˜ ê³µê²©ìœ¼ë¡œ ì²˜ì¹˜ ê°€ëŠ¥'
                        }
                    },
                    spitter: {
                        name: 'ìŠ¬ë¼ì„ë³‘', 
                        health: 50, 
                        speed: 1.3, 
                        damage: 15, 
                        color: '#16a34a', 
                        size: 35, 
                        shootInterval: 2500, 
                        points: 180, 
                        slowEffect: 0.5, 
                        slowDuration: 3000, // ìŠ¬ë¼ì„ë³‘ ì „ìš© ì†ì„±
                        description: 'í”Œë ˆì´ì–´ë¥¼ ë‘”í™”ì‹œí‚¤ëŠ” ëŠ¥ë ¥ì„ ê°€ì§„ ì . ë§ìœ¼ë©´ ì¼ì • ì‹œê°„ ë™ì•ˆ ì†ë„ê°€ ëŠë ¤ì§‘ë‹ˆë‹¤.',
                        dexInfo: {
                            category: 'íŠ¹ìˆ˜',
                            difficulty: 'â˜…â˜…â˜†â˜†â˜†',
                            abilities: ['í”Œë ˆì´ì–´ ë‘”í™”', 'ì§€ì†ì ì¸ ìœ„í˜‘'],
                            strategy: 'ë‘”í™” íš¨ê³¼ë¡œ ì¸í•´ ë‹¤ë¥¸ ì ë“¤ì˜ ê³µê²©ì„ í”¼í•˜ê¸° ì–´ë ¤ì›Œì§‘ë‹ˆë‹¤. ìš°ì„  ì²˜ì¹˜í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.',
                            weakness: 'ì†ë„ê°€ ëŠë¦¬ê³  ì²´ë ¥ì´ ë³´í†µì„'
                        }
                    },
                    berserker: {
                        name: 'ê´‘ì „ì‚¬', 
                        health: 60, 
                        speed: 3, 
                        damage: 20, 
                        color: '#be123c', 
                        size: 38, 
                        shootInterval: 1800, 
                        points: 250, 
                        rageThreshold: 0.3, 
                        rageSpeedBoost: 1.5, 
                        rageDamageBoost: 1.5, 
                        isRaging: false, // ê´‘ì „ì‚¬ ì „ìš© ì†ì„±
                        description: 'ì²´ë ¥ì´ ë‚®ì•„ì§€ë©´ ê´‘ë¶„ ìƒíƒœê°€ ë˜ì–´ ì†ë„ì™€ ê³µê²©ë ¥ì´ ì¦ê°€í•˜ëŠ” ì .',
                        dexInfo: {
                            category: 'íŠ¹ìˆ˜',
                            difficulty: 'â˜…â˜…â˜…â˜†â˜†',
                            abilities: ['ê´‘ë¶„ ìƒíƒœ', 'ëŠ¥ë ¥ì¹˜ ì¦ê°€'],
                            strategy: 'ì²´ë ¥ì´ 30% ì´í•˜ë¡œ ë–¨ì–´ì§€ë©´ ê´‘ë¶„ ìƒíƒœê°€ ë˜ì–´ ìœ„í—˜í•´ì§‘ë‹ˆë‹¤. ê´‘ë¶„ ìƒíƒœ ì „ì— ì²˜ì¹˜í•˜ì„¸ìš”.',
                            weakness: 'ê´‘ë¶„ ìƒíƒœ ì „ì—ëŠ” ì¼ë°˜ì ì¸ ì ê³¼ ë¹„ìŠ·í•¨'
                        }
                    },
                    // ìƒˆë¡œìš´ ë³´ìŠ¤ íƒ€ì…
                    boss_alpha: {
                        name: 'ì•ŒíŒŒ ë³´ìŠ¤', health: 200, speed: 2, damage: 25, color: '#ff007f', size: 65, shootInterval: 1800, points: 700,
                        summonCooldown: 10000, lastSummon: 0, summonCount: 2, summonType: 'basic',
                        // ìŠ¤í‚¬1: ë¯¸ë‹ˆì–¸ ì†Œí™˜
                        dashCooldown: 7000, lastDash: 0, dashCount: 3, dashDuration: 300, isDashing: false,
                        // ìŠ¤í‚¬2: ì—°ì† ëŒì§„
                        shockwaveCooldown: 12000, lastShockwave: 0,
                        description: 'ë¯¸ë‹ˆì–¸ ì†Œí™˜, ì—°ì† ëŒì§„, ê´‘ì—­ ì¶©ê²©íŒŒ'
                    },
                    boss_beta: {
                        name: 'ë² íƒ€ ë³´ìŠ¤', health: 300, speed: 1.5, damage: 20, color: '#00ffff', size: 70, shootInterval: 2500, points: 800,
                        // ìŠ¤í‚¬1: ì‰´ë“œ(ë¬´ì )
                        shieldCooldown: 10000, lastShield: 0, shieldDuration: 3000, isInvincible: false, invincibleEndTime: 0,
                        // ìŠ¤í‚¬2: íƒ„ë§‰ ë°œì‚¬
                        barrageCooldown: 8000, lastBarrage: 0,
                        // ìŠ¤í‚¬3: ì²´ë ¥ íšŒë³µ
                        healCooldown: 14000, lastHeal: 0, healAmount: 60,
                        description: 'ì‰´ë“œ, íƒ„ë§‰, ì²´ë ¥ íšŒë³µ'
                    },
                    boss_gamma: {
                        name: 'ê°ë§ˆ ë³´ìŠ¤', health: 180, speed: 3.5, damage: 35, color: '#ff8c00', size: 60, shootInterval: 1000, points: 900,
                        // ìŠ¤í‚¬1: ìˆœê°„ì´ë™
                        teleportCooldown: 6000, lastTeleport: 0, teleportRange: 200,
                        // ìŠ¤í‚¬2: ë ˆì´ì €
                        laserCooldown: 9000, lastLaser: 0, laserDuration: 1200,
                        // ìŠ¤í‚¬3: ì†ë„ ë²„í”„
                        speedBuffCooldown: 12000, lastSpeedBuff: 0, speedBuffDuration: 3000, isSpeedBuffed: false,
                        description: 'ìˆœê°„ì´ë™, ë ˆì´ì €, ì†ë„ ë²„í”„'
                    },
                    boss_delta: {
                        name: 'ë¸íƒ€ ë³´ìŠ¤', health: 350, speed: 1.7, damage: 30, color: '#22223b', size: 80, shootInterval: 2000, points: 1200,
                        // ìŠ¤í‚¬1: ë¸”ë™í™€
                        blackholeCooldown: 9000, lastBlackhole: 0, blackholeRadius: 180,
                        // ìŠ¤í‚¬2: ê´‘ì—­ í­ë°œ
                        explosionCooldown: 11000, lastExplosion: 0,
                        // ìŠ¤í‚¬3: í”Œë ˆì´ì–´ ë‘”í™”
                        slowCooldown: 13000, lastSlow: 0, slowDuration: 3000,
                        description: 'ë¸”ë™í™€, ê´‘ì—­ í­ë°œ, í”Œë ˆì´ì–´ ë‘”í™”'
                    },
                    boss_epsilon: {
                        name: 'ì—¡ì‹¤ë¡  ë³´ìŠ¤', health: 320, speed: 2.2, damage: 22, color: '#fbbf24', size: 75, shootInterval: 1800, points: 1100,
                        // ìŠ¤í‚¬1: ë¶„ì‹  ìƒì„±
                        cloneCooldown: 10000, lastClone: 0, clones: 2, hasCloned: false,
                        // ìŠ¤í‚¬2: íƒ„í™˜ ë°˜ì‚¬
                        reflectCooldown: 9000, lastReflect: 0, reflectDuration: 2000, isReflecting: false,
                        // ìŠ¤í‚¬3: ì²´ë ¥ í¡ìˆ˜
                        drainCooldown: 12000, lastDrain: 0, drainAmount: 40,
                        description: 'ë¶„ì‹ , íƒ„í™˜ ë°˜ì‚¬, ì²´ë ¥ í¡ìˆ˜'
                    },
                    boss_zeta: {
                        name: 'ì œíƒ€ ë³´ìŠ¤', health: 300, speed: 2.5, damage: 28, color: '#06d6a0', size: 78, shootInterval: 1700, points: 1300,
                        // ìŠ¤í‚¬1: ì‹œê°„ ì™œê³¡(ìŠ¬ë¡œìš°)
                        timeWarpCooldown: 8000, lastTimeWarp: 0, timeWarpDuration: 2500, isTimeWarp: false,
                        // ìŠ¤í‚¬2: ì—°ë°œ ì‚¬ê²©
                        rapidFireCooldown: 9000, lastRapidFire: 0, rapidFireDuration: 2000, isRapidFire: false,
                        // ìŠ¤í‚¬3: ëœë¤ ìœ„ì¹˜ ì´ë™
                        randomMoveCooldown: 11000, lastRandomMove: 0,
                        description: 'ì‹œê°„ ì™œê³¡, ì—°ë°œ ì‚¬ê²©, ëœë¤ ì´ë™'
                    },
                    boss_eta: {
                        name: 'ì—íƒ€ ë³´ìŠ¤', health: 400, speed: 1.3, damage: 40, color: '#ff006e', size: 90, shootInterval: 3000, points: 1500,
                        // ìŠ¤í‚¬1: ë ˆì´ì €
                        laserCooldown: 7000, lastLaser: 0, laserDuration: 1200,
                        // ìŠ¤í‚¬2: ì—°ì† ì í”„
                        jumpCooldown: 9000, lastJump: 0, jumpCount: 3, jumpPower: 30,
                        // ìŠ¤í‚¬3: ë°©ì–´ë ¥ ì¦ê°€
                        armorBuffCooldown: 12000, lastArmorBuff: 0, armorBuffDuration: 4000, isArmorBuffed: false,
                        description: 'ë ˆì´ì €, ì—°ì† ì í”„, ë°©ì–´ë ¥ ì¦ê°€'
                    },
                    boss_theta: {
                        name: 'ì„íƒ€ ë³´ìŠ¤', health: 370, speed: 1.8, damage: 26, color: '#3a86ff', size: 85, shootInterval: 2100, points: 1250,
                        // ìŠ¤í‚¬1: ë°œì‚¬ì²´ ë°˜ì‚¬
                        reflectAllCooldown: 10000, lastReflectAll: 0, reflectAllDuration: 2000, isReflecting: false,
                        // ìŠ¤í‚¬2: ë„íƒ„ íƒ„í™˜
                        ricochetCooldown: 9000, lastRicochet: 0, ricochetCount: 5,
                        // ìŠ¤í‚¬3: í”Œë ˆì´ì–´ ìœ„ì¹˜ ì¶”ì 
                        trackCooldown: 11000, lastTrack: 0, trackDuration: 2000, isTracking: false,
                        description: 'ë°œì‚¬ì²´ ë°˜ì‚¬, ë„íƒ„, ìœ„ì¹˜ ì¶”ì '
                    },
                    // === ì‹ ê·œ ì  10ì¢… ===
                    mirror: {
                        name: 'ë¯¸ëŸ¬ ì ', 
                        health: 35, 
                        speed: 2.5, 
                        damage: 15, 
                        color: '#b6e0fe', 
                        size: 32, 
                        shootInterval: 1800, 
                        points: 180, 
                        mirrorPlayer: true, // í”Œë ˆì´ì–´ ì›€ì§ì„ ë”°ë¼í•¨
                        description: 'í”Œë ˆì´ì–´ì˜ ì›€ì§ì„ì„ ë”°ë¼í•˜ëŠ” ëŠ¥ë ¥ì„ ê°€ì§„ ì . ì˜ˆì¸¡í•˜ê¸° ì–´ë ¤ìš´ íŒ¨í„´ì„ ë³´ì…ë‹ˆë‹¤.',
                        dexInfo: {
                            category: 'íŠ¹ìˆ˜',
                            difficulty: 'â˜…â˜…â˜†â˜†â˜†',
                            abilities: ['í”Œë ˆì´ì–´ ëª¨ë°©', 'ì˜ˆì¸¡ ë¶ˆê°€ëŠ¥í•œ ì›€ì§ì„'],
                            strategy: 'í”Œë ˆì´ì–´ì˜ ì›€ì§ì„ì„ ë”°ë¼í•˜ë¯€ë¡œ ì˜ˆì¸¡í•˜ê¸° ì–´ë µìŠµë‹ˆë‹¤. íŒ¨í„´ì„ íŒŒì•…í•˜ì—¬ ëŒ€ì‘í•˜ì„¸ìš”.',
                            weakness: 'ì²´ë ¥ì´ ë‚®ê³  ì§ì ‘ì ì¸ ê³µê²©ë ¥ì€ ë³´í†µì„'
                        }
                    },
                    leech: {
                        name: 'í¡í˜ˆ ì ', 
                        health: 30, 
                        speed: 2, 
                        damage: 10, 
                        color: '#a21caf', 
                        size: 30, 
                        shootInterval: 2000, 
                        points: 160, 
                        leechAmount: 10, // ë‹¿ìœ¼ë©´ ì²´ë ¥ í¡ìˆ˜
                        description: 'í”Œë ˆì´ì–´ì™€ ë‹¿ìœ¼ë©´ ì²´ë ¥ì„ í¡ìˆ˜í•˜ëŠ” ëŠ¥ë ¥ì„ ê°€ì§„ ì .',
                        dexInfo: {
                            category: 'íŠ¹ìˆ˜',
                            difficulty: 'â˜…â˜…â˜†â˜†â˜†',
                            abilities: ['ì²´ë ¥ í¡ìˆ˜', 'ì ‘ì´‰ ê³µê²©'],
                            strategy: 'ë‹¿ìœ¼ë©´ ì²´ë ¥ì„ í¡ìˆ˜í•˜ë¯€ë¡œ ì ‘ì´‰ì„ í”¼í•´ì•¼ í•©ë‹ˆë‹¤. ì›ê±°ë¦¬ì—ì„œ ê³µê²©í•˜ì„¸ìš”.',
                            weakness: 'ì²´ë ¥ì´ ë‚®ê³  ê³µê²©ë ¥ì´ ë‚®ìŒ'
                        }
                    },
                    mine: {
                        name: 'ì§€ë¢° ì ', 
                        health: 20, 
                        speed: 1, 
                        damage: 40, 
                        color: '#fbbf24', 
                        size: 28, 
                        shootInterval: 99999, 
                        points: 120, 
                        explodesOnNear: true, 
                        explodeRadius: 60, // ê·¼ì ‘ í­ë°œ
                        description: 'í”Œë ˆì´ì–´ê°€ ê°€ê¹Œì´ ì˜¤ë©´ í­ë°œí•˜ëŠ” ì§€ë¢°í˜• ì .',
                        dexInfo: {
                            category: 'íŠ¹ìˆ˜',
                            difficulty: 'â˜…â˜…â˜†â˜†â˜†',
                            abilities: ['ê·¼ì ‘ í­ë°œ', 'ë†’ì€ í­ë°œ ë°ë¯¸ì§€'],
                            strategy: 'ê°€ê¹Œì´ ê°€ë©´ í­ë°œí•˜ë¯€ë¡œ ì›ê±°ë¦¬ì—ì„œ ê³µê²©í•˜ì„¸ìš”. í­ë°œ ë°˜ê²½ì„ ê³ ë ¤í•˜ì—¬ ê±°ë¦¬ë¥¼ ìœ ì§€í•˜ì„¸ìš”.',
                            weakness: 'ì²´ë ¥ì´ ë§¤ìš° ë‚®ê³  ì§ì ‘ ê³µê²©ë ¥ì´ ì—†ìŒ'
                        }
                    },
                    freezer: {
                        name: 'ë¹™ê²° ì ', 
                        health: 28, 
                        speed: 1.7, 
                        damage: 12, 
                        color: '#38bdf8', 
                        size: 30, 
                        shootInterval: 2200, 
                        points: 150, 
                        freezeOnHit: true, 
                        freezeDuration: 2000, // ë§ìœ¼ë©´ ë¹™ê²°
                        description: 'í”Œë ˆì´ì–´ë¥¼ ë§ì¶”ë©´ ë¹™ê²°ì‹œí‚¤ëŠ” ëŠ¥ë ¥ì„ ê°€ì§„ ì .',
                        dexInfo: {
                            category: 'íŠ¹ìˆ˜',
                            difficulty: 'â˜…â˜…â˜†â˜†â˜†',
                            abilities: ['í”Œë ˆì´ì–´ ë¹™ê²°', 'ì´ë™ ì œí•œ'],
                            strategy: 'ë§ìœ¼ë©´ ë¹™ê²°ë˜ì–´ ì›€ì§ì¼ ìˆ˜ ì—†ê²Œ ë©ë‹ˆë‹¤. íšŒí”¼ì— ì§‘ì¤‘í•˜ê³  ìš°ì„  ì²˜ì¹˜í•˜ì„¸ìš”.',
                            weakness: 'ì²´ë ¥ì´ ë‚®ê³  ê³µê²©ë ¥ì´ ë‚®ìŒ'
                        }
                    },
                    reflector: {
                        name: 'ë°˜ì‚¬ ì ', 
                        health: 40, 
                        speed: 1.5, 
                        damage: 15, 
                        color: '#f472b6', 
                        size: 34, 
                        shootInterval: 2500, 
                        points: 200, 
                        reflectChance: 0.3, // 30% í™•ë¥ ë¡œ íƒ„í™˜ ë°˜ì‚¬
                        description: 'ì¼ì • í™•ë¥ ë¡œ íƒ„í™˜ì„ ë°˜ì‚¬í•˜ëŠ” ëŠ¥ë ¥ì„ ê°€ì§„ ì .',
                        dexInfo: {
                            category: 'íŠ¹ìˆ˜',
                            difficulty: 'â˜…â˜…â˜…â˜†â˜†',
                            abilities: ['íƒ„í™˜ ë°˜ì‚¬', 'ì˜ˆì¸¡ ë¶ˆê°€ëŠ¥í•œ ê³µê²©'],
                            strategy: '30% í™•ë¥ ë¡œ íƒ„í™˜ì„ ë°˜ì‚¬í•˜ë¯€ë¡œ ê³µê²©í•  ë•Œ ì£¼ì˜í•´ì•¼ í•©ë‹ˆë‹¤. ë°˜ì‚¬ëœ íƒ„í™˜ì„ í”¼í•˜ì„¸ìš”.',
                            weakness: 'ì†ë„ê°€ ëŠë¦¬ê³  ë°˜ì‚¬ í™•ë¥ ì´ 30%ë¡œ ì œí•œì ì„'
                        }
                    },
                    healer: {
                        name: 'íëŸ¬ ì ', 
                        health: 32, 
                        speed: 1.2, 
                        damage: 0, 
                        color: '#bef264', 
                        size: 32, 
                        shootInterval: 4000, 
                        points: 180, 
                        healAmount: 15, 
                        healRadius: 120, 
                        healsOthers: true, // ì£¼ë³€ ì  íšŒë³µ
                        description: 'ì£¼ë³€ì˜ ë‹¤ë¥¸ ì ë“¤ì„ ì¹˜ë£Œí•˜ëŠ” ëŠ¥ë ¥ì„ ê°€ì§„ ì .',
                        dexInfo: {
                            category: 'ì§€ì›',
                            difficulty: 'â˜…â˜…â˜†â˜†â˜†',
                            abilities: ['ì  ì¹˜ë£Œ', 'ì§€ì†ì ì¸ ìœ„í˜‘'],
                            strategy: 'ë‹¤ë¥¸ ì ë“¤ì„ ì¹˜ë£Œí•˜ë¯€ë¡œ ìš°ì„  ì²˜ì¹˜í•´ì•¼ í•©ë‹ˆë‹¤. ì¹˜ë£Œ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ì„œ ê³µê²©í•˜ì„¸ìš”.',
                            weakness: 'ì§ì ‘ ê³µê²©ë ¥ì´ ì—†ê³  ì²´ë ¥ì´ ë‚®ìŒ'
                        }
                    },
                    portal: {
                        name: 'í¬íƒˆ ì ', 
                        health: 30, 
                        speed: 2.2, 
                        damage: 13, 
                        color: '#818cf8', 
                        size: 30, 
                        shootInterval: 2000, 
                        points: 170, 
                        teleportsNearPlayer: true, 
                        teleportCooldown: 3000, 
                        lastTeleport: 0, // ìˆœê°„ì´ë™
                        description: 'í”Œë ˆì´ì–´ ê·¼ì²˜ë¡œ ìˆœê°„ì´ë™í•˜ëŠ” ëŠ¥ë ¥ì„ ê°€ì§„ ì .',
                        dexInfo: {
                            category: 'íŠ¹ìˆ˜',
                            difficulty: 'â˜…â˜…â˜…â˜†â˜†',
                            abilities: ['ìˆœê°„ì´ë™', 'ì˜ˆì¸¡ ë¶ˆê°€ëŠ¥í•œ ìœ„ì¹˜'],
                            strategy: 'ê°‘ìê¸° í”Œë ˆì´ì–´ ê·¼ì²˜ë¡œ ìˆœê°„ì´ë™í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ìˆœê°„ì´ë™ í›„ ê³µê²©ê¹Œì§€ ì‹œê°„ì´ í•„ìš”í•˜ë‹ˆ ê·¸ íƒ€ì´ë°ì„ ë…¸ë¦¬ì„¸ìš”.',
                            weakness: 'ì²´ë ¥ì´ ë‚®ê³  ìˆœê°„ì´ë™ í›„ ê³µê²©ê¹Œì§€ ì‹œê°„ì´ í•„ìš”'
                        }
                    },
                    exploder: {
                        name: 'í­ë°œ ì ', 
                        health: 25, 
                        speed: 2, 
                        damage: 18, 
                        color: '#f87171', 
                        size: 28, 
                        shootInterval: 99999, 
                        points: 140, 
                        explodesOnDeath: true, 
                        explodeRadius: 70, // ì£½ìœ¼ë©´ í­ë°œ
                        description: 'ì£½ì„ ë•Œ í­ë°œí•˜ëŠ” ëŠ¥ë ¥ì„ ê°€ì§„ ì .',
                        dexInfo: {
                            category: 'íŠ¹ìˆ˜',
                            difficulty: 'â˜…â˜…â˜†â˜†â˜†',
                            abilities: ['ì‚¬í›„ í­ë°œ', 'ê´‘ì—­ ë°ë¯¸ì§€'],
                            strategy: 'ì£½ì„ ë•Œ í­ë°œí•˜ë¯€ë¡œ ë‹¤ë¥¸ ì ë“¤ê³¼ í•¨ê»˜ ìˆì„ ë•Œ ì£¼ì˜í•´ì•¼ í•©ë‹ˆë‹¤. í­ë°œ ë°˜ê²½ì„ ê³ ë ¤í•˜ì—¬ ì²˜ì¹˜í•˜ì„¸ìš”.',
                            weakness: 'ì²´ë ¥ì´ ë‚®ê³  ì§ì ‘ ê³µê²©ë ¥ì´ ì—†ìŒ'
                        }
                    },
                    magnet: {
                        name: 'ìì„ ì ', 
                        health: 30, 
                        speed: 1.8, 
                        damage: 10, 
                        color: '#fde047', 
                        size: 30, 
                        shootInterval: 2000, 
                        points: 160, 
                        pullsItems: true, 
                        magnetRadius: 180, // ì•„ì´í…œ ëŒì–´ë‹¹ê¹€
                        description: 'ì£¼ë³€ì˜ ì•„ì´í…œì„ ëŒì–´ë‹¹ê¸°ëŠ” ëŠ¥ë ¥ì„ ê°€ì§„ ì .',
                        dexInfo: {
                            category: 'íŠ¹ìˆ˜',
                            difficulty: 'â˜…â˜…â˜†â˜†â˜†',
                            abilities: ['ì•„ì´í…œ í¡ìˆ˜', 'ìì› ì œí•œ'],
                            strategy: 'ì•„ì´í…œì„ ëŒì–´ë‹¹ê¸°ë¯€ë¡œ ì•„ì´í…œì„ ì–»ê¸° ì–´ë ¤ì›Œì§‘ë‹ˆë‹¤. ìš°ì„  ì²˜ì¹˜í•˜ì—¬ ì•„ì´í…œì„ í™•ë³´í•˜ì„¸ìš”.',
                            weakness: 'ì²´ë ¥ì´ ë‚®ê³  ê³µê²©ë ¥ì´ ë‚®ìŒ'
                        }
                    },
                    curse: {
                        name: 'ì €ì£¼ ì ', 
                        health: 28, 
                        speed: 1.6, 
                        damage: 10, 
                        color: '#a3a3a3', 
                        size: 30, 
                        shootInterval: 2200, 
                        points: 170, 
                        cursesPlayer: true, 
                        curseDuration: 2500, // ë§ì¶”ë©´ ë””ë²„í”„
                        description: 'í”Œë ˆì´ì–´ë¥¼ ë§ì¶”ë©´ ì €ì£¼ë¥¼ ê±¸ì–´ ë””ë²„í”„ë¥¼ ì£¼ëŠ” ì .',
                        dexInfo: {
                            category: 'íŠ¹ìˆ˜',
                            difficulty: 'â˜…â˜…â˜†â˜†â˜†',
                            abilities: ['í”Œë ˆì´ì–´ ì €ì£¼', 'ë””ë²„í”„ ê³µê²©'],
                            strategy: 'ë§ìœ¼ë©´ ì €ì£¼ íš¨ê³¼ë¡œ ì¸í•´ ëŠ¥ë ¥ì¹˜ê°€ ê°ì†Œí•©ë‹ˆë‹¤. íšŒí”¼ì— ì§‘ì¤‘í•˜ê³  ìš°ì„  ì²˜ì¹˜í•˜ì„¸ìš”.',
                            weakness: 'ì²´ë ¥ì´ ë‚®ê³  ê³µê²©ë ¥ì´ ë‚®ìŒ'
                        }
                    },
                    floater: {
                        name: 'í”Œë¡œí„°', 
                        health: 35, 
                        speed: 2.5, 
                        damage: 15, 
                        color: '#8b5cf6', 
                        size: 32, 
                        shootInterval: 2000, 
                        points: 180, 
                        flies: true, 
                        floatDirection: 0, 
                        lastDirectionChange: 0, // ììœ ë¡œìš´ ì›€ì§ì„
                        description: 'ììœ ë¡­ê²Œ ì›€ì§ì´ëŠ” ëŠ¥ë ¥ì„ ê°€ì§„ ì . ì˜ˆì¸¡í•˜ê¸° ì–´ë ¤ìš´ íŒ¨í„´ì„ ë³´ì…ë‹ˆë‹¤.',
                        dexInfo: {
                            category: 'íŠ¹ìˆ˜',
                            difficulty: 'â˜…â˜…â˜†â˜†â˜†',
                            abilities: ['ììœ ë¡œìš´ ì›€ì§ì„', 'ì˜ˆì¸¡ ë¶ˆê°€ëŠ¥í•œ íŒ¨í„´'],
                            strategy: 'ììœ ë¡­ê²Œ ì›€ì§ì´ë¯€ë¡œ ì˜ˆì¸¡í•˜ê¸° ì–´ë µìŠµë‹ˆë‹¤. íŒ¨í„´ì„ íŒŒì•…í•˜ì—¬ ëŒ€ì‘í•˜ì„¸ìš”.',
                            weakness: 'ì²´ë ¥ì´ ë³´í†µì´ê³  ì§ì ‘ì ì¸ íŠ¹ìˆ˜ ëŠ¥ë ¥ì´ ì œí•œì ì„'
                        }
                    },
                    phaser: {
                        name: 'í˜ì´ì €', 
                        health: 40, 
                        speed: 2, 
                        damage: 20, 
                        color: '#06b6d4', 
                        size: 35, 
                        shootInterval: 1800, 
                        points: 200, 
                        phaseCooldown: 8000, 
                        lastPhase: 0, 
                        phaseDuration: 2000, 
                        isPhasing: false, // í˜ì´ì¦ˆ ìŠ¤í‚¬
                        description: 'ì¼ì • ì‹œê°„ ë™ì•ˆ í˜ì´ì¦ˆ ìƒíƒœê°€ ë˜ì–´ ë¬´ì ì´ ë˜ëŠ” ëŠ¥ë ¥ì„ ê°€ì§„ ì .',
                        dexInfo: {
                            category: 'íŠ¹ìˆ˜',
                            difficulty: 'â˜…â˜…â˜…â˜†â˜†',
                            abilities: ['í˜ì´ì¦ˆ ë¬´ì ', 'ì¼ì‹œì  ë³´í˜¸'],
                            strategy: 'í˜ì´ì¦ˆ ìƒíƒœì¼ ë•ŒëŠ” ê³µê²©ì´ í†µí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. í˜ì´ì¦ˆê°€ ëë‚  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¬ê±°ë‚˜ ë‹¤ë¥¸ ì ì„ ê³µê²©í•˜ì„¸ìš”.',
                            weakness: 'í˜ì´ì¦ˆ ìƒíƒœê°€ ì•„ë‹ ë•ŒëŠ” ì¼ë°˜ì ì¸ ì ê³¼ ë¹„ìŠ·í•¨'
                        }
                    },
                    // === ì™„ì „íˆ ìƒˆë¡œìš´ ì  10ì¢… ì¶”ê°€ ===
                    timekeeper: {
                        name: 'íƒ€ì„í‚¤í¼', 
                        health: 50, 
                        speed: 2.0, 
                        damage: 20, 
                        color: '#ff6b9d', 
                        size: 35, 
                        shootInterval: 2000, 
                        points: 280, 
                        timeReverse: true, 
                        timeReverseCooldown: 12000, 
                        lastTimeReverse: 0, 
                        timeReverseDuration: 3000, 
                        isTimeReversed: false, // ì‹œê°„ ì—­í–‰
                        description: 'ì‹œê°„ì„ ì—­í–‰ì‹œì¼œ ì²´ë ¥ì„ íšŒë³µí•˜ëŠ” ëŠ¥ë ¥ì„ ê°€ì§„ ì .',
                        dexInfo: {
                            category: 'íŠ¹ìˆ˜',
                            difficulty: 'â˜…â˜…â˜…â˜†â˜†',
                            abilities: ['ì‹œê°„ ì—­í–‰', 'ì²´ë ¥ íšŒë³µ'],
                            strategy: 'ì‹œê°„ ì—­í–‰ìœ¼ë¡œ ì²´ë ¥ì„ íšŒë³µí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. íšŒë³µ ì „ì— ì²˜ì¹˜í•˜ê±°ë‚˜ íšŒë³µ í›„ ë‹¤ì‹œ ê³µê²©í•˜ì„¸ìš”.',
                            weakness: 'ì‹œê°„ ì—­í–‰ ì¿¨ë‹¤ìš´ì´ ê¸¸ê³  ì¼ë°˜ ìƒíƒœì—ì„œëŠ” ë³´í†µì„'
                        }
                    },
                    gravity: {
                        name: 'ê·¸ë˜ë¹„í‹°', 
                        health: 45, 
                        speed: 1.8, 
                        damage: 18, 
                        color: '#9d4edd', 
                        size: 38, 
                        shootInterval: 2500, 
                        points: 260, 
                        gravityField: true, 
                        gravityCooldown: 8000, 
                        lastGravity: 0, 
                        gravityRadius: 200, 
                        gravityStrength: 0.8, // ì¤‘ë ¥ì¥ ìƒì„±
                        description: 'ì¤‘ë ¥ì¥ì„ ìƒì„±í•˜ì—¬ í”Œë ˆì´ì–´ë¥¼ ëŒì–´ë‹¹ê¸°ëŠ” ëŠ¥ë ¥ì„ ê°€ì§„ ì .',
                        dexInfo: {
                            category: 'íŠ¹ìˆ˜',
                            difficulty: 'â˜…â˜…â˜…â˜†â˜†',
                            abilities: ['ì¤‘ë ¥ì¥', 'í”Œë ˆì´ì–´ ëŒì–´ë‹¹ê¹€'],
                            strategy: 'ì¤‘ë ¥ì¥ìœ¼ë¡œ í”Œë ˆì´ì–´ë¥¼ ëŒì–´ë‹¹ê¸°ë¯€ë¡œ ë‹¤ë¥¸ ì ë“¤ì˜ ê³µê²©ì„ í”¼í•˜ê¸° ì–´ë ¤ì›Œì§‘ë‹ˆë‹¤. ì¤‘ë ¥ì¥ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ì„¸ìš”.',
                            weakness: 'ì¤‘ë ¥ì¥ ì¿¨ë‹¤ìš´ì´ ê¸¸ê³  ì¼ë°˜ ìƒíƒœì—ì„œëŠ” ë³´í†µì„'
                        }
                    },
                    echo: {
                        name: 'ì—ì½”', 
                        health: 40, 
                        speed: 2.2, 
                        damage: 15, 
                        color: '#4cc9f0', 
                        size: 32, 
                        shootInterval: 1800, 
                        points: 240, 
                        echoShot: true, 
                        echoCount: 3, 
                        echoDelay: 500, 
                        lastEcho: 0, // ì—ì½” ë°œì‚¬
                        description: 'ì—ì½” íš¨ê³¼ë¡œ ì—¬ëŸ¬ ë°œì˜ íƒ„í™˜ì„ ì—°ì†ìœ¼ë¡œ ë°œì‚¬í•˜ëŠ” ì .',
                        dexInfo: {
                            category: 'íŠ¹ìˆ˜',
                            difficulty: 'â˜…â˜…â˜†â˜†â˜†',
                            abilities: ['ì—ì½” ë°œì‚¬', 'ì—°ì† ê³µê²©'],
                            strategy: 'ì—ì½”ë¡œ ì—¬ëŸ¬ ë°œì˜ íƒ„í™˜ì„ ì—°ì†ìœ¼ë¡œ ë°œì‚¬í•©ë‹ˆë‹¤. íƒ„í™˜ì˜ íƒ€ì´ë°ì„ íŒŒì•…í•˜ì—¬ íšŒí”¼í•˜ì„¸ìš”.',
                            weakness: 'ì²´ë ¥ì´ ë³´í†µì´ê³  ì—ì½” ë°œì‚¬ í›„ ê³µê²©ê¹Œì§€ ì‹œê°„ì´ í•„ìš”'
                        }
                    },
                    vortex: {
                        name: 'ë³´ë¥´í…ìŠ¤', 
                        health: 55, 
                        speed: 1.5, 
                        damage: 25, 
                        color: '#7209b7', 
                        size: 40, 
                        shootInterval: 3000, 
                        points: 320, 
                        vortexPull: true, 
                        vortexCooldown: 10000, 
                        lastVortex: 0, 
                        vortexRadius: 250, 
                        vortexStrength: 2.0, // ì†Œìš©ëŒì´ ëŒì–´ë‹¹ê¹€
                        description: 'ì†Œìš©ëŒì´ë¥¼ ìƒì„±í•˜ì—¬ í”Œë ˆì´ì–´ë¥¼ ê°•í•˜ê²Œ ëŒì–´ë‹¹ê¸°ëŠ” ëŠ¥ë ¥ì„ ê°€ì§„ ì .',
                        dexInfo: {
                            category: 'íŠ¹ìˆ˜',
                            difficulty: 'â˜…â˜…â˜…â˜†â˜†',
                            abilities: ['ì†Œìš©ëŒì´', 'ê°•í•œ ëŒì–´ë‹¹ê¹€'],
                            strategy: 'ì†Œìš©ëŒì´ë¡œ ê°•í•˜ê²Œ ëŒì–´ë‹¹ê¸°ë¯€ë¡œ ë‹¤ë¥¸ ì ë“¤ì˜ ê³µê²©ì„ í”¼í•˜ê¸° ì–´ë ¤ì›Œì§‘ë‹ˆë‹¤. ì†Œìš©ëŒì´ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ì„¸ìš”.',
                            weakness: 'ì†Œìš©ëŒì´ ì¿¨ë‹¤ìš´ì´ ê¸¸ê³  ì¼ë°˜ ìƒíƒœì—ì„œëŠ” ë³´í†µì„'
                        }
                    },
                    prism: {
                        name: 'í”„ë¦¬ì¦˜', 
                        health: 35, 
                        speed: 2.5, 
                        damage: 12, 
                        color: '#f72585', 
                        size: 30, 
                        shootInterval: 1600, 
                        points: 220, 
                        prismSplit: true, 
                        prismCount: 5, 
                        prismAngle: Math.PI/3, 
                        lastPrism: 0, // í”„ë¦¬ì¦˜ ë¶„ì‚°
                        description: 'í”„ë¦¬ì¦˜ íš¨ê³¼ë¡œ íƒ„í™˜ì„ ì—¬ëŸ¬ ë°©í–¥ìœ¼ë¡œ ë¶„ì‚°ì‹œí‚¤ëŠ” ì .',
                        dexInfo: {
                            category: 'íŠ¹ìˆ˜',
                            difficulty: 'â˜…â˜…â˜†â˜†â˜†',
                            abilities: ['í”„ë¦¬ì¦˜ ë¶„ì‚°', 'ë‹¤ë°©í–¥ ê³µê²©'],
                            strategy: 'í”„ë¦¬ì¦˜ìœ¼ë¡œ íƒ„í™˜ì„ ì—¬ëŸ¬ ë°©í–¥ìœ¼ë¡œ ë¶„ì‚°ì‹œí‚µë‹ˆë‹¤. ë¶„ì‚°ëœ íƒ„í™˜ë“¤ì„ ëª¨ë‘ í”¼í•´ì•¼ í•©ë‹ˆë‹¤.',
                            weakness: 'ì²´ë ¥ì´ ë‚®ê³  ê°œë³„ íƒ„í™˜ì˜ ë°ë¯¸ì§€ê°€ ë‚®ìŒ'
                        }
                    },
                    quantum: {
                        name: 'í€€í…€', 
                        health: 60, 
                        speed: 2.8, 
                        damage: 30, 
                        color: '#3a0ca3', 
                        size: 36, 
                        shootInterval: 2200, 
                        points: 300, 
                        quantumTeleport: true, 
                        quantumCooldown: 6000, 
                        lastQuantum: 0, 
                        quantumRange: 300, // ì–‘ì ìˆœê°„ì´ë™
                        description: 'ì–‘ì ìˆœê°„ì´ë™ ëŠ¥ë ¥ì„ ê°€ì§„ ì . ê°‘ìê¸° ì‚¬ë¼ì¡Œë‹¤ê°€ ë‹¤ë¥¸ ìœ„ì¹˜ì—ì„œ ë‚˜íƒ€ë‚©ë‹ˆë‹¤.',
                        dexInfo: {
                            category: 'íŠ¹ìˆ˜',
                            difficulty: 'â˜…â˜…â˜…â˜†â˜†',
                            abilities: ['ì–‘ì ìˆœê°„ì´ë™', 'ì˜ˆì¸¡ ë¶ˆê°€ëŠ¥í•œ ìœ„ì¹˜'],
                            strategy: 'ì–‘ì ìˆœê°„ì´ë™ìœ¼ë¡œ ê°‘ìê¸° ìœ„ì¹˜ë¥¼ ë°”ê¿€ ìˆ˜ ìˆì–´ íšŒí”¼í•˜ê¸° ì–´ë ¤ìš¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ìˆœê°„ì´ë™ í›„ ê³µê²©ê¹Œì§€ ì‹œê°„ì´ í•„ìš”í•˜ë‹ˆ ê·¸ íƒ€ì´ë°ì„ ë…¸ë¦¬ì„¸ìš”.',
                            weakness: 'ìˆœê°„ì´ë™ í›„ ê³µê²©ê¹Œì§€ ì‹œê°„ì´ í•„ìš”í•˜ê³  ì²´ë ¥ì´ ë³´í†µì„'
                        }
                    },
                    crystal: {
                        name: 'í¬ë¦¬ìŠ¤íƒˆ', 
                        health: 70, 
                        speed: 1.2, 
                        damage: 35, 
                        color: '#4361ee', 
                        size: 45, 
                        shootInterval: 3500, 
                        points: 350, 
                        crystalShield: true, 
                        crystalCooldown: 15000, 
                        lastCrystal: 0, 
                        crystalDuration: 5000, 
                        isCrystalShielded: false, // í¬ë¦¬ìŠ¤íƒˆ ë°©íŒ¨
                        description: 'í¬ë¦¬ìŠ¤íƒˆ ë°©íŒ¨ë¥¼ ìƒì„±í•˜ì—¬ ì¼ì • ì‹œê°„ ë™ì•ˆ ë¬´ì ì´ ë˜ëŠ” ëŠ¥ë ¥ì„ ê°€ì§„ ì .',
                        dexInfo: {
                            category: 'íŠ¹ìˆ˜',
                            difficulty: 'â˜…â˜…â˜…â˜†â˜†',
                            abilities: ['í¬ë¦¬ìŠ¤íƒˆ ë°©íŒ¨', 'ì¼ì‹œì  ë¬´ì '],
                            strategy: 'í¬ë¦¬ìŠ¤íƒˆ ë°©íŒ¨ ìƒíƒœì¼ ë•ŒëŠ” ê³µê²©ì´ í†µí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë°©íŒ¨ê°€ ëë‚  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¬ê±°ë‚˜ ë‹¤ë¥¸ ì ì„ ê³µê²©í•˜ì„¸ìš”.',
                            weakness: 'í¬ë¦¬ìŠ¤íƒˆ ë°©íŒ¨ ì¿¨ë‹¤ìš´ì´ ë§¤ìš° ê¸¸ê³  ì¼ë°˜ ìƒíƒœì—ì„œëŠ” ë³´í†µì„'
                        }
                    },

                    plasma: {
                        name: 'í”Œë¼ì¦ˆë§ˆ', 
                        health: 48, 
                        speed: 2.1, 
                        damage: 28, 
                        color: '#06ffa5', 
                        size: 34, 
                        shootInterval: 1900, 
                        points: 270, 
                        plasmaChain: true, 
                        plasmaChainCount: 4, 
                        plasmaChainRange: 150, 
                        lastPlasma: 0, // í”Œë¼ì¦ˆë§ˆ ì²´ì¸
                        description: 'í”Œë¼ì¦ˆë§ˆ ì²´ì¸ê³¼ í­ë°œ ëŠ¥ë ¥ì„ ê°€ì§„ íŠ¹ìˆ˜ ì . ì—°ì‡„ ê³µê²©ìœ¼ë¡œ ìœ„í—˜í•©ë‹ˆë‹¤.',
                        dexInfo: {
                            category: 'íŠ¹ìˆ˜',
                            difficulty: 'â˜…â˜…â˜…â˜†â˜†',
                            abilities: ['í”Œë¼ì¦ˆë§ˆ ì²´ì¸', 'í”Œë¼ì¦ˆë§ˆ í­ë°œ'],
                            strategy: 'í”Œë¼ì¦ˆë§ˆ ì²´ì¸ìœ¼ë¡œ ì—°ì‡„ ê³µê²©ì„ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì²´ì¸ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ê±°ë‚˜ ì²´ì¸ì„ ëŠì–´ì£¼ì„¸ìš”.',
                            weakness: 'ì²´ë ¥ì´ ë³´í†µì´ê³  ì²´ì¸ ê³µê²© í›„ ê³µê²©ê¹Œì§€ ì‹œê°„ì´ í•„ìš”'
                        }
                    },
                    nebula: {
                        name: 'ë„¤ë·¸ë¼', 
                        health: 65, 
                        speed: 1.6, 
                        damage: 32, 
                        color: '#ff9e00', 
                        size: 42, 
                        shootInterval: 2800, 
                        points: 340, 
                        nebulaCloud: true, 
                        nebulaCooldown: 12000, 
                        lastNebula: 0, 
                        nebulaRadius: 180, 
                        nebulaDamage: 8, // ë„¤ë·¸ë¼ êµ¬ë¦„
                        description: 'ë„¤ë·¸ë¼ êµ¬ë¦„ì„ ìƒì„±í•˜ì—¬ ì§€ì†ì ì¸ ë°ë¯¸ì§€ë¥¼ ì£¼ëŠ” ëŠ¥ë ¥ì„ ê°€ì§„ ì .',
                        dexInfo: {
                            category: 'íŠ¹ìˆ˜',
                            difficulty: 'â˜…â˜…â˜…â˜†â˜†',
                            abilities: ['ë„¤ë·¸ë¼ êµ¬ë¦„', 'ì§€ì† ë°ë¯¸ì§€'],
                            strategy: 'ë„¤ë·¸ë¼ êµ¬ë¦„ìœ¼ë¡œ ì§€ì†ì ì¸ ë°ë¯¸ì§€ë¥¼ ì¤ë‹ˆë‹¤. êµ¬ë¦„ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ê±°ë‚˜ êµ¬ë¦„ì´ ì‚¬ë¼ì§ˆ ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¬ì„¸ìš”.',
                            weakness: 'ë„¤ë·¸ë¼ êµ¬ë¦„ ì¿¨ë‹¤ìš´ì´ ê¸¸ê³  ì¼ë°˜ ìƒíƒœì—ì„œëŠ” ë³´í†µì„'
                        }
                    },
                    // === ì‹ ê·œ ë³´ìŠ¤ 5ì¢… ===
                    boss_delta: {
                        name: 'ë¸íƒ€ ë³´ìŠ¤', health: 350, speed: 1.7, damage: 30, color: '#22223b', size: 80, shootInterval: 2000, points: 1200, blackholeCooldown: 9000, lastBlackhole: 0, blackholeRadius: 180 // ë¸”ë™í™€ ìƒì„±
                    },
                    boss_epsilon: {
                        name: 'ì—¡ì‹¤ë¡  ë³´ìŠ¤', health: 320, speed: 2.2, damage: 22, color: '#fbbf24', size: 75, shootInterval: 1800, points: 1100, cloneThreshold: 0.5, clones: 3, hasCloned: false // ë¶„ì‹  ìƒì„±
                    },
                    boss_zeta: {
                        name: 'ì œíƒ€ ë³´ìŠ¤', health: 300, speed: 2.5, damage: 28, color: '#06d6a0', size: 78, shootInterval: 1700, points: 1300, timeWarpCooldown: 8000, lastTimeWarp: 0 // ì‹œê°„ ì™œê³¡
                    },
                    boss_eta: {
                        name: 'ì—íƒ€ ë³´ìŠ¤', health: 400, speed: 1.3, damage: 40, color: '#ff006e', size: 90, shootInterval: 3000, points: 1500, laserCooldown: 7000, lastLaser: 0, laserDuration: 1200 // ë ˆì´ì € ë°œì‚¬
                    },
                    boss_theta: {
                        name: 'ì„íƒ€ ë³´ìŠ¤', health: 370, speed: 1.8, damage: 26, color: '#3a86ff', size: 85, shootInterval: 2100, points: 1250, reflectAllCooldown: 10000, lastReflectAll: 0, reflectAllDuration: 2000 // ë°œì‚¬ì²´ ë°˜ì‚¬
                    },
                    // === ì¶”ê°€ ì  2ì¢… ===
                    juggernaut: {
                        name: 'ì €ê±°ë„ˆíŠ¸', health: 800, speed: 1.2, damage: 8, color: '#444444', size: 60, shootInterval: 3000, points: 600, description: 'ê³µê²©ë ¥ì€ ì•½í•˜ì§€ë§Œ ì—„ì²­ë‚œ ì²´ë ¥ì„ ìë‘í•˜ëŠ” ê±°ëŒ€ ì .'
                    },
                    // ì°¸ì‹ í•œ í•˜ëŠ˜ ëª¹ (íƒ„ë§‰)
                    skyblaster: {
                        name: 'ìŠ¤ì¹´ì´ë¸”ë˜ìŠ¤í„°',
                        health: 90,
                        speed: 3.2,
                        damage: 14,
                        color: '#00bfff',
                        size: 36,
                        shootInterval: 1400,
                        points: 350,
                        flies: true,
                        multishot: 6, // í•œ ë²ˆì— 6ë°œ í¼ëœ¨ë¦¼
                        spread: Math.PI / 2, // 90ë„ ë²”ìœ„ë¡œ í¼ì§
                        description: 'í•˜ëŠ˜ì„ ë‚ ë©° í•œ ë²ˆì— ì—¬ëŸ¬ ë°œì˜ ì´ì•Œì„ í¼ëœ¨ë¦¬ëŠ” ì°¸ì‹ í•œ íƒ„ë§‰ ëª¹.'
                    },
                    melee: {
                        name: 'ê·¼ì ‘ ê³µê²©',
                        health: 0,
                        speed: 0,
                        damage: 0,
                        color: '#f59e42',
                        size: 0,
                        shootInterval: 0,
                        points: 0,
                        description: 'ê·¼ì ‘ ê³µê²© ë¬´ê¸°'
                    }
                };

                // ë³´ìƒ ì˜µì…˜ ì •ì˜
                this.REWARD_OPTIONS = [
                    { text: '+100 ìµœëŒ€ ì²´ë ¥', type: 'maxHealth', value: 100 },
                    { text: '+50 í˜„ì¬ ì²´ë ¥', type: 'currentHealth', value: 50 },
                    { text: '+5 ê³µê²©ë ¥', type: 'damage', value: 5 },
                    { text: '+1 ì´ë™ ì†ë„', type: 'speed', value: 1 },
                    { text: '+1 ë‹¤ì¤‘ ë°œì‚¬', type: 'multishot', value: 1 },
                    { text: 'íšŒì „ ì¹¼ë‚ ', type: 'orbiting_knife', value: 1 }, // ë³´ìƒìœ¼ë¡œ íšŒì „ ì¹¼ë‚  ì¶”ê°€
                    { text: 'ê´€í†µ ì‚¬ê²©', type: 'piercing_shot', value: 1 }, // ë³´ìƒìœ¼ë¡œ ê´€í†µ ì‚¬ê²© ì¶”ê°€
                    { text: 'í­ë°œ ì‚¬ê²©', type: 'explosive_shot', value: 1 }, // ë³´ìƒìœ¼ë¡œ í­ë°œ ì‚¬ê²© ì¶”ê°€
                    { text: 'ë„íƒ„ ì‚¬ê²©', type: 'ricochet_shot', value: 1 }, // ë³´ìƒìœ¼ë¡œ ë„íƒ„ ì‚¬ê²© ì¶”ê°€
                    { text: 'ìœ ë„ ì‚¬ê²©', type: 'homing_shot', value: 1 }, // ë³´ìƒìœ¼ë¡œ ìœ ë„ ì‚¬ê²© ì¶”ê°€
                    { text: 'ë¶„ì—´ ì‚¬ê²©', type: 'split_shot', value: 1 }, // ë³´ìƒìœ¼ë¡œ ë¶„ì—´ ì‚¬ê²© ì¶”ê°€
                    { text: 'ìƒëª…ë ¥ í¡ìˆ˜', type: 'life_steal', value: 0.02 }, // ìƒëª…ë ¥ í¡ìˆ˜ ì¶”ê°€ (2%)
                    { text: 'ì¹˜ëª…íƒ€ í™•ë¥ ', type: 'crit_chance', value: 0.05 }, // ì¹˜ëª…íƒ€ í™•ë¥  ì¶”ê°€ (5%)
                    { text: 'ì¬ì‚¬ìš© ëŒ€ê¸°ì‹œê°„ ê°ì†Œ', type: 'cooldown_reduction', value: 0.05 }, // ì¬ì‚¬ìš© ëŒ€ê¸°ì‹œê°„ ê°ì†Œ (5%)
                    { text: 'ë°©ì–´ë ¥', type: 'armor', value: 5 }, // ë°©ì–´ë ¥ ì¶”ê°€ (5)
                    { text: 'ì‹œê°„ ì •ì§€', type: 'time_stop', value: 3000 }, // ì‹œê°„ ì •ì§€ ì•„ì´í…œ
                    { text: 'íƒ„ì•½ ì¬ìƒ', type: 'ammo_regen', value: 10 } // íƒ„ì•½ ì¬ìƒ ì•„ì´í…œ
                ];
                
                // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
                this.setupEventListeners();
                this.xp = 0;

                // GlassCombatArena ìƒì„±ì ë‚´ë¶€ì— ì¶”ê°€
                this.upgrades = { gun: 0, melee: 0, health: 0, speed: 0, cooldown: 0 };
                this.scoreMilestones = [1000, 2000, 3000, 5000, 8000, 12000, 18000, 25000, 35000, 50000];
                this.nextMilestoneIndex = 0;

                // 1. SHOP_ITEMSë¥¼ JSì— ëª…í™•íˆ ì •ì˜ (GlassCombatArena í´ë˜ìŠ¤ ë‚´ constructorì— ì¶”ê°€)
                this.SHOP_ITEMS = [
                                    { text: '+100 ìµœëŒ€ ì²´ë ¥', type: 'maxHealth', value: 100, basePrice: 2000, purchaseCount: 0 },
                { text: '+50 í˜„ì¬ ì²´ë ¥', type: 'currentHealth', value: 50, basePrice: 1400, purchaseCount: 0 },
                { text: '+5 ê³µê²©ë ¥', type: 'damage', value: 5, basePrice: 2400, purchaseCount: 0 },
                { text: '+1 ì´ë™ ì†ë„', type: 'speed', value: 1, basePrice: 1800, purchaseCount: 0 },
                { text: '+1 ë‹¤ì¤‘ ë°œì‚¬', type: 'multishot', value: 1, basePrice: 3000, purchaseCount: 0 },
                { text: 'íšŒì „ ì¹¼ë‚ ', type: 'orbiting_knife', value: 1, basePrice: 4000, purchaseCount: 0 },
                { text: 'ê´€í†µ ì‚¬ê²©', type: 'piercing_shot', value: 1, basePrice: 3600, purchaseCount: 0 },
                { text: 'í­ë°œ ì‚¬ê²©', type: 'explosive_shot', value: 1, basePrice: 3600, purchaseCount: 0 },
                { text: 'ë„íƒ„ ì‚¬ê²©', type: 'ricochet_shot', value: 1, basePrice: 3600, purchaseCount: 0 },
                { text: 'ìœ ë„ ì‚¬ê²©', type: 'homing_shot', value: 1, basePrice: 3600, purchaseCount: 0 },
                { text: 'ë¶„ì—´ ì‚¬ê²©', type: 'split_shot', value: 1, basePrice: 3600, purchaseCount: 0 },
                { text: 'í¡í˜ˆ', type: 'life_steal', value: 0.05, basePrice: 4400, purchaseCount: 0 },
                { text: 'ì¹˜ëª…íƒ€ í™•ë¥ ', type: 'crit_chance', value: 0.05, basePrice: 4000, purchaseCount: 0 },
                { text: 'ì¬ì‚¬ìš© ëŒ€ê¸°ì‹œê°„ ê°ì†Œ', type: 'cooldown_reduction', value: 0.05, basePrice: 4000, purchaseCount: 0 },
                { text: 'ë°©ì–´ë ¥', type: 'armor', value: 5, basePrice: 4000, purchaseCount: 0 },
                { text: 'íƒ„ì•½ ìë™ íšŒë³µ', type: 'ammo_regen', value: 1, basePrice: 3600, purchaseCount: 0 }
                ];


            }
            
            // ìº”ë²„ìŠ¤ í¬ê¸°ë¥¼ ì°½ í¬ê¸°ì— ë§ê²Œ ì¡°ì •
            resizeCanvas = () => {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }
            
            // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì • (í‚¤ë³´ë“œ, ë§ˆìš°ìŠ¤, ì°½ í¬ê¸° ì¡°ì •)
            setupEventListeners = () => {
                // í‚¤ë³´ë“œ ì…ë ¥ ì²˜ë¦¬
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    if (e.key === ' ') e.preventDefault(); // ìŠ¤í˜ì´ìŠ¤ë°” ê¸°ë³¸ ë™ì‘ ë°©ì§€ (ìŠ¤í¬ë¡¤)
                    if (e.key.toLowerCase() === 'e') this.tryDash();
                    if (e.key === '1') this.currentWeapon = 'gun';
                    if (e.key === '2') this.currentWeapon = 'melee';
                    if (e.key.toLowerCase() === 'r') this.reload(); // Rí‚¤ë¡œ ì¬ì¥ì „
                    
                    // í”Œë ˆì´ì–´2 í‚¤ ì…ë ¥ ì²˜ë¦¬ (ë©€í‹°í”Œë ˆì´ ëª¨ë“œì¼ ë•Œë§Œ)
                    if (this.gameState.player2 && this.gameState.multiplayerMode) {
                        // í”Œë ˆì´ì–´2 í‚¤ ë§¤í•‘: WASD -> IJKL, ìŠ¤í˜ì´ìŠ¤ -> ì—”í„°, R -> T
                        const player2KeyMap = {
                            'i': 'w', 'j': 'a', 'k': 's', 'l': 'd',
                            'enter': ' ', 't': 'r'
                        };
                        
                        const mappedKey = player2KeyMap[e.key.toLowerCase()];
                        if (mappedKey) {
                            this.gameState.player2.keys[mappedKey] = true;
                        }
                        
                        // í”Œë ˆì´ì–´2 ë°œì‚¬ (Oí‚¤)
                        if (e.key.toLowerCase() === 'o' && this.gameState.gameStatus === 'playing' && this.gameState.multiplayerMode) {
                            this.shootPlayer2();
                        }
                        
                        // í”Œë ˆì´ì–´2 ì¬ì¥ì „ (Tí‚¤)
                        if (e.key.toLowerCase() === 't') {
                            this.reloadPlayer2();
                        }
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                    
                    // í”Œë ˆì´ì–´2 í‚¤ ì…ë ¥ ì²˜ë¦¬
                    if (this.gameState.player2 && this.gameState.multiplayerMode) {
                        const player2KeyMap = {
                            'i': 'w', 'j': 'a', 'k': 's', 'l': 'd',
                            'enter': ' ', 't': 'r'
                        };
                        
                        const mappedKey = player2KeyMap[e.key.toLowerCase()];
                        if (mappedKey) {
                            this.gameState.player2.keys[mappedKey] = false;
                        }
                    }
                });
                
                // ë§ˆìš°ìŠ¤ ì…ë ¥ ì²˜ë¦¬
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouse.x = e.clientX - rect.left;
                    this.mouse.y = e.clientY - rect.top;
                });
                
                this.canvas.addEventListener('click', (e) => {
                    if (this.gameState.gameStatus === 'playing') {
                        this.shoot(); // ê²Œì„ í”Œë ˆì´ ì¤‘ì¼ ë•Œë§Œ ë°œì‚¬
                    } else if (e.button === 0 && this.gameState.gameStatus === 'start') {
                        // ì‹œì‘ í™”ë©´ì—ì„œ í´ë¦­ ì‹œ ì‹œì‘ ë²„íŠ¼ í´ë¦­ê³¼ ë™ì¼í•˜ê²Œ ì²˜ë¦¬ (ì„ íƒ ì‚¬í•­)
                        // document.getElementById('startButton').click();
                    } else if (e.button === 0 && this.gameState.gameStatus === 'game-over') {
                        // ê²Œì„ ì˜¤ë²„ í™”ë©´ì—ì„œ í´ë¦­ ì‹œ ì¬ì‹œì‘ (ì„ íƒ ì‚¬í•­)
                        // this.resetGame();
                    }
                });
                
                // ì°½ í¬ê¸° ì¡°ì • ì‹œ ìº”ë²„ìŠ¤ í¬ê¸° ì¬ì¡°ì •
                window.addEventListener('resize', this.resizeCanvas);

                // ì‹œì‘ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
                document.getElementById('startButton').addEventListener('click', this.startGame);
                
                // ì  ë„ê° ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
                document.getElementById('enemyDexHUDButton').addEventListener('click', () => {
                    this.showEnemyDex();
                });
                
                // ì  ë„ê° ë‹«ê¸° ë²„íŠ¼
                document.getElementById('closeEnemyDexButton').addEventListener('click', () => {
                    this.hideEnemyDex();
                });
            }

            // ì‹œì‘ í™”ë©´ í‘œì‹œ (ìº”ë²„ìŠ¤ ë¸”ëŸ¬ ì²˜ë¦¬)
            showStartScreen = () => {
                this.canvas.style.filter = 'blur(10px)'; // ìº”ë²„ìŠ¤ ë¸”ëŸ¬ ì²˜ë¦¬
                this.canvas.style.display = 'block'; // ìº”ë²„ìŠ¤ ë³´ì´ê²Œ
                document.querySelector('.hud').style.display = 'none'; // HUD ìˆ¨ê¹€
                document.getElementById('startScreen').style.display = 'flex'; // ì‹œì‘ í™”ë©´ í‘œì‹œ
                document.getElementById('rewardSelectionScreen').style.display = 'none'; // ë³´ìƒ í™”ë©´ ìˆ¨ê¹€
            }

            // í…ŒìŠ¤íŒ… ì¡´ ì‹œì‘
            startTestZone = () => {
                this.canvas.style.filter = 'blur(0px)'; // ìº”ë²„ìŠ¤ ë¸”ëŸ¬ ì œê±°
                document.getElementById('introScreen').style.display = 'none'; // ì¸íŠ¸ë¡œ í™”ë©´ ìˆ¨ê¹€
                document.querySelector('.hud').style.display = 'flex'; // HUD í‘œì‹œ
                document.getElementById('rewardSelectionScreen').style.display = 'none'; // ë³´ìƒ í™”ë©´ ìˆ¨ê¹€

                // ê²Œì„ ìƒíƒœ ì´ˆê¸°í™” (í…ŒìŠ¤íŒ… ì¡´ìš©)
                this.gameState = {
                    player: {
                        x: this.canvas.width / 2, y: this.canvas.height / 2,
                        width: 40, height: 40,
                        vx: 0, vy: 0,
                        health: 150, maxHealth: 150,
                        ammo: 30, maxAmmo: 30,
                        speed: 5, jumpPower: 15,
                        onGround: false, facing: 0,
                        expression: this.getRandomExpression(),
                        color: '#6366f1',
                        baseDamage: 10,
                        multishot: 1,
                        rapidFireTime: 0,
                        damageReductionFactor: 1,
                        shieldBoostEndTime: 0,
                        healthRegenEndTime: 0,
                        lastRegenTick: 0,
                        magnetEndTime: 0,
                        magnetRadius: 200,
                        lastHitById: null,
                        type: 'player',
                        orbitingKnives: [],
                        piercingShot: 0,
                        explosiveShot: 0,
                        ricochetLevel: 0,
                        homingLevel: 0,
                        splitLevel: 0,
                        lifeStealPercent: 0,
                        critChance: 0,
                        critMultiplier: 1.5,
                        cooldownReduction: 0,
                        armor: 0,
                        timeStopEndTime: 0,
                        ammoRegenEndTime: 0,
                        lastAmmoRegenTick: 0,
                        ammoRegenAmount: 0,
                        dashCooldown: 0,
                        dashEndTime: 0,
                        isDashing: false,
                        reloadTime: 1500,
                        isReloading: false,
                        machineGunMode: false,
                        machineGunPenalty: false,
                        reloadPenalty: 0,
                        gunRecoil: 0,
                        gunRecoilTarget: 0,
                    },
                    enemies: [],
                    projectiles: [],
                    items: [],
                    particles: [],
                    floatingTexts: [],
                    allies: [],
                    score: 0,
                    wave: 1,
                    gameStatus: 'playing',
                    message: '',
                    messageTimer: 0,
                    playerSlowedEndTime: 0,
                    timeSlowEndTime: 0,
                    timeSlowEffect: 1
                };
                
                // ë³´ìŠ¤ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
                this.bossSystem = {
                    isActive: false,
                    currentBoss: null,
                    spawnLock: false
                };
                
                // ê²Œì„ ëª¨ë“œ ì„¤ì • (í…ŒìŠ¤íŒ… ì¡´)
                this.gameMode = 'testzone';
                
                // í…ŒìŠ¤íŒ… ì¡´ UI ë²„íŠ¼ì„ HUDì— ì¶”ê°€
                this.addTestZoneButtonToHUD();
                
                this.gameLoop(); // ê²Œì„ ë£¨í”„ ì‹œì‘
                this.updateHUD(); // HUD ì´ˆê¸° ì—…ë°ì´íŠ¸
                this.hideMessage(); // ë©”ì‹œì§€ ìˆ¨ê¸°ê¸°

                // í€˜ìŠ¤íŠ¸ ì´ˆê¸°í™”
                this.questSystem.activeQuests = [];
                for (let i = 0; i < 3; i++) {
                    this.questSystem.activeQuests.push(this.generateQuest());
                }
                this.updateQuestUI();

                this.currentWeapon = 'gun';
                this.upgrades = { gun: 0, melee: 0, health: 0, speed: 0, cooldown: 0 };
            }

            // ë©€í‹°í”Œë ˆì´ ê²Œì„ ì‹œì‘ ë©”ì„œë“œ
            startMultiplayerGame = (mode, config) => {
                this.canvas.style.filter = 'blur(0px)';
                document.getElementById('startScreen').style.display = 'none';
                document.querySelector('.hud').style.display = 'flex';
                document.getElementById('rewardSelectionScreen').style.display = 'none';

                // ê²Œì„ ìƒíƒœ ì´ˆê¸°í™”
                this.gameState = {
                    player: {
                        x: this.canvas.width / 2, y: this.canvas.height / 2,
                        width: 40, height: 40,
                        vx: 0, vy: 0,
                        health: 150, maxHealth: 150,
                        ammo: 30, maxAmmo: 30,
                        speed: 5, jumpPower: 15,
                        onGround: false, facing: 0,
                        expression: this.getRandomExpression(),
                        color: config.player1Color || config.leaderColor || '#6366f1',
                        baseDamage: 10,
                        multishot: 1,
                        rapidFireTime: 0,
                        damageReductionFactor: 1,
                        shieldBoostEndTime: 0,
                        healthRegenEndTime: 0,
                        lastRegenTick: 0,
                        magnetEndTime: 0,
                        magnetRadius: 200,
                        lastHitById: null,
                        type: 'player',
                        orbitingKnives: [],
                        piercingShot: 0,
                        explosiveShot: 0,
                        ricochetLevel: 0,
                        homingLevel: 0,
                        splitLevel: 0,
                        lifeStealPercent: 0,
                        critChance: 0,
                        critMultiplier: 1.5,
                        cooldownReduction: 0,
                        armor: 0,
                        timeStopEndTime: 0,
                        ammoRegenEndTime: 0,
                        lastAmmoRegenTick: 0,
                        ammoRegenAmount: 0,
                        dashCooldown: 0,
                        dashEndTime: 0,
                        isDashing: false,
                        reloadTime: 1500,
                        isReloading: false,
                        machineGunMode: false,
                        machineGunPenalty: false,
                        reloadPenalty: 0,
                        gunRecoil: 0,
                        gunRecoilTarget: 0,
                    },
                    player2: this.createPlayer2(config),
                    multiplayerMode: mode,
                    multiplayerConfig: config,
                    // ë¶€í™œ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
                    player1Dead: false,
                    player2Dead: false,
                    lastDeathWave: 0,
                    revivalWaveCount: 0,
                    enemies: [],
                    projectiles: [],
                    items: [],
                    particles: [],
                    floatingTexts: [],
                    allies: [],
                    score: 0,
                    wave: 1,
                    gameStatus: 'playing',
                    message: '',
                    messageTimer: 0,
                    playerSlowedEndTime: 0,
                    timeSlowEndTime: 0,
                    timeSlowEffect: 1
                };
                
                // ë³´ìŠ¤ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
                this.bossSystem = {
                    isActive: false,
                    currentBoss: null,
                    spawnLock: false
                };
                
                // ê²Œì„ ëª¨ë“œ ì„¤ì •
                this.gameMode = 'multiplayer';
                
                // ì´ˆê¸° ì›¨ì´ë¸Œ ìƒì„±
                this.spawnInitialWave();
                
                // ê²Œì„ ë£¨í”„ ì‹œì‘
                this.gameLoop();
                this.updateHUD();
                this.hideMessage();
                
                // í”Œë ˆì´ì–´2 HUD í‘œì‹œ (ë©€í‹°í”Œë ˆì´ì–´ ëª¨ë“œì—ì„œë§Œ)
                if (this.gameState.player2 && this.gameState.multiplayerMode) {
                    document.getElementById('player2HUD').style.display = 'flex';
                }
                
                // í€˜ìŠ¤íŠ¸ ì´ˆê¸°í™”
                this.questSystem.activeQuests = [];
                for (let i = 0; i < 3; i++) {
                    this.questSystem.activeQuests.push(this.generateQuest());
                }
                this.updateQuestUI();
                
                this.currentWeapon = 'gun';
                this.upgrades = { gun: 0, melee: 0, health: 0, speed: 0, cooldown: 0 };
                
                // ë©€í‹°í”Œë ˆì´ ëª¨ë“œë³„ ë©”ì‹œì§€ í‘œì‹œ
                if (mode === 'leader') {
                    this.showMessage('ë¦¬ë” ì‹œìŠ¤í…œ ì‹œì‘!', `${config.leaderName}ì´ ${config.followerName}ì„ ì´ë•ë‹ˆë‹¤!`, 2000);
                } else if (mode === 'hybrid') {
                    const hybridPlayerName = config.hybridPlayer === 'player1' ? config.player1Name : config.player2Name;
                    this.showMessage('í•˜ì´ë¸Œë¦¬ë“œ ì‹œìŠ¤í…œ ì‹œì‘!', `${hybridPlayerName}ì´ ìë™ ì¡°ì¤€ì„ ì‚¬ìš©í•©ë‹ˆë‹¤!`, 2000);
                }
            };

            // í”Œë ˆì´ì–´2 ìƒì„± ë©”ì„œë“œ
            createPlayer2 = (config) => {
                const player2 = {
                    x: this.canvas.width / 2 + 50,
                    y: this.canvas.height / 2,
                    width: 40,
                    height: 40,
                    vx: 0,
                    vy: 0,
                    health: 150,
                    maxHealth: 150,
                    ammo: 30,
                    maxAmmo: 30,
                    speed: 5,
                    jumpPower: 15,
                    onGround: false,
                    facing: 0,
                    expression: this.getRandomExpression(),
                    color: config.player2Color || config.followerColor || '#ef4444',
                    baseDamage: 10,
                    multishot: 1,
                    rapidFireTime: 0,
                    damageReductionFactor: 1,
                    shieldBoostEndTime: 0,
                    healthRegenEndTime: 0,
                    lastRegenTick: 0,
                    magnetEndTime: 0,
                    magnetRadius: 200,
                    lastHitById: null,
                    type: 'player2',
                    orbitingKnives: [],
                    piercingShot: 0,
                    explosiveShot: 0,
                    ricochetLevel: 0,
                    homingLevel: 0,
                    splitLevel: 0,
                    lifeStealPercent: 0,
                    critChance: 0,
                    critMultiplier: 1.5,
                    cooldownReduction: 0,
                    armor: 0,
                    timeStopEndTime: 0,
                    ammoRegenEndTime: 0,
                    lastAmmoRegenTick: 0,
                    ammoRegenAmount: 0,
                    dashCooldown: 0,
                    dashEndTime: 0,
                    isDashing: false,
                    reloadTime: 1500,
                    isReloading: false,
                    machineGunMode: false,
                    machineGunPenalty: false,
                    reloadPenalty: 0,
                    gunRecoil: 0,
                    gunRecoilTarget: 0,
                    // í”Œë ˆì´ì–´2 ì „ìš© ì†ì„±ë“¤
                    keys: {}, // í”Œë ˆì´ì–´2 í‚¤ ì…ë ¥
                    lastShot: 0, // ë§ˆì§€ë§‰ ë°œì‚¬ ì‹œê°„
                    autoAimTarget: null, // ìë™ ì¡°ì¤€ íƒ€ê²Ÿ
                    followTarget: null, // ë”°ë¼ê°ˆ íƒ€ê²Ÿ (ë¦¬ë” ì‹œìŠ¤í…œìš©)
                };
                
                return player2;
            };

            // í”Œë ˆì´ì–´2 ë°œì‚¬ ë©”ì„œë“œ
            shootPlayer2 = () => {
                const player2 = this.gameState.player2;
                if (!player2 || player2.ammo <= 0 || this.gameState.player2Dead) return;
                
                // ìë™ ì¬ì¥ì „: íƒ„ì•½ì´ ì—†ìœ¼ë©´ ìë™ìœ¼ë¡œ ì¬ì¥ì „
                if (player2.ammo <= 0 && !player2.isReloading) {
                    this.reloadPlayer2();
                    return;
                }
                
                if (player2.isReloading) return;
                
                const now = Date.now();
                if (now - player2.lastShot < 200) return; // ë°œì‚¬ ì†ë„ ì œí•œ
                
                player2.lastShot = now;
                player2.ammo--;
                
                // ì¡°ì¤€ ë°©í–¥ ê²°ì •
                let angle = player2.facing;
                
                if (this.gameState.multiplayerMode === 'leader') {
                    // ë¦¬ë” ì‹œìŠ¤í…œ: í”Œë ˆì´ì–´1ì˜ ì¡°ì¤€ ë°©í–¥ì„ ë”°ë¼ê°
                    angle = this.gameState.player.facing;
                } else if (this.gameState.multiplayerMode === 'hybrid') {
                    // í•˜ì´ë¸Œë¦¬ë“œ ì‹œìŠ¤í…œ: ìë™ ì¡°ì¤€
                    const nearestEnemy = this.findNearestEnemy(player2);
                    if (nearestEnemy) {
                        angle = Math.atan2(nearestEnemy.y - player2.y, nearestEnemy.x - player2.x);
                    }
                }
                
                // ë°œì‚¬ì²´ ìƒì„±
                const projectile = {
                    id: Date.now() + Math.random(),
                    x: player2.x + Math.cos(angle) * 25,
                    y: player2.y + Math.sin(angle) * 25,
                    vx: Math.cos(angle) * 8,
                    vy: Math.sin(angle) * 8,
                    radius: 3,
                    damage: player2.baseDamage || 10,
                    life: 80,
                    color: player2.color || '#ff6b6b',
                    ownerId: 'player2',
                    pierceCount: player2.piercingShot || 0,
                    explosiveRadius: player2.explosiveShot || 0,
                    bounceCount: 0,
                    isHoming: player2.homingLevel > 0,
                    homingStrength: player2.homingLevel * 0.05 || 0,
                    splitCount: player2.splitLevel || 0,
                    hitEnemies: [],
                    isCritical: Math.random() < (player2.critChance || 0)
                };
                
                console.log('í”Œë ˆì´ì–´2 ë°œì‚¬ì²´ ìƒì„±:', projectile);
                
                this.gameState.projectiles.push(projectile);
                
                // ë‹¤ì¤‘ ë°œì‚¬ ì²˜ë¦¬
                if (player2.multishot > 1) {
                    for (let i = 1; i < player2.multishot; i++) {
                        const spreadAngle = angle + (i - (player2.multishot - 1) / 2) * 0.2;
                        const spreadProjectile = {
                            ...projectile,
                            id: Date.now() + Math.random(),
                            x: player2.x + Math.cos(spreadAngle) * 25,
                            y: player2.y + Math.sin(spreadAngle) * 25,
                            vx: Math.cos(spreadAngle) * 8,
                            vy: Math.sin(spreadAngle) * 8
                        };
                        this.gameState.projectiles.push(spreadProjectile);
                    }
                }
                
                // ë¶„ì—´ ì‚¬ê²© ì²˜ë¦¬
                if (player2.splitLevel > 0) {
                    for (let i = 0; i < player2.splitLevel; i++) {
                        const splitAngle = angle + (i + 1) * (Math.PI / (player2.splitLevel + 1));
                        const splitProjectile = {
                            ...projectile,
                            id: Date.now() + Math.random(),
                            x: player2.x + Math.cos(splitAngle) * 25,
                            y: player2.y + Math.sin(splitAngle) * 25,
                            vx: Math.cos(splitAngle) * 8,
                            vy: Math.sin(splitAngle) * 8
                        };
                        this.gameState.projectiles.push(splitProjectile);
                    }
                }
            };

            // ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸°
            findNearestEnemy = (player) => {
                let nearestEnemy = null;
                let nearestDistance = Infinity;
                
                this.gameState.enemies.forEach(enemy => {
                    const distance = Math.sqrt((enemy.x - player.x) ** 2 + (enemy.y - player.y) ** 2);
                    if (distance < nearestDistance) {
                        nearestDistance = distance;
                        nearestEnemy = enemy;
                    }
                });
                
                return nearestEnemy;
            };

            // í”Œë ˆì´ì–´2 ì¬ì¥ì „ ë©”ì„œë“œ
            reloadPlayer2 = () => {
                const player2 = this.gameState.player2;
                if (!player2 || player2.isReloading || player2.ammo >= player2.maxAmmo) return;
                
                player2.isReloading = true;
                const reloadTime = player2.reloadTime + player2.reloadPenalty;
                
                setTimeout(() => {
                    if (player2) {
                        player2.ammo = player2.maxAmmo;
                        player2.isReloading = false;
                    }
                }, reloadTime);
            };

            // í”Œë ˆì´ì–´ ì‚¬ë§ ì²˜ë¦¬ ë©”ì„œë“œ
            handlePlayerDeath = (playerType) => {
                if (playerType === 'player1') {
                    this.gameState.player1Dead = true;
                    this.gameState.player.health = 0;
                    this.showMessage('í”Œë ˆì´ì–´1 ì‚¬ë§!', 'í”Œë ˆì´ì–´2ê°€ 5ì›¨ì´ë¸Œë¥¼ í´ë¦¬ì–´í•˜ë©´ ë¶€í™œí•©ë‹ˆë‹¤!', 3000);
                } else if (playerType === 'player2') {
                    this.gameState.player2Dead = true;
                    this.gameState.player2.health = 0;
                    this.showMessage('í”Œë ˆì´ì–´2 ì‚¬ë§!', 'í”Œë ˆì´ì–´1ì´ 5ì›¨ì´ë¸Œë¥¼ í´ë¦¬ì–´í•˜ë©´ ë¶€í™œí•©ë‹ˆë‹¤!', 3000);
                }
                
                this.gameState.lastDeathWave = this.gameState.wave;
                
                // ë‘ í”Œë ˆì´ì–´ ëª¨ë‘ ì£½ì—ˆëŠ”ì§€ í™•ì¸
                if (this.gameState.player1Dead && this.gameState.player2Dead) {
                    this.gameOver();
                }
            };

            // í”Œë ˆì´ì–´ ë¶€í™œ ë©”ì„œë“œ
            revivePlayer = (playerType) => {
                if (playerType === 'player1') {
                    this.gameState.player1Dead = false;
                    this.gameState.player.health = this.gameState.player.maxHealth * 0.5; // 50% ì²´ë ¥ìœ¼ë¡œ ë¶€í™œ
                    this.gameState.player.ammo = this.gameState.player.maxAmmo;
                    this.showMessage('í”Œë ˆì´ì–´1 ë¶€í™œ!', '50% ì²´ë ¥ìœ¼ë¡œ ë¶€í™œí–ˆìŠµë‹ˆë‹¤!', 3000);
                } else if (playerType === 'player2') {
                    this.gameState.player2Dead = false;
                    this.gameState.player2.health = this.gameState.player2.maxHealth * 0.5; // 50% ì²´ë ¥ìœ¼ë¡œ ë¶€í™œ
                    this.gameState.player2.ammo = this.gameState.player2.maxAmmo;
                    this.gameState.player2.isReloading = false; // ì¬ì¥ì „ ìƒíƒœ ì´ˆê¸°í™”
                    this.gameState.player2.gunRecoil = 0; // ë°˜ë™ ì´ˆê¸°í™”
                    this.gameState.player2.gunRecoilTarget = 0; // ë°˜ë™ íƒ€ê²Ÿ ì´ˆê¸°í™”
                    this.showMessage('í”Œë ˆì´ì–´2 ë¶€í™œ!', '50% ì²´ë ¥ìœ¼ë¡œ ë¶€í™œí–ˆìŠµë‹ˆë‹¤!', 3000);
                }
                
                this.gameState.revivalWaveCount = 0; // ë¶€í™œ ì¹´ìš´íŠ¸ ë¦¬ì…‹
            };

            // ê²Œì„ ì‹œì‘
            startGame = () => {
                this.canvas.style.filter = 'blur(0px)'; // ìº”ë²„ìŠ¤ ë¸”ëŸ¬ ì œê±°
                document.getElementById('startScreen').style.display = 'none'; // ì‹œì‘ í™”ë©´ ìˆ¨ê¹€
                document.querySelector('.hud').style.display = 'flex'; // HUD í‘œì‹œ (flexë¡œ ë³€ê²½)
                document.getElementById('rewardSelectionScreen').style.display = 'none'; // ë³´ìƒ í™”ë©´ ìˆ¨ê¹€

                // ê²Œì„ ìƒíƒœ ì´ˆê¸°í™” (resetGameê³¼ ìœ ì‚¬)
                this.gameState = {
                    player: {
                        x: this.canvas.width / 2, y: this.canvas.height / 2,
                        width: 40, height: 40,
                        vx: 0, vy: 0,
                        health: 150, maxHealth: 150, // ê¸°ë³¸ê°’ 100ìœ¼ë¡œ ë³€ê²½
                        ammo: 30, maxAmmo: 30, // ê¸°ë³¸ê°’ 100ìœ¼ë¡œ ë³€ê²½
                        speed: 5, jumpPower: 15,
                        onGround: false, facing: 0,
                        expression: ':D',
                        color: this.getRandomPlayerColor(),
                        baseDamage: 10, // ê¸°ë³¸ê°’ 10ìœ¼ë¡œ ë³€ê²½
                        multishot: 1,
                        rapidFireTime: 0,
                        damageReductionFactor: 1,
                        shieldBoostEndTime: 0,
                        healthRegenEndTime: 0,
                        lastRegenTick: 0,
                        magnetEndTime: 0,
                        magnetRadius: 200,
                        lastHitById: null, // ì´ˆê¸°í™”
                        type: 'player', // í”Œë ˆì´ì–´ íƒ€ì…
                        flies: false, // í”Œë ˆì´ì–´ëŠ” ë‚ ì§€ ì•ŠìŒ
                        orbitingKnives: [], // íšŒì „ ì¹¼ë‚  ì´ˆê¸°í™”
                        piercingShot: 0, // ê´€í†µ ì‚¬ê²© ì´ˆê¸°í™”
                        explosiveShot: 0, // í­ë°œ ì‚¬ê²© ì´ˆê¸°í™”
                        ricochetLevel: 0, // ë„íƒ„ ì‚¬ê²© ì´ˆê¸°í™”
                        homingLevel: 0, // ìœ ë„ ì‚¬ê²© ì´ˆê¸°í™”
                        splitLevel: 0, // ë¶„ì—´ ì‚¬ê²© ì´ˆê¸°í™”
                        lifeStealPercent: 0, // ìƒëª…ë ¥ í¡ìˆ˜ ì´ˆê¸°í™”
                        critChance: 0, // ì¹˜ëª…íƒ€ í™•ë¥  ì´ˆê¸°í™”
                        critMultiplier: 1.5, // ì¹˜ëª…íƒ€ ë°°ìœ¨ ì´ˆê¸°í™”
                        cooldownReduction: 0, // ì¬ì‚¬ìš© ëŒ€ê¸°ì‹œê°„ ê°ì†Œ ì´ˆê¸°í™”
                        armor: 0, // ë°©ì–´ë ¥ ì´ˆê¸°í™”
                        timeStopEndTime: 0, // ì‹œê°„ ì •ì§€ ì´ˆê¸°í™”
                        ammoRegenEndTime: 0, // íƒ„ì•½ ì¬ìƒ ì´ˆê¸°í™”
                        lastAmmoRegenTick: 0, // ë§ˆì§€ë§‰ íƒ„ì•½ ì¬ìƒ í‹± ì´ˆê¸°í™”
                        ammoRegenAmount: 0, // íƒ„ì•½ ì¬ìƒëŸ‰ ì´ˆê¸°í™”
                        dashCooldown: 0, // ë§ˆì§€ë§‰ ëŒ€ì‹œ ì‹œê°
                        dashEndTime: 0, // ëŒ€ì‹œ ì¢…ë£Œ ì‹œê°
                        isDashing: false, // ëŒ€ì‹œ ì¤‘ ì—¬ë¶€
                        reloadTime: 1500, // ê¸°ë³¸ ì¬ì¥ì „ ì‹œê°„(ms)
                        isReloading: false,
                        machineGunMode: false, // ê¸°ê´€ë‹¨ì´ íŒ¨ì‹œë¸Œ
                        machineGunPenalty: false, // ê¸°ê´€ë‹¨ì´ íŒ¨ë„í‹°
                        reloadPenalty: 0, // íŒ¨ì‹œë¸Œë¡œ ì¸í•œ ì¶”ê°€ ì¬ì¥ì „ ì‹œê°„(ms)
                        gunRecoil: 0,
                        gunRecoilTarget: 0,
                    },
                    enemies: [],
                    projectiles: [],
                    items: [],
                    particles: [],
                    floatingTexts: [],
                    allies: [], // ì•„êµ° ë°°ì—´ ì´ˆê¸°í™”
                    score: 0,
                    wave: 1,
                    gameStatus: 'playing',
                    message: '',
                    messageTimer: 0,
                    playerSlowedEndTime: 0,
                    timeSlowEndTime: 0,
                    timeSlowEffect: 1
                };
                
                this.spawnInitialWave(); // ì´ˆê¸° ì›¨ì´ë¸Œ ìƒì„±
                this.gameLoop(); // ê²Œì„ ë£¨í”„ ì‹œì‘
                this.updateHUD(); // HUD ì´ˆê¸° ì—…ë°ì´íŠ¸
                this.hideMessage(); // ë©”ì‹œì§€ ìˆ¨ê¸°ê¸°

                // === startGame í•¨ìˆ˜ ë‚´ë¶€ì— ì¶”ê°€ ===
                this.currentWeapon = 'gun'; // ê²Œì„ ì‹œì‘ ì‹œ ë¬´ê¸° ì´ˆê¸°í™”
                this.upgrades = { gun: 0, melee: 0, health: 0, speed: 0, cooldown: 0 };
                
                // ë³´ìŠ¤ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
                this.bossSystem = {
                    isActive: false,
                    currentBoss: null,
                    spawnLock: false
                };
                
                // ê²Œì„ ëª¨ë“œ ì„¤ì • (ì†”ë¡œ í”Œë ˆì´)
                this.gameMode = 'solo';
                
                // ê²Œì„ ì†ë„ ì •ìƒí™”
                this.gameState.timeSlowEffect = 1;
                
                // ë©€í‹°í”Œë ˆì´ì–´ UI ìˆ¨ê¸°ê¸° (ê²Œì„ ì‹œì‘ ì‹œ)
                const roomListPopup = document.getElementById('roomListPopup');
                const roomLobbyPopup = document.getElementById('roomLobbyPopup');
                const enterRoomPopup = document.getElementById('enterRoomPopup');
                const createRoomPopup = document.getElementById('createRoomPopup');
                const multiplayerModeSelect = document.getElementById('multiplayerModeSelect');
                const onlineMultiplayerPopup = document.getElementById('onlineMultiplayerPopup');
                
                if (roomListPopup) roomListPopup.style.display = 'none';
                if (roomLobbyPopup) roomLobbyPopup.style.display = 'none';
                if (enterRoomPopup) enterRoomPopup.style.display = 'none';
                if (createRoomPopup) createRoomPopup.style.display = 'none';
                if (multiplayerModeSelect) multiplayerModeSelect.style.display = 'none';
                if (onlineMultiplayerPopup) onlineMultiplayerPopup.style.display = 'none';
            }
            
            // ë¬´ì‘ìœ„ í‘œì • ë°˜í™˜
            getRandomExpression = () => {
                if (this.EXPRESSIONS && this.EXPRESSIONS.length > 0) {
                    return this.EXPRESSIONS[Math.floor(Math.random() * this.EXPRESSIONS.length)];
                }
                return ':)'; // í‘œì • ë°°ì—´ì´ ë¹„ì–´ìˆëŠ” ê²½ìš°ë¥¼ ìœ„í•œ ê¸°ë³¸ í‘œì •
            }
            
            // ë¬´ì‘ìœ„ í”Œë ˆì´ì–´ ìƒ‰ìƒ ë°˜í™˜
            getRandomPlayerColor = () => {
                const colors = [
                    '#ef4444', // ë¹¨ê°•
                    '#3b82f6', // íŒŒë‘
                    '#10b981', // ì´ˆë¡
                    '#f59e0b', // ì£¼í™©
                    '#8b5cf6', // ë³´ë¼
                    '#ec4899', // ë¶„í™
                    '#06b6d4', // ì²­ë¡
                    '#84cc16', // ì—°ë‘
                    '#f97316', // ì£¼í™©
                    '#6366f1', // ì¸ë””ê³ 
                    '#14b8a6', // ì²­ë¡
                    '#f43f5e'  // ë¡œì¦ˆ
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            // í˜„ì¬ ì›¨ì´ë¸Œì— ë”°ë¼ ì  íƒ€ì… ê²°ì • (ë³´ìŠ¤ ì œê±°)
            getEnemyTypeForWave = (wave) => {
                // ì¼ë°˜ ì›¨ì´ë¸Œ ì  ìƒì„± ë¡œì§
                if (wave <= 2) {
                    return 'basic';
                } else if (wave <= 5) {
                    const rand = Math.random();
                    if (rand < 0.4) return 'basic';
                    else if (rand < 0.7) return 'fast';
                    else return 'jumper';
                } else if (wave <= 8) {
                    const rand = Math.random();
                    if (rand < 0.2) return 'basic';
                    else if (rand < 0.35) return 'fast';
                    else if (rand < 0.5) return 'tank';
                    else if (rand < 0.65) return 'assassin';
                    else if (rand < 0.75) return 'jumper';
                    else if (rand < 0.85) return 'teleporter';
                    else return 'drone';
                } else if (wave <= 12) {
                    const rand = Math.random();
                    if (rand < 0.1) return 'basic';
                    else if (rand < 0.18) return 'fast';
                    else if (rand < 0.26) return 'tank';
                    else if (rand < 0.34) return 'sniper';
                    else if (rand < 0.42) return 'assassin';
                    else if (rand < 0.50) return 'heavy';
                    else if (rand < 0.58) return 'bomber';
                    else if (rand < 0.66) return 'jumper';
                    else if (rand < 0.74) return 'teleporter';
                    else if (rand < 0.82) return 'drone';
                    else if (rand < 0.90) return 'spitter';
                    else return 'berserker';
                } else if (wave <= 15) {
                    const rand = Math.random();
                    if (rand < 0.05) return 'basic';
                    else if (rand < 0.10) return 'fast';
                    else if (rand < 0.15) return 'tank';
                    else if (rand < 0.20) return 'sniper';
                    else if (rand < 0.25) return 'assassin';
                    else if (rand < 0.30) return 'heavy';
                    else if (rand < 0.35) return 'bomber';
                    else if (rand < 0.40) return 'guardian';
                    else if (rand < 0.45) return 'ghost';
                    else if (rand < 0.50) return 'medic';
                    else if (rand < 0.55) return 'summoner';
                    else if (rand < 0.60) return 'jumper';
                    else if (rand < 0.65) return 'shielded';
                    else if (rand < 0.70) return 'teleporter';
                    else if (rand < 0.75) return 'drone';
                    else if (rand < 0.80) return 'spitter';
                    else if (rand < 0.85) return 'berserker';
                    else if (rand < 0.88) return 'mirror';
                    else if (rand < 0.90) return 'leech';
                    else if (rand < 0.92) return 'mine';
                    else if (rand < 0.94) return 'freezer';
                    else if (rand < 0.96) return 'reflector';
                    else if (rand < 0.98) return 'healer';
                    else if (rand < 0.99) return 'portal';
                    else return 'exploder';
                } else {
                    // 15ì›¨ì´ë¸Œ ì´ìƒ: ì‹ ê·œ ì  í™•ë¥  ëŒ€í­ ì¦ê°€
                    const rand = Math.random();
                    if (rand < 0.03) return 'basic';
                    else if (rand < 0.06) return 'fast';
                    else if (rand < 0.09) return 'tank';
                    else if (rand < 0.12) return 'sniper';
                    else if (rand < 0.15) return 'assassin';
                    else if (rand < 0.18) return 'heavy';
                    else if (rand < 0.21) return 'bomber';
                    else if (rand < 0.24) return 'guardian';
                    else if (rand < 0.27) return 'ghost';
                    else if (rand < 0.30) return 'medic';
                    else if (rand < 0.33) return 'summoner';
                    else if (rand < 0.36) return 'jumper';
                    else if (rand < 0.39) return 'shielded';
                    else if (rand < 0.42) return 'teleporter';
                    else if (rand < 0.45) return 'drone';
                    else if (rand < 0.48) return 'spitter';
                    else if (rand < 0.51) return 'berserker';
                    else if (rand < 0.58) return 'mirror';
                    else if (rand < 0.63) return 'leech';
                    else if (rand < 0.68) return 'mine';
                    else if (rand < 0.73) return 'freezer';
                    else if (rand < 0.78) return 'reflector';
                    else if (rand < 0.83) return 'healer';
                    else if (rand < 0.88) return 'portal';
                    else if (rand < 0.93) return 'exploder';
                    else if (rand < 0.96) return 'magnet';
                    else return 'curse';
                }
            }
            
            // ë³´ìŠ¤ ìƒì„± í•¨ìˆ˜
            createBoss = (bossType) => {
                const x = this.canvas.width / 2;
                const y = this.canvas.height / 2 - 100; // í™”ë©´ ì¤‘ì•™ì—ì„œ ì•½ê°„ ìœ„ìª½ì— ìƒì„±
                let bossData = { ...this.ENEMY_TYPES[bossType] };
                
                // ë³´ìŠ¤ ìŠ¤ì¼€ì¼ë§: ì›¨ì´ë¸Œê°€ ì˜¤ë¥¼ìˆ˜ë¡ ê°•í•´ì§
                const scale = 1 + (this.gameState.wave / 10);
                bossData.health = Math.floor(bossData.health * scale);
                bossData.maxHealth = bossData.health;
                bossData.speed = bossData.speed * (1 + (this.gameState.wave / 20));
                bossData.damage = Math.floor(bossData.damage * scale);
                bossData.points = Math.floor(bossData.points * scale);
                
                // ë³´ìŠ¤ ìŠ¤í‚¬ ì¿¨íƒ€ì„ ì´ˆê¸°í™”
                bossData.lastMissile = 0;
                bossData.lastTeleport = 0;
                bossData.lastExplosion = 0;
                bossData.lastSummon = 0;
                bossData.lastShield = 0;
                bossData.lastBlackhole = 0;
                bossData.isInvincible = false;
                bossData.invincibleEndTime = 0;
                
                return {
                    id: Date.now() + Math.random(),
                    type: bossType,
                    x: x, y: y,
                    width: bossData.size, height: bossData.size,
                    vx: 0, vy: 0,
                    health: bossData.health, maxHealth: bossData.health,
                    ammo: 20, maxAmmo: 20,
                    speed: bossData.speed,
                    damage: bossData.damage,
                    jumpPower: 10,
                    onGround: false,
                    facing: 0,
                    expression: this.getRandomExpression(),
                    color: bossData.color,
                    lastShot: 0,
                    shootInterval: bossData.shootInterval,
                    points: bossData.points,
                    // ë³´ìŠ¤ ì „ìš© ì†ì„±
                    lastMissile: 0,
                    lastTeleport: 0,
                    lastExplosion: 0,
                    lastSummon: 0,
                    lastShield: 0,
                    lastBlackhole: 0,
                    isInvincible: false,
                    invincibleEndTime: 0,
                    shieldDuration: bossData.shieldDuration || 0,
                    summonCount: bossData.summonCount || 0,
                    summonType: bossData.summonType || 'basic',
                    healAmount: bossData.healAmount || 0,
                    healCooldown: bossData.healCooldown || 0,
                    lastHeal: 0,
                    barrageCooldown: bossData.barrageCooldown || 0,
                    lastBarrage: 0,
                    dashCooldown: bossData.dashCooldown || 0,
                    lastDash: 0,
                    dashCount: bossData.dashCount || 0,
                    dashDuration: bossData.dashDuration || 0,
                    isDashing: false,
                    shockwaveCooldown: bossData.shockwaveCooldown || 0,
                    lastShockwave: 0,
                    laserCooldown: bossData.laserCooldown || 0,
                    lastLaser: 0,
                    laserDuration: bossData.laserDuration || 0,
                    speedBuffCooldown: bossData.speedBuffCooldown || 0,
                    lastSpeedBuff: 0,
                    speedBuffDuration: bossData.speedBuffDuration || 0,
                    isSpeedBuffed: false,
                    blackholeRadius: bossData.blackholeRadius || 0,
                    slowCooldown: bossData.slowCooldown || 0,
                    lastSlow: 0,
                    slowDuration: bossData.slowDuration || 0,
                    cloneCooldown: bossData.cloneCooldown || 0,
                    lastClone: 0,
                    clones: bossData.clones || 0,
                    hasCloned: false,
                    reflectCooldown: bossData.reflectCooldown || 0,
                    lastReflect: 0,
                    reflectDuration: bossData.reflectDuration || 0,
                    isReflecting: false,
                    drainCooldown: bossData.drainCooldown || 0,
                    lastDrain: 0,
                    drainAmount: bossData.drainAmount || 0,
                    timeWarpCooldown: bossData.timeWarpCooldown || 0,
                    lastTimeWarp: 0,
                    timeWarpDuration: bossData.timeWarpDuration || 0,
                    isTimeWarp: false,
                    rapidFireCooldown: bossData.rapidFireCooldown || 0,
                    lastRapidFire: 0,
                    rapidFireDuration: bossData.rapidFireDuration || 0,
                    isRapidFire: false,
                    randomMoveCooldown: bossData.randomMoveCooldown || 0,
                    lastRandomMove: 0,
                    jumpCount: bossData.jumpCount || 0,
                    jumpPower: bossData.jumpPower || 0,
                    armorBuffCooldown: bossData.armorBuffCooldown || 0,
                    lastArmorBuff: 0,
                    armorBuffDuration: bossData.armorBuffDuration || 0,
                    isArmorBuffed: false,
                    reflectAllCooldown: bossData.reflectAllCooldown || 0,
                    lastReflectAll: 0,
                    reflectAllDuration: bossData.reflectAllDuration || 0,
                    ricochetCooldown: bossData.ricochetCooldown || 0,
                    lastRicochet: 0,
                    ricochetCount: bossData.ricochetCount || 0,
                    trackCooldown: bossData.trackCooldown || 0,
                    lastTrack: 0,
                    trackDuration: bossData.trackDuration || 0,
                    isTracking: false
                };
            }
            
            // ì  ê°ì²´ ìƒì„± (ë³´ìŠ¤ ì œê±°)
            createEnemy = (enemyType = null) => {
                const side = Math.random() < 0.5 ? 'left' : 'right';
                const x = side === 'left' ? -50 : this.canvas.width + 50;
                const y = Math.random() * (this.canvas.height - 200);
                let type = enemyType || this.getEnemyTypeForWave(this.gameState.wave);
                let enemyData = { ...this.ENEMY_TYPES[type] };
                
                // ìŠ¤ì¼€ì¼ë§: ì›¨ì´ë¸Œê°€ ì˜¤ë¥¼ìˆ˜ë¡ ì²´ë ¥/ê³µê²©ë ¥/ì†ë„ ì¦ê°€
                if (this.bossRushMode && type.startsWith('boss')) {
                    // ë³´ìŠ¤ ëŸ¬ì‹œ ëª¨ë“œ: ë³´ìŠ¤ë§Œ ë“±ì¥, ì†ë„ ì¦ê°€ ì™„í™”, ëŠ¥ë ¥ì¹˜ ëŒ€í­ ìƒí–¥
                    const scale = 2.5 * Math.pow(2.5, Math.floor(this.gameState.wave / 10));
                    enemyData.health = Math.floor(enemyData.health * scale);
                    enemyData.maxHealth = enemyData.health;
                    enemyData.speed = enemyData.speed * (1 + (this.gameState.wave / 100)); // ì†ë„ ì¦ê°€ ëŒ€í­ ì™„í™”
                    enemyData.damage = Math.floor(enemyData.damage * scale);
                    enemyData.points = Math.floor(enemyData.points * scale);
                } else if (type.startsWith('boss')) {
                    // ì¼ë°˜ ë³´ìŠ¤ ì›¨ì´ë¸Œ - í›¨ì”¬ ê°•í•˜ê²Œ
                    const scale = 5.0 * Math.pow(2.5, Math.floor(this.gameState.wave / 10));
                    enemyData.health = Math.floor(enemyData.health * scale);
                    enemyData.maxHealth = enemyData.health;
                    enemyData.speed = enemyData.speed * (1 + (this.gameState.wave / 30));
                    enemyData.damage = Math.floor(enemyData.damage * scale);
                    enemyData.points = Math.floor(enemyData.points * scale);
                } else {
                    // ì¼ë°˜ ì 
                    const scale = 1 + (this.gameState.wave - 1) * 0.12;
                    enemyData.health = Math.floor(enemyData.health * scale * 0.8);
                    enemyData.maxHealth = enemyData.health; 
                    enemyData.speed = enemyData.speed * (1 + (this.gameState.wave - 1) * 0.04);
                    enemyData.damage = Math.floor(enemyData.damage * scale * 0.8);
                    enemyData.points = Math.floor(enemyData.points * scale);
                }
                
                // ì‹ ê·œ ì  ë“±ì¥ ë©”ì‹œì§€
                const newTypes = [
                    'mirror','leech','mine','freezer','reflector','healer','portal','exploder','magnet','curse'
                ];
                if (newTypes.includes(type)) {
                    this.showMessage(`${this.ENEMY_TYPES[type].name} ë“±ì¥!`, 'ìƒˆë¡œìš´ ìœ„í˜‘ì´ ë‚˜íƒ€ë‚¬ìŠµë‹ˆë‹¤!', 3000);
                }

                // ì  ê°ì²´ ë°˜í™˜
                return {
                    id: Date.now() + Math.random(), // ê³ ìœ  ID
                    type: type, // ì  íƒ€ì…
                    x: x, y: y, // ìœ„ì¹˜
                    width: enemyData.size, height: enemyData.size, // í¬ê¸°
                    vx: 0, vy: 0, // ì†ë„
                    health: enemyData.health, maxHealth: enemyData.health, // ì²´ë ¥ (maxHealthë„ ë™ì¼í•˜ê²Œ ì„¤ì •)
                    ammo: 20, maxAmmo: 20, // íƒ„ì•½ (ì ì€ ê³ ì •ê°’)
                    speed: enemyData.speed, // ì´ë™ ì†ë„
                    damage: enemyData.damage, // ê³µê²©ë ¥
                    jumpPower: 10, // ì í”„ë ¥ (ì ì€ ê³ ì •ê°’)
                    onGround: false, // ì§€ë©´ ì ‘ì´‰ ì—¬ë¶€
                    facing: 0, // ë°”ë¼ë³´ëŠ” ë°©í–¥
                    expression: this.getRandomExpression(), // í‘œì •
                    color: enemyData.color, // ìƒ‰ìƒ
                    lastShot: 0, // ë§ˆì§€ë§‰ ë°œì‚¬ ì‹œê°„
                    shootInterval: enemyData.shootInterval, // ë°œì‚¬ ê°„ê²©
                    points: enemyData.points, // ì²˜ì¹˜ ì‹œ íšë“ ì ìˆ˜
                    // ìƒˆë¡œìš´ ì  ì „ìš© ì†ì„± ì´ˆê¸°í™”
                    isInvincible: enemyData.isInvincible || false,
                    invincibilityDuration: enemyData.invincibilityDuration || 0,
                    invincibleEndTime: 0,
                    healAmount: enemyData.healAmount || 0,
                    healRadius: enemyData.healRadius || 0,
                    summonCooldown: enemyData.summonCooldown || 0, // ì•ŒíŒŒ ë³´ìŠ¤
                    lastSummon: enemyData.lastSummon || 0, // ì•ŒíŒŒ ë³´ìŠ¤
                    summonCount: enemyData.summonCount || 0, // ì•ŒíŒŒ ë³´ìŠ¤
                    summonType: enemyData.summonType || 'basic', // ì•ŒíŒŒ ë³´ìŠ¤
                    shieldCooldown: enemyData.shieldCooldown || 0, // ë² íƒ€ ë³´ìŠ¤
                    lastShield: enemyData.lastShield || 0, // ë² íƒ€ ë³´ìŠ¤
                    shieldDuration: enemyData.shieldDuration || 0, // ë² íƒ€ ë³´ìŠ¤
                    burstProjectiles: enemyData.burstProjectiles || 0, // ë² íƒ€ ë³´ìŠ¤
                    burstDamage: enemyData.burstDamage || 0, // ë² íƒ€ ë³´ìŠ¤
                    teleportStrikeCooldown: enemyData.teleportStrikeCooldown || 0, // ê°ë§ˆ ë³´ìŠ¤
                    lastTeleportStrike: enemyData.lastTeleportStrike || 0, // ê°ë§ˆ ë³´ìŠ¤
                    teleportRange: enemyData.teleportRange || 0, // ê°ë§ˆ ë³´ìŠ¤
                    jumpCooldown: enemyData.jumpCooldown || 0,
                    lastJump: enemyData.lastJump || 0,
                    flies: enemyData.flies || false, // ë“œë¡ 
                    slowEffect: enemyData.slowEffect || 0, // ì¹¨ë±‰ëŠ”ë³‘
                    slowDuration: enemyData.slowDuration || 0,
                    rageThreshold: enemyData.rageThreshold || 0, // ê´‘ì „ì‚¬
                    rageSpeedBoost: enemyData.rageSpeedBoost || 1,
                    rageDamageBoost: enemyData.rageDamageBoost || 1,
                    isRaging: false, // ê´‘ì „ì‚¬ ìƒíƒœ
                    // ìƒˆë¡œìš´ ì  10ì¢… ìŠ¤í‚¬ ì¿¨ë‹¤ìš´ ì´ˆê¸°í™”
                    lastTimeReverse: 0, // íƒ€ì„í‚¤í¼
                    lastTimeAccel: 0, // íƒ€ì„í‚¤í¼
                    lastGravity: 0, // ê·¸ë˜ë¹„í‹°
                    lastAntiGravity: 0, // ê·¸ë˜ë¹„í‹°
                    lastEcho: 0, // ì—ì½”
                    lastSonicWave: 0, // ì—ì½”
                    lastVortex: 0, // ë³´ë¥´í…ìŠ¤
                    lastWhirlwind: 0, // ë³´ë¥´í…ìŠ¤
                    lastPrism: 0, // í”„ë¦¬ì¦˜
                    lastLaser: 0, // í”„ë¦¬ì¦˜
                    lastQuantum: 0, // í€€í…€
                    lastQuantumSplit: 0, // í€€í…€
                    lastCrystal: 0, // í¬ë¦¬ìŠ¤íƒˆ
                    lastCrystalShard: 0, // í¬ë¦¬ìŠ¤íƒˆ
                    lastPlasma: 0, // í”Œë¼ì¦ˆë§ˆ
                    lastPlasmaExplosion: 0, // í”Œë¼ì¦ˆë§ˆ
                    lastNebula: 0, // ë„¤ë·¸ë¼
                    lastStarExplosion: 0 // ë„¤ë·¸ë¼
                };
            }

            // ì•„êµ° ë“œë¡  ìƒì„±
            spawnAlly = (x, y) => {
                this.gameState.allies.push({
                    id: Date.now() + Math.random(),
                    type: 'ally',
                    x: x, y: y,
                    width: 25, height: 25,
                    vx: 0, vy: 0,
                    health: 70, maxHealth: 70,
                    speed: 5,
                    damage: 10, // 25 -> 10
                    color: '#90ee90',
                    lastShot: 0,
                    shootInterval: 600,
                    onGround: false,
                    facing: 0,
                    expression: this.getRandomExpression(),
                    flies: true
                });
            }
            
            // ì•„ì´í…œ ê°ì²´ ìƒì„±
            createItem = (x, y) => {
                const itemType = this.ITEM_TYPES[Math.floor(Math.random() * this.ITEM_TYPES.length)]; // ë¬´ì‘ìœ„ ì•„ì´í…œ íƒ€ì… ì„ íƒ
                return {
                    id: Date.now() + Math.random(), // ê³ ìœ  ID
                    x: x, y: y, // ìœ„ì¹˜
                    width: 20, height: 20, // í¬ê¸°
                    vx: (Math.random() - 0.5) * 4, // ìˆ˜í‰ ì´ˆê¸° ì†ë„ (ë¬´ì‘ìœ„)
                    vy: -Math.random() * 8 - 5, // ìœ„ë¡œ íŠ€ì–´ë‚˜ì˜¤ëŠ” ì´ˆê¸° ì†ë„ (ë¬´ì‘ìœ„)
                    onGround: false, // ì§€ë©´ ì ‘ì´‰ ì—¬ë¶€
                    type: itemType.type, // ì•„ì´í…œ íƒ€ì…
                    effect: itemType.effect, // ì•„ì´í…œ íš¨ê³¼ëŸ‰
                    color: itemType.color, // ì•„ì´í…œ ìƒ‰ìƒ
                    emoji: itemType.emoji, // ì•„ì´í…œ ì´ëª¨ì§€
                    bobOffset: Math.random() * Math.PI * 2, // ë– ë‹¤ë‹ˆëŠ” ì• ë‹ˆë©”ì´ì…˜ ì˜¤í”„ì…‹
                    collected: false, // ìˆ˜ì§‘ ì—¬ë¶€
                    duration: itemType.duration || 0, // ì•„ì´í…œ ì§€ì† ì‹œê°„ (ìƒˆë¡œìš´ ì•„ì´í…œìš©)
                    tickInterval: itemType.tickInterval || 0 // ì²´ë ¥ ì¬ìƒ ë“± ì£¼ê¸°ì  íš¨ê³¼ìš©
                };
            }
            
            // í”Œë ˆì´ì–´ ë°œì‚¬ ë¡œì§
            shoot = () => {
                const player = this.gameState.player;
                if (player.isReloading || this.gameState.player1Dead) return;
                if (this.currentWeapon === 'gun') {
                    if (player.ammo <= 0) {
                        this.reload();
                        return;
                    }
                    const now = Date.now();
                    let shootInterval = 200;
                    if (player.machineGunMode) shootInterval = 60;
                    if (player.rapidFireTime && now < player.rapidFireTime) shootInterval = 100;
                    shootInterval *= (1 - player.cooldownReduction);
                    if (player.lastShot && now - player.lastShot < shootInterval) return;
                    const startX = player.x + player.width / 2;
                    const startY = player.y + player.height / 2;
                    const angle = Math.atan2(this.mouse.y - startY, this.mouse.x - startX);
                    let speed = player.machineGunMode ? 16 : 12;
                    let damage = player.baseDamage;
                    let isCritical = false;
                    if (Math.random() < player.critChance) {
                        damage *= player.critMultiplier;
                        isCritical = true;
                    }
                    if (player.machineGunMode) damage *= 0.5;
                    if (player.machineGunPenalty) damage *= 0.5;
                    if (player.homingLevel >= 3 && player.homingPenalty) damage *= 0.95;
                    const multishot = player.multishot;
                    const actualMultishot = Math.min(multishot, 4);
                    for (let i = 0; i < actualMultishot; i++) {
                        const spreadAngle = angle + (i - (actualMultishot - 1) / 2) * 0.2;
                        let baseLife = 120;
                        let ricochetBonus = player.ricochetLevel ? player.ricochetLevel * 30 : 0;
                        let projectileLife = baseLife + ricochetBonus;
                        this.gameState.projectiles.push({
                            id: Date.now() + Math.random() + i,
                            x: startX, y: startY,
                            vx: Math.cos(spreadAngle) * speed,
                            vy: Math.sin(spreadAngle) * speed,
                            radius: player.machineGunMode ? 2 : 3,
                            damage: damage,
                            life: projectileLife,
                            color: player.machineGunMode ? '#aaa' : (player.rapidFireTime && now < player.rapidFireTime ? '#ff6b00' : '#fbbf24'),
                            ownerId: 'player',
                            pierceCount: player.piercingShot,
                            explosiveRadius: player.explosiveShot > 0 ? (80 + player.explosiveShot * 20) : 0,
                            bounceCount: player.ricochetLevel,
                            isHoming: player.homingLevel > 0,
                            homingStrength: player.homingLevel > 0 ? (0.03 + player.homingLevel * 0.005) : 0,
                            splitCount: player.splitLevel,
                            isCritical: isCritical,
                            hitEnemies: []
                        });
                    }
                    // ê¸°ê´€ë‹¨ì´ íŒ¨ë„í‹°: 4ë°œë‹¹ íƒ„ì•½ 1 ì†Œëª¨
                    if (player.machineGunMode) {
                        player.ammo -= 0.25;
                        if (player.ammo < 0) player.ammo = 0;
                    } else {
                        player.ammo--;
                    }
                    // ì´ ë°˜ë™ íš¨ê³¼ ì¶”ê°€
                    player.gunRecoilTarget = 15; // ë°˜ë™ ëª©í‘œê°’ ì„¤ì •
                    
                    player.lastShot = now;
                    this.updateHUD();
                } else if (this.currentWeapon === 'melee') {
                    const range = 70;
                    const damage = player.baseDamage * 4;
                    let hit = false;
                    this.gameState.enemies.forEach(enemy => {
                        const dx = (enemy.x + enemy.width/2) - (player.x + player.width/2);
                        const dy = (enemy.y + enemy.height/2) - (player.y + player.height/2);
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < range) {
                            enemy.health = Math.max(0, enemy.health - damage);
                            this.createFloatingText(enemy.x + enemy.width/2, enemy.y, `-${damage}`, 'orange');
                            this.createHitParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                            if (enemy.health <= 0) {
                                this.addScore(enemy.points || 100);
                                if (Math.random() < 0.4) this.gameState.items.push(this.createItem(enemy.x, enemy.y));
                                
                                // ë³´ìŠ¤ê°€ ì£½ìœ¼ë©´ ì‹œìŠ¤í…œ ë¦¬ì…‹
                                if (enemy.type && enemy.type.startsWith('boss')) {
                                    if (this.bossSystem && this.bossSystem.currentBoss && this.bossSystem.currentBoss.id === enemy.id) {
                                        this.bossSystem.currentBoss = null;
                                    }
                                    this.checkBossWaveComplete(); // â† ë¨¼ì € í˜¸ì¶œ
                                    this.resetBossSystem();
                                }
                                
                                this.gameState.enemies = this.gameState.enemies.filter(e => e !== enemy);
                            }
                            hit = true;
                        }
                    });
                    if (hit) this.showMessage('ì¹¼ ê³µê²©!', '', 600);
                }
            }

            tryDash = () => {
                const player = this.gameState.player;
                const now = Date.now();
                // ì¿¨íƒ€ì„ 1ì´ˆ (1000ms)
                if (player.isDashing) return;
                if (now - player.dashCooldown < 1000) return;

                player.isDashing = true;
                player.dashCooldown = now;

                // ëŒ€ì‹œ ë°©í–¥: ë°”ë¼ë³´ëŠ” ë°©í–¥(facing)ìœ¼ë¡œ ë¹ ë¥´ê²Œ ì´ë™
                const dashPower = 25;
                player.vx += Math.cos(player.facing) * dashPower;
                player.vy += Math.sin(player.facing) * dashPower;

                // 0.2ì´ˆ í›„ ë¬´ì  í•´ì œ
                setTimeout(() => {
                    player.isDashing = false;
                }, 200);
            };

            // í€˜ìŠ¤íŠ¸ ìƒì„±
            generateQuest = () => {
                const questType = this.questSystem.questTypes[Math.floor(Math.random() * this.questSystem.questTypes.length)];
                let target = 0;
                
                switch (questType.type) {
                    case 'wave':
                        target = this.gameState.wave + Math.floor(Math.random() * 5) + 3; // í˜„ì¬ ì›¨ì´ë¸Œ + 3~7
                        break;
                    case 'score':
                        target = this.gameState.score + Math.floor(Math.random() * 2000) + 1000; // í˜„ì¬ ì ìˆ˜ + 1000~3000
                        break;
                    case 'boss_kill':
                        target = Math.floor(Math.random() * 3) + 1; // 1~3ë§ˆë¦¬
                        break;
                    case 'enemy_kill':
                        target = Math.floor(Math.random() * 20) + 10; // 10~30ë§ˆë¦¬
                        break;
                    case 'item_collect':
                        target = Math.floor(Math.random() * 10) + 5; // 5~15ê°œ
                        break;
                }
                
                return {
                    id: Date.now() + Math.random(),
                    type: questType.type,
                    name: questType.name,
                    description: questType.description.replace('{target}', target),
                    target: target,
                    current: 0,
                    rewards: questType.rewards,
                    completed: false
                };
            };

            // í€˜ìŠ¤íŠ¸ ì§„í–‰ë„ ì—…ë°ì´íŠ¸
            updateQuestProgress = (type, amount = 1) => {
                this.questSystem.activeQuests.forEach(quest => {
                    if (quest.type === type && !quest.completed) {
                        quest.current += amount;
                        if (quest.current >= quest.target) {
                            this.completeQuest(quest);
                        }
                    }
                });
            };

            // í€˜ìŠ¤íŠ¸ ì™„ë£Œ
            completeQuest = (quest) => {
                quest.completed = true;
                quest.current = quest.target;
                
                // ë³´ìƒ ì§€ê¸‰
                if (quest.rewards.score) {
                    this.gameState.score += quest.rewards.score;
                }
                if (quest.rewards.health) {
                    this.gameState.player.health = Math.min(this.gameState.player.maxHealth, this.gameState.player.health + quest.rewards.health);
                }
                if (quest.rewards.ammo) {
                    this.gameState.player.ammo = Math.min(this.gameState.player.maxAmmo, this.gameState.player.ammo + quest.rewards.ammo);
                }
                
                // ì™„ë£Œëœ í€˜ìŠ¤íŠ¸ ì´ë™
                this.questSystem.completedQuests.push(quest);
                this.questSystem.activeQuests = this.questSystem.activeQuests.filter(q => q.id !== quest.id);
                
                // ì™„ë£Œ ë©”ì‹œì§€ í‘œì‹œ
                this.showMessage(`í€˜ìŠ¤íŠ¸ ì™„ë£Œ!`, `${quest.name}: ${quest.rewards.score}ì  íšë“!`, 3000);
                
                // ìƒˆë¡œìš´ í€˜ìŠ¤íŠ¸ ìƒì„±
                if (this.questSystem.activeQuests.length < 3) {
                    this.questSystem.activeQuests.push(this.generateQuest());
                }
                
                this.updateQuestUI();
            };

            // í€˜ìŠ¤íŠ¸ UI ì—…ë°ì´íŠ¸
            updateQuestUI = () => {
                const questList = document.getElementById('questList');
                if (!questList) return;
                
                let questHTML = '';
                this.questSystem.activeQuests.forEach(quest => {
                    const progress = Math.min(100, (quest.current / quest.target) * 100);
                    const status = quest.completed ? 'âœ…' : 'â³';
                    questHTML += `
                        <div style="margin-bottom: 10px; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 5px;">
                            <div style="font-weight: bold; color: ${quest.completed ? '#4ade80' : '#fbbf24'};">${status} ${quest.name}</div>
                            <div style="font-size: 12px; margin: 5px 0;">${quest.description}</div>
                            <div style="font-size: 11px; color: #a1a1aa;">ì§„í–‰ë„: ${quest.current}/${quest.target} (${progress.toFixed(1)}%)</div>
                            <div style="width: 100%; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; margin-top: 5px;">
                                <div style="width: ${progress}%; height: 100%; background: ${quest.completed ? '#4ade80' : '#fbbf24'}; border-radius: 2px; transition: width 0.3s;"></div>
                            </div>
                        </div>
                    `;
                });
                
                if (this.questSystem.activeQuests.length === 0) {
                    questHTML = '<div style="color: #a1a1aa; text-align: center; padding: 20px;">í™œì„± í€˜ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤</div>';
                }
                
                questList.innerHTML = questHTML;
            };

            reload = () => {
                const player = this.gameState.player;
                if (player.isReloading) return;
                if (player.ammo >= player.maxAmmo) return; // ì´ë¯¸ ê°€ë“ ì°¬ ê²½ìš° ì¬ì¥ì „ ì•ˆí•¨
                
                player.isReloading = true;
                player.gunRecoilTarget = 18;
                let reloadTime = player.reloadTime + player.reloadPenalty;
                this.showMessage('ì¬ì¥ì „ ì¤‘...', '', reloadTime);
                
                // ì¬ì¥ì „ ì¤‘ì—ëŠ” ë°œì‚¬ ë¶ˆê°€
                setTimeout(() => {
                    player.ammo = player.maxAmmo;
                    player.isReloading = false;
                    player.gunRecoilTarget = 0;
                    this.updateHUD();
                    this.showMessage('ì¬ì¥ì „ ì™„ë£Œ!', '', 1000);
                }, reloadTime);
            }
            
            // ìˆ˜ë¥˜íƒ„ íˆ¬ì²™ ë¡œì§
            throwGrenade = () => {
                const player = this.gameState.player;
                const now = Date.now();
                // ìˆ˜ë¥˜íƒ„ ì¿¨íƒ€ì„ (ì˜ˆì‹œ: 2ì´ˆ)
                if (player.lastGrenade && now - player.lastGrenade < 2000) return;

                const startX = player.x + player.width / 2;
                const startY = player.y + player.height / 2;
                const angle = Math.atan2(this.mouse.y - startY, this.mouse.x - startX);
                const speed = 10; // ìˆ˜ë¥˜íƒ„ íˆ¬ì²™ ì†ë„
                const grenadeLife = 60; // ìˆ˜ë¥˜íƒ„ ìˆ˜ëª… (í”„ë ˆì„)
                const explosionDelay = 40; // í­ë°œê¹Œì§€ì˜ ë”œë ˆì´ (í”„ë ˆì„)

                this.gameState.projectiles.push({
                    id: Date.now() + Math.random(),
                    x: startX, y: startY,
                    vx: (Math.cos(angle) * speed) * this.gameState.timeSlowEffect, // ì‹œê°„ ë‘”í™” ì˜í–¥ ë°›ìŒ
                    vy: (Math.sin(angle) * speed) * this.gameState.timeSlowEffect, // ì‹œê°„ ë‘”í™” ì˜í–¥ ë°›ìŒ
                    radius: 8, // ìˆ˜ë¥˜íƒ„ í¬ê¸°
                    damage: 0, // ì§ì ‘ ë°ë¯¸ì§€ ì—†ìŒ (í­ë°œ ë°ë¯¸ì§€)
                    life: grenadeLife,
                    color: '#6b7280',
                    ownerId: 'player',
                    isGrenade: true, // ìˆ˜ë¥˜íƒ„ì„ì„ ë‚˜íƒ€ë‚´ëŠ” í”Œë˜ê·¸
                    explosionRadius: 150, // í­ë°œ ë²”ìœ„
                    explosionDamage: 70, // í­ë°œ ë°ë¯¸ì§€
                    explosionDelay: explosionDelay // í­ë°œ ë”œë ˆì´
                });
                player.lastGrenade = now;
            }
            
            // ì›¨ì´ë¸Œ ìƒì„± (ìƒˆë¡œìš´ ë³´ìŠ¤ ì‹œìŠ¤í…œ)
            spawnInitialWave = () => {
                // ê²Œì„ ìƒíƒœê°€ spawningì´ ì•„ë‹ˆë©´ ì›¨ì´ë¸Œ ìƒì„± ì•ˆí•¨
                if (this.gameState.gameStatus !== 'spawning' && this.gameState.gameStatus !== 'playing') return;
                
                // í…ŒìŠ¤íŒ… ì¡´ì—ì„œëŠ” ìë™ ì†Œí™˜ ì•ˆí•¨
                if (this.gameMode === 'testzone') return;
                
                // ë©€í‹°í”Œë ˆì´ì–´ ëª¨ë“œì—ì„œëŠ” ë°©ì¥ë§Œ ì›¨ì´ë¸Œ ìƒì„±
                if (this.gameState.multiplayerMode && !this.gameState.isHost) {
                    return;
                }
                
                // ì´ë¯¸ ì›¨ì´ë¸Œ ìƒì„± ì¤‘ì´ë©´ ìŠ¤í‚µ
                if (this.gameState.gameStatus === 'spawning' || this.gameState.waveSpawning) {
                    return;
                }
                
                // ë³´ìŠ¤ ì›¨ì´ë¸Œ ì²´í¬ (10ì˜ ë°°ìˆ˜)
                if (this.gameState.wave % 10 === 0) {
                    this.spawnBossWave();
                } else {
                    this.spawnNormalWave();
                }
            }
            
            // ë³´ìŠ¤ ì›¨ì´ë¸Œ ìƒì„±
            spawnBossWave = () => {
                // ì´ë¯¸ ë³´ìŠ¤ê°€ í™œì„±í™”ë˜ì–´ ìˆìœ¼ë©´ ìŠ¤í‚µ
                if (!this.bossSystem || this.bossSystem.isActive || this.bossSystem.spawnLock) {
                    return;
                }
                
                // ì´ë¯¸ ìŠ¤í° ì¤‘ì´ë©´ ìŠ¤í‚µ
                if (this.gameState.waveSpawning) return;
                this.gameState.waveSpawning = true;
                
                // ë³´ìŠ¤ ìŠ¤í° ë½ ì„¤ì •
                this.bossSystem.spawnLock = true;
                this.bossSystem.isActive = true;
                
                // ë³´ìŠ¤ íƒ€ì… ì„ íƒ
                const bossTypes = ['boss_alpha', 'boss_beta', 'boss_gamma', 'boss_delta', 'boss_epsilon', 'boss_zeta', 'boss_eta', 'boss_theta'];
                const bossType = bossTypes[Math.floor(Math.random() * bossTypes.length)];
                
                // ë³´ìŠ¤ ìƒì„±
                const boss = this.createBoss(bossType);
                this.bossSystem.currentBoss = boss;
                this.gameState.enemies.push(boss);
                
                // ë³´ìŠ¤ ë“±ì¥ ë©”ì‹œì§€
                const bossData = this.ENEMY_TYPES[bossType];
                this.showMessage(`${bossData.name} ë“±ì¥!`, 'ê°•ë ¥í•œ ë³´ìŠ¤ê°€ ë‚˜íƒ€ë‚¬ìŠµë‹ˆë‹¤!', 2000);
                
                console.log(`ë³´ìŠ¤ ì›¨ì´ë¸Œ ${this.gameState.wave} ì‹œì‘: ${bossData.name}`);
                console.log(`ë³´ìŠ¤ ìƒì„±ë¨: ${bossData.name}, ìœ„ì¹˜: (${boss.x}, ${boss.y}), ì²´ë ¥: ${boss.health}`);
                console.log(`í˜„ì¬ ì  ìˆ˜: ${this.gameState.enemies.length}`);
                
                // ë³´ìŠ¤ ìŠ¤í° ì™„ë£Œ í›„ í”Œë˜ê·¸ í•´ì œ
                setTimeout(() => {
                    this.gameState.waveSpawning = false;
                }, 2000);
            }
            
            // ì¼ë°˜ ì›¨ì´ë¸Œ ìƒì„±
            spawnNormalWave = () => {
                // ì´ë¯¸ ìŠ¤í° ì¤‘ì´ë©´ ìŠ¤í‚µ
                if (this.gameState.waveSpawning) return;
                this.gameState.waveSpawning = true;
                
                // ì  ìˆ˜ ê²°ì • (ë” ë§ì´ ìŠ¤í°)
                let enemyCount;
                if (this.gameState.wave === 1) {
                    enemyCount = 5;
                } else if (this.gameState.wave === 2) {
                    enemyCount = 7;
                } else if (this.gameState.wave === 3) {
                    enemyCount = 9;
                } else if (this.gameState.wave <= 10) {
                    enemyCount = Math.min(12, 9 + (this.gameState.wave - 3));
                } else if (this.gameState.wave <= 15) {
                    enemyCount = Math.min(15, 12 + (this.gameState.wave - 10));
                } else {
                    enemyCount = Math.min(18, 15 + (this.gameState.wave - 15));
                }
                
                // ì  ìƒì„±
                for (let i = 0; i < enemyCount; i++) {
                    setTimeout(() => {
                        let type = undefined;
                        if (this.gameState.wave >= 2 && Math.random() < 0.2) type = 'fast';
                        if (this.gameState.wave >= 3 && Math.random() < 0.15) type = 'tank';
                        if (this.gameState.wave >= 4 && Math.random() < 0.1) type = 'sniper';
                        if (this.gameState.wave >= 5 && Math.random() < 0.1) type = 'bomber';
                        if (this.gameState.wave >= 6 && Math.random() < 0.08) type = 'guardian';
                        if (this.gameState.wave >= 7 && Math.random() < 0.08) type = 'assassin';
                        if (this.gameState.wave >= 8 && Math.random() < 0.08) type = 'heavy';
                        if (this.gameState.wave >= 9 && Math.random() < 0.06) type = 'ghost';
                        if (this.gameState.wave >= 10 && Math.random() < 0.06) type = 'medic';
                        if (this.gameState.wave >= 11 && Math.random() < 0.06) type = 'summoner';
                        if (this.gameState.wave >= 12 && Math.random() < 0.06) type = 'jumper';
                        if (this.gameState.wave >= 13 && Math.random() < 0.06) type = 'shielded';
                        if (this.gameState.wave >= 14 && Math.random() < 0.06) type = 'teleporter';
                        if (this.gameState.wave >= 15 && Math.random() < 0.06) type = 'drone';
                        if (this.gameState.wave >= 15 && Math.random() < 0.06) type = 'spitter';
                        if (this.gameState.wave >= 15 && Math.random() < 0.06) type = 'berserker';
                        if (this.gameState.wave >= 15 && Math.random() < 0.05) type = 'leech';
                        if (this.gameState.wave >= 15 && Math.random() < 0.05) type = 'mine';
                        if (this.gameState.wave >= 15 && Math.random() < 0.05) type = 'freezer';
                        if (this.gameState.wave >= 15 && Math.random() < 0.05) type = 'reflector';
                        if (this.gameState.wave >= 16 && Math.random() < 0.05) type = 'healer';
                        if (this.gameState.wave >= 16 && Math.random() < 0.05) type = 'portal';
                        if (this.gameState.wave >= 16 && Math.random() < 0.05) type = 'exploder';
                        if (this.gameState.wave >= 16 && Math.random() < 0.05) type = 'magnet';
                        if (this.gameState.wave >= 20 && Math.random() < 0.05) type = 'curse';
                        if (this.gameState.wave >= 20 && Math.random() < 0.05) type = 'floater';
                        if (this.gameState.wave >= 16 && Math.random() < 0.05) type = 'phaser';
                        if (this.gameState.wave >= 16 && Math.random() < 0.04) type = 'ninja';
                        if (this.gameState.wave >= 17 && Math.random() < 0.04) type = 'sniper';
                        if (this.gameState.wave >= 18 && Math.random() < 0.04) type = 'berserker';
                        if (this.gameState.wave >= 19 && Math.random() < 0.04) type = 'summoner';
                        if (this.gameState.wave >= 20 && Math.random() < 0.04) type = 'guardian';
                        if (this.gameState.wave >= 16 && Math.random() < 0.04) type = 'assassin';
                        if (this.gameState.wave >= 17 && Math.random() < 0.04) type = 'heavy';
                        if (this.gameState.wave >= 18 && Math.random() < 0.04) type = 'bomber';
                        if (this.gameState.wave >= 19 && Math.random() < 0.04) type = 'medic';
                        if (this.gameState.wave >= 20 && Math.random() < 0.04) type = 'drone';
                        if (this.gameState.wave >= 16 && Math.random() < 0.03) type = 'timekeeper';
                        if (this.gameState.wave >= 17 && Math.random() < 0.03) type = 'gravity';
                        if (this.gameState.wave >= 18 && Math.random() < 0.03) type = 'echo';
                        if (this.gameState.wave >= 19 && Math.random() < 0.03) type = 'vortex';
                        if (this.gameState.wave >= 20 && Math.random() < 0.03) type = 'prism';
                        if (this.gameState.wave >= 16 && Math.random() < 0.03) type = 'quantum';
                        if (this.gameState.wave >= 17 && Math.random() < 0.03) type = 'crystal';
                        if (this.gameState.wave >= 18 && Math.random() < 0.03) type = 'plasma';
                        if (this.gameState.wave >= 19 && Math.random() < 0.03) type = 'nebula';
                        this.gameState.enemies.push(this.createEnemy(type));
                    }, i * 500);
                }
                
                // ì•„ì´í…œ ìƒì„±
                const totalItemCount = Math.min(6, Math.floor(this.gameState.wave / 2) + 3);
                let ammoItemCount = 0;
                if (this.gameState.wave >= 3) {
                    ammoItemCount = 1;
                }
                
                for (let i = 0; i < totalItemCount; i++) {
                    setTimeout(() => {
                        let itemToCreate;
                        if (Math.random() < 0.06) { 
                            itemToCreate = this.ITEM_TYPES.find(item => item.type === 'ally_summon');
                        } else if (ammoItemCount > 0 && Math.random() < 0.5) {
                            itemToCreate = this.ITEM_TYPES.find(item => item.type === 'ammo');
                            ammoItemCount--;
                        } else if (Math.random() < 0.15) {
                            itemToCreate = this.ITEM_TYPES.find(item => item.type === 'multishot');
                        } else if (Math.random() < 0.1) {
                            itemToCreate = this.ITEM_TYPES.find(item => item.type === 'health');
                        } else {
                            const nonSpecialItems = this.ITEM_TYPES.filter(item => item.type !== 'ammo' && item.type !== 'ally_summon' && item.type !== 'multishot' && item.type !== 'health');
                            itemToCreate = nonSpecialItems[Math.floor(Math.random() * nonSpecialItems.length)];
                        }
                        
                        const item = this.createItem(
                            Math.random() * (this.canvas.width - 40) + 20,
                            Math.random() * (this.canvas.height - 200) + 50
                        );
                        
                        item.type = itemToCreate.type;
                        item.effect = itemToCreate.effect;
                        item.color = itemToCreate.color;
                        item.emoji = itemToCreate.emoji;
                        item.duration = itemToCreate.duration || 0;
                        item.tickInterval = itemToCreate.tickInterval || 0;
                        
                        this.gameState.items.push(item);
                    }, i * 3000);
                }
                
                console.log(`ì¼ë°˜ ì›¨ì´ë¸Œ ${this.gameState.wave} ì‹œì‘: ${enemyCount}ë§ˆë¦¬`);
                
                // ì›¨ì´ë¸Œ ìŠ¤í° ì™„ë£Œ í›„ í”Œë˜ê·¸ í•´ì œ
                setTimeout(() => {
                    this.gameState.waveSpawning = false;
                }, enemyCount * 500 + 1000);
            }
            
            // ìºë¦­í„° (í”Œë ˆì´ì–´ ë° ì ) ìƒíƒœ ì—…ë°ì´íŠ¸ (ìƒˆë¡œìš´ ì  AI ë¡œì§ ì¶”ê°€)
            updateCharacter = (character) => {
                const now = Date.now();
                // player ë³€ìˆ˜ë¥¼ í•¨ìˆ˜ ì‹œì‘ ë¶€ë¶„ì—ì„œ ì •ì˜í•˜ì—¬ ëª¨ë“  ì¡°ê±´ë¬¸ì—ì„œ ì ‘ê·¼ ê°€ëŠ¥í•˜ë„ë¡ í•¨
                const player = this.gameState.player; 

                // í”Œë ˆì´ì–´ ë‘”í™” íš¨ê³¼ í•´ì œ
                if (character === player) { // character === this.gameState.player ëŒ€ì‹  player ì‚¬ìš©
                    if (now > this.gameState.playerSlowedEndTime) {
                        character.speed = 5; // ê¸°ë³¸ ì†ë„ë¡œ ë³µê·€
                        // ì†ë„ ë²„ê·¸ ë°©ì§€: ì¶”ê°€ ê²€ì¦
                        if (character.speed > 10) character.speed = 5;
                        if (character.speed < 1) character.speed = 5;
                    }
                    // ì²´ë ¥ ì¬ìƒ íš¨ê³¼
                    if (now < character.healthRegenEndTime && now - character.lastRegenTick > character.tickInterval) {
                        character.health = Math.min(character.maxHealth, character.health + character.effect);
                        this.createFloatingText(character.x + character.width / 2, character.y, `+${character.effect}`, 'lime');
                        character.lastRegenTick = now;
                    }
                    // íƒ„ì•½ ì¬ìƒ íš¨ê³¼
                    if (now < character.ammoRegenEndTime && now - character.lastAmmoRegenTick > character.tickInterval) {
                        character.ammo = Math.min(character.maxAmmo, character.ammo + character.ammoRegenAmount);
                        this.createFloatingText(character.x + character.width / 2, character.y + 20, `+${character.ammoRegenAmount} íƒ„ì•½`, 'yellow');
                        character.lastAmmoRegenTick = now;
                    }
                }

                // ì¤‘ë ¥ ì ìš© (ë“œë¡ ì€ ì¤‘ë ¥ ë¬´ì‹œ)
                if (!character.onGround && !character.flies) {
                    character.vy += this.GRAVITY;
                }
                
                // ì§€ë©´ ì¶©ëŒ ì²˜ë¦¬ (ë“œë¡ ì€ ì§€ë©´ ì¶©ëŒ ì—†ìŒ)
                if (!character.flies && character.y + character.height > this.canvas.height - this.GROUND_Y) {
                    character.y = this.canvas.height - this.GROUND_Y - character.height;
                    character.vy = 0;
                    character.onGround = true;
                } else if (!character.flies) {
                    character.onGround = false;
                }
                
                // ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (ì‹œê°„ ì •ì§€ íš¨ê³¼ ì ìš©)
                if (this.gameState.timeSlowEffect > 0) { // ì‹œê°„ì´ ì™„ì „íˆ ë©ˆì¶”ì§€ ì•Šì•˜ì„ ë•Œë§Œ ì´ë™
                    character.x += character.vx * this.gameState.timeSlowEffect;
                    character.y += character.vy * this.gameState.timeSlowEffect;
                }
                
                // ë§ˆì°° ì ìš©
                character.vx *= this.FRICTION;
                
                // í™”ë©´ ê²½ê³„ ì œí•œ
                character.x = Math.max(0, Math.min(this.canvas.width - character.width, character.x));
                // ë“œë¡ ì€ Yì¶•ë„ í™”ë©´ ê²½ê³„ ì œí•œ (ìƒë‹¨)
                if (character.flies) {
                    character.y = Math.max(50, Math.min(this.canvas.height - this.GROUND_Y - character.height, character.y));
                }

                // í”Œë ˆì´ì–´ ì…ë ¥ ì²˜ë¦¬
                if (character === player) { // character === this.gameState.player ëŒ€ì‹  player ì‚¬ìš©
                    // í”Œë ˆì´ì–´1ì´ ì£½ì–´ìˆìœ¼ë©´ ì…ë ¥ ì²˜ë¦¬ ì•ˆí•¨
                    if (this.gameState.player1Dead) return;
                    
                    const currentSpeed = character.speed * (now > this.gameState.playerSlowedEndTime ? 1 : this.gameState.playerSlowEffect || 1);
                    
                    // í‚¤ë³´ë“œ ì…ë ¥ ì²˜ë¦¬
                    if (this.keys['a']) character.vx -= currentSpeed;
                    if (this.keys['d']) character.vx += currentSpeed;
                    if ((this.keys['w'] || this.keys[' ']) && character.onGround) {
                        character.vy = -character.jumpPower;
                        character.onGround = false;
                    }
                    
                    // ëª¨ë°”ì¼ í„°ì¹˜ ì»¨íŠ¸ë¡¤ ì²˜ë¦¬
                    if (this.mobileMode) {
                        // ì´ë™ ì¡°ì´ìŠ¤í‹±
                        if (this.touchControls.joystick.active) {
                            const joystickX = this.touchControls.joystick.x / 50;
                            const joystickY = this.touchControls.joystick.y / 50;
                            character.vx += joystickX * currentSpeed * 0.5; // ì†ë„ 0.1 â†’ 0.5ë¡œ ì¦ê°€
                            character.vy += joystickY * currentSpeed * 0.5;
                        }
                        // ì¡°ì¤€ ì¡°ì´ìŠ¤í‹±
                        if (this.touchControls.aimJoystick && (this.touchControls.aimJoystick.x !== 0 || this.touchControls.aimJoystick.y !== 0)) {
                            character.facing = Math.atan2(this.touchControls.aimJoystick.y, this.touchControls.aimJoystick.x);
                        } else {
                            // ë§ˆìš°ìŠ¤/í„°ì¹˜ ë°©í–¥ìœ¼ë¡œ í”Œë ˆì´ì–´ ë°”ë¼ë³´ê²Œ ì„¤ì • (ì¡°ì´ìŠ¤í‹±ì´ ë¹„í™œì„±ì¼ ë•Œë§Œ)
                            const dx = this.mouse.x - (character.x + character.width / 2);
                            const dy = this.mouse.y - (character.y + character.height / 2);
                            character.facing = Math.atan2(dy, dx);
                        }
                        // ì í”„ ë²„íŠ¼
                        if (this.touchControls.jumpButton.pressed && character.onGround) {
                            character.vy = -character.jumpPower;
                            character.onGround = false;
                        }
                    }
                    
                    // ë§ˆìš°ìŠ¤/í„°ì¹˜ ë°©í–¥ìœ¼ë¡œ í”Œë ˆì´ì–´ ë°”ë¼ë³´ê²Œ ì„¤ì •
                    const dx = this.mouse.x - (character.x + character.width / 2);
                    const dy = this.mouse.y - (character.y + character.height / 2);
                    character.facing = Math.atan2(dy, dx);
                    
                    // gunRecoil ë³´ê°„ (ë¶€ë“œëŸ½ê²Œ ë³µê·€)
                    character.gunRecoil += (character.gunRecoilTarget - character.gunRecoil) * 0.6;
                    if (Math.abs(character.gunRecoil - character.gunRecoilTarget) < 0.5) character.gunRecoil = character.gunRecoilTarget;
                } else if (character.type === 'player2') {
                    // í”Œë ˆì´ì–´2ê°€ ì£½ì–´ìˆìœ¼ë©´ ì…ë ¥ ì²˜ë¦¬ ì•ˆí•¨
                    if (this.gameState.player2Dead) return;
                    
                    // í”Œë ˆì´ì–´2 ì…ë ¥ ì²˜ë¦¬
                    const currentSpeed = character.speed * (now > this.gameState.playerSlowedEndTime ? 1 : this.gameState.playerSlowEffect || 1);
                    if (character.keys['a']) character.vx -= currentSpeed;
                    if (character.keys['d']) character.vx += currentSpeed;
                    if ((character.keys['w'] || character.keys[' ']) && character.onGround) {
                        character.vy = -character.jumpPower;
                        character.onGround = false;
                    }
                    
                    // ì¡°ì¤€ ë°©í–¥ ê²°ì •
                    if (this.gameState.multiplayerMode === 'leader') {
                        // ë¦¬ë” ì‹œìŠ¤í…œ: í”Œë ˆì´ì–´1ì˜ ì¡°ì¤€ ë°©í–¥ì„ ë”°ë¼ê°
                        character.facing = this.gameState.player.facing;
                    } else if (this.gameState.multiplayerMode === 'hybrid') {
                        // í•˜ì´ë¸Œë¦¬ë“œ ì‹œìŠ¤í…œ: ìë™ ì¡°ì¤€
                        const nearestEnemy = this.findNearestEnemy(character);
                        if (nearestEnemy) {
                            character.facing = Math.atan2(nearestEnemy.y - character.y, nearestEnemy.x - character.x);
                        }
                    }
                    
                                    // gunRecoil ë³´ê°„
                character.gunRecoil += (character.gunRecoilTarget - character.gunRecoil) * 0.6;
                if (Math.abs(character.gunRecoil - character.gunRecoilTarget) < 0.5) character.gunRecoil = character.gunRecoilTarget;
                } else if (character.type === 'ally') {
                    // ì•„êµ° AI: ê°€ì¥ ê°€ê¹Œìš´ ì ì„ ì°¾ì•„ ì´ë™í•˜ê³  ê³µê²©
                    let closestEnemy = null;
                    let minDistance = Infinity;

                    this.gameState.enemies.forEach(enemy => {
                        const dx = enemy.x - character.x;
                        const dy = enemy.y - character.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestEnemy = enemy;
                        }
                    });

                    if (closestEnemy) {
                        const dx = closestEnemy.x - character.x;
                        const dy = closestEnemy.y - character.y;
                        const angle = Math.atan2(dy, dx);
                        character.facing = angle;

                        // ì ì—ê²Œ ì ‘ê·¼ (ë„ˆë¬´ ê°€ê¹Œì›Œì§€ë©´ ë©ˆì¶¤)
                        if (minDistance > 100) { // ì ê³¼ 100px ì´ìƒ ë–¨ì–´ì ¸ ìˆìœ¼ë©´ ì´ë™
                            character.vx += Math.cos(angle) * 0.5 * character.speed * this.gameState.timeSlowEffect;
                            character.vy += Math.sin(angle) * 0.5 * character.speed * this.gameState.timeSlowEffect;
                        } else { // ì ê³¼ ê°€ê¹Œì›Œì§€ë©´ ì†ë„ ì¤„ì„
                            character.vx *= 0.9 * this.gameState.timeSlowEffect;
                            character.vy *= 0.9 * this.gameState.timeSlowEffect;
                        }

                        // ê³µê²©
                        if (this.gameState.timeSlowEffect === 0) {
                            // ì‹œê°„ ì •ì§€ ì¤‘ì—ëŠ” ì¿¨íƒ€ì„ì„ ê°•ì œë¡œ ê°±ì‹ 
                            character.lastShot = now;
                        } else if (now - character.lastShot > character.shootInterval * this.gameState.timeSlowEffect) {
                            this.gameState.projectiles.push({
                                id: Date.now() + Math.random(),
                                x: character.x + character.width / 2,
                                y: character.y + character.height / 2,
                                vx: Math.cos(angle) * 7,
                                vy: Math.sin(angle) * 7,
                                radius: 3,
                                damage: character.damage,
                                life: 80,
                                color: character.color,
                                ownerId: character.id,
                                pierceCount: 0,
                                explosiveRadius: 0,
                                bounceCount: 0,
                                isHoming: false,
                                homingStrength: 0,
                                splitCount: 0,
                                hitEnemies: []
                            });
                            character.lastShot = now;
                        }
                    } else {
                        // ì ì´ ì—†ìœ¼ë©´ ê°€ì¥ ê°€ê¹Œìš´ í”Œë ˆì´ì–´ ë”°ë¼ë‹¤ë‹˜
                        const allPlayers = [player];
                        
                        // í”Œë ˆì´ì–´2ê°€ ìˆë‹¤ë©´ ì¶”ê°€
                        if (this.gameState.player2 && this.gameState.multiplayerMode && !this.gameState.player2Dead) {
                            allPlayers.push(this.gameState.player2);
                        }
                        
                        // ë‹¤ë¥¸ ì˜¨ë¼ì¸ í”Œë ˆì´ì–´ë“¤ë„ ì¶”ê°€
                        if (this.gameState.otherPlayers) {
                            Object.values(this.gameState.otherPlayers).forEach(otherPlayer => {
                                if (otherPlayer && otherPlayer.isAlive !== false) {
                                    allPlayers.push(otherPlayer);
                                }
                            });
                        }
                        
                        // ê°€ì¥ ê°€ê¹Œìš´ í”Œë ˆì´ì–´ ì°¾ê¸°
                        let closestPlayer = player;
                        let minDistance = Infinity;
                        
                        allPlayers.forEach(p => {
                            if (p && p.isAlive !== false) {
                                const dx = p.x - character.x;
                                const dy = p.y - character.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                
                                if (distance < minDistance) {
                                    minDistance = distance;
                                    closestPlayer = p;
                                }
                            }
                        });
                        
                        const dx = closestPlayer.x - character.x;
                        const dy = closestPlayer.y - character.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance > 50) { // í”Œë ˆì´ì–´ì™€ 50px ì´ìƒ ë–¨ì–´ì ¸ ìˆìœ¼ë©´ ì´ë™
                            const angle = Math.atan2(dy, dx);
                            character.vx += Math.cos(angle) * 0.3 * character.speed * this.gameState.timeSlowEffect;
                            character.vy += Math.sin(angle) * 0.3 * character.speed * this.gameState.timeSlowEffect;
                        } else {
                            character.vx *= 0.9 * this.gameState.timeSlowEffect;
                            character.vy *= 0.9 * this.gameState.timeSlowEffect;
                        }
                    }

                } else {
                    // ì  AI ë™ì‘ (ì‹œê°„ ì •ì§€ íš¨ê³¼ ì ìš©)
                    if (this.gameState.timeSlowEffect === 0) return; // ì‹œê°„ì´ ì™„ì „íˆ ì •ì§€í–ˆìœ¼ë©´ ì ì€ ì›€ì§ì´ì§€ ì•ŠìŒ

                    // íƒ€ê²Ÿ í”Œë ˆì´ì–´ ì„ íƒ (ê°€ì¥ ê°€ê¹Œìš´ í”Œë ˆì´ì–´ë¥¼ íƒ€ê²Ÿìœ¼ë¡œ í•¨)
                    let targetPlayer = player;
                    let targetDistance = Math.sqrt(
                        Math.pow((player.x + player.width / 2) - (character.x + character.width / 2), 2) +
                        Math.pow((player.y + player.height / 2) - (character.y + character.height / 2), 2)
                    );
                    
                    // ë©€í‹°í”Œë ˆì´ì–´ì—ì„œ ëª¨ë“  í”Œë ˆì´ì–´ë“¤ì„ ê³ ë ¤
                    const allPlayers = [player];
                    
                    // í”Œë ˆì´ì–´2ê°€ ìˆë‹¤ë©´ ì¶”ê°€
                    if (this.gameState.player2 && this.gameState.multiplayerMode && !this.gameState.player2Dead) {
                        allPlayers.push(this.gameState.player2);
                    }
                    
                    // ë‹¤ë¥¸ ì˜¨ë¼ì¸ í”Œë ˆì´ì–´ë“¤ë„ ì¶”ê°€
                    if (this.gameState.otherPlayers) {
                        Object.values(this.gameState.otherPlayers).forEach(otherPlayer => {
                            if (otherPlayer && otherPlayer.isAlive !== false) {
                                allPlayers.push(otherPlayer);
                            }
                        });
                    }
                    
                    // ê°€ì¥ ê°€ê¹Œìš´ í”Œë ˆì´ì–´ ì°¾ê¸°
                    allPlayers.forEach(p => {
                        if (p && p.isAlive !== false) {
                            const distance = Math.sqrt(
                                Math.pow((p.x + p.width / 2) - (character.x + character.width / 2), 2) +
                                Math.pow((p.y + p.height / 2) - (character.y + character.height / 2), 2)
                            );
                            
                            if (distance < targetDistance) {
                                targetPlayer = p;
                                targetDistance = distance;
                            }
                        }
                    });
                    
                    const dx = (targetPlayer.x + targetPlayer.width / 2) - (character.x + character.width / 2);
                    const dy = (targetPlayer.y + targetPlayer.height / 2) - (character.y + character.height / 2);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // === ë³´ìŠ¤ ìŠ¤í‚¬ ===
                    if (character.type === 'boss') {
                        // 1. ë¯¸ì‚¬ì¼ ë‚œì‚¬ (ì—¬ëŸ¬ ë°©í–¥ìœ¼ë¡œ íƒ„í™˜ í¼ë¶“ê¸°)
                        if (now - character.lastMissile > character.missileCooldown) {
                            const missileCount = 12 + Math.floor(this.gameState.wave/5);
                            for (let i = 0; i < missileCount; i++) {
                                const angle = (Math.PI * 2) * (i / missileCount);
                                this.gameState.projectiles.push({
                                    id: Date.now() + Math.random(),
                                    x: character.x + character.width / 2,
                                    y: character.y + character.height / 2,
                                    vx: Math.cos(angle) * 8,
                                    vy: Math.sin(angle) * 8,
                                    radius: 6,
                                    damage: Math.floor(character.damage * 0.7),
                                    life: 90,
                                    color: character.color,
                                    ownerId: character.id
                                });
                            }
                            this.createFloatingText(character.x + character.width/2, character.y-20, 'ë¯¸ì‚¬ì¼ ë‚œì‚¬!', 'orange');
                            character.lastMissile = now;
                        }
                        // 2. ìˆœê°„ì´ë™ (í”Œë ˆì´ì–´ ê·¼ì²˜ë¡œ) - ì¿¨ë‹¤ìš´ ì¦ê°€
                        if (now - character.lastTeleport > (character.teleportCooldown || 15000)) {
                            const newX = targetPlayer.x + (Math.random() - 0.5) * 150;
                            const newY = targetPlayer.y + (Math.random() - 0.5) * 150;
                            character.x = Math.max(0, Math.min(this.canvas.width - character.width, newX));
                            character.y = Math.max(50, Math.min(this.canvas.height - this.GROUND_Y - character.height, newY));
                            this.createCollectParticles(character.x, character.y, character.color);
                            this.createFloatingText(character.x + character.width/2, character.y-20, 'ìˆœê°„ì´ë™!', 'cyan');
                            character.lastTeleport = now;
                        }
                        // 3. ê´‘ì—­ í­ë°œ
                        if (now - character.lastExplosion > character.explosionCooldown) {
                            this.createExplosion(character.x + character.width/2, character.y + character.height/2, 120 + this.gameState.wave*2, Math.floor(character.damage * 1.2), character.id);
                            this.createFloatingText(character.x + character.width/2, character.y-20, 'ê´‘ì—­ í­ë°œ!', 'red');
                            character.lastExplosion = now;
                        }
                        // 4. ì†Œí™˜ (ì¼ë°˜ ì )
                        if (now - character.lastSummon > character.summonCooldown) {
                            const summonCount = 2 + Math.floor(this.gameState.wave/10);
                            for (let i = 0; i < summonCount; i++) {
                                const spawnX = character.x + (Math.random() - 0.5) * 120;
                                const spawnY = character.y + (Math.random() - 0.5) * 120;
                                const summonedEnemy = this.createEnemy();
                                summonedEnemy.x = Math.max(0, Math.min(this.canvas.width - summonedEnemy.width, spawnX));
                                summonedEnemy.y = Math.max(50, Math.min(this.canvas.height - this.GROUND_Y - summonedEnemy.height, spawnY));
                                this.gameState.enemies.push(summonedEnemy);
                            }
                            this.createFloatingText(character.x + character.width/2, character.y-20, 'ì†Œí™˜!', 'yellow');
                            character.lastSummon = now;
                        }
                        // 5. ì‰´ë“œ (ë¬´ì )
                        if (!character.isInvincible && now - character.lastShield > character.shieldCooldown) {
                            character.isInvincible = true;
                            character.invincibleEndTime = now + character.shieldDuration;
                            character.lastShield = now;
                            this.createFloatingText(character.x + character.width/2, character.y-20, 'ì‰´ë“œ!', 'lightblue');
                        }
                        if (character.isInvincible && now > character.invincibleEndTime) {
                            character.isInvincible = false;
                        }
                        // 6. ë¸”ë™í™€ (ëª¨ë“  í”Œë ˆì´ì–´ë¥¼ ëŒì–´ë‹¹ê¹€)
                        if (now - character.lastBlackhole > character.blackholeCooldown) {
                            // ë¸”ë™í™€ íš¨ê³¼: ëª¨ë“  í”Œë ˆì´ì–´ë¥¼ ë³´ìŠ¤ ìª½ìœ¼ë¡œ ìˆœê°„ì ìœ¼ë¡œ ëŒì–´ë‹¹ê¹€
                            allPlayers.forEach(p => {
                                if (p && p.isAlive !== false) {
                                    const dx = (character.x + character.width/2) - (p.x + p.width/2);
                                    const dy = (character.y + character.height/2) - (p.y + p.height/2);
                                    const dist = Math.sqrt(dx*dx + dy*dy);
                                    if (dist < 600) {
                                        p.vx += dx/dist * 30;
                                        p.vy += dy/dist * 30;
                                        this.createFloatingText(p.x + p.width/2, p.y-20, 'ë¸”ë™í™€!', 'purple');
                                    }
                                }
                            });
                            this.createFloatingText(character.x + character.width/2, character.y-20, 'ë¸”ë™í™€!', 'purple');
                            character.lastBlackhole = now;
                        }
                    }

                    // ì¼ë°˜ ë³´ìŠ¤ AI ì´ë™/ê³µê²©
                    if (distance > 10) {
                        // ë” ì§€ëŠ¥ì ì¸ ì´ë™: í”Œë ˆì´ì–´ ë°©í–¥ìœ¼ë¡œ ë¶€ë“œëŸ½ê²Œ ì´ë™
                        const moveSpeed = 0.3 * this.gameState.timeSlowEffect;
                        character.vx += (dx / distance) * moveSpeed;
                        character.vy += (dy / distance) * moveSpeed;
                        character.facing = Math.atan2(dy, dx);
                        
                        // ì†ë„ ì œí•œ
                        const maxSpeed = character.speed || 2;
                        const currentSpeed = Math.sqrt(character.vx * character.vx + character.vy * character.vy);
                        if (currentSpeed > maxSpeed) {
                            character.vx = (character.vx / currentSpeed) * maxSpeed;
                            character.vy = (character.vy / currentSpeed) * maxSpeed;
                        }
                    }
                    // ê¸°ë³¸ ë°œì‚¬ (í”Œë ˆì´ì–´ í–¥í•´) - ìƒˆë¡œìš´ ì  10ì¢…ì€ ì œì™¸
                    const newEnemyTypes = ['timekeeper', 'gravity', 'echo', 'vortex', 'prism', 'quantum', 'crystal', 'plasma', 'nebula'];
                    if (!newEnemyTypes.includes(character.type) && distance < 700 && now - character.lastShot > character.shootInterval * this.gameState.timeSlowEffect) {
                        const angle = Math.atan2(dy, dx);
                        this.gameState.projectiles.push({
                            id: Date.now() + Math.random(),
                            x: character.x + character.width / 2,
                            y: character.y + character.height / 2,
                            vx: Math.cos(angle) * 7,
                            vy: Math.sin(angle) * 7,
                            radius: 3,
                            damage: character.damage,
                            life: 80,
                            color: character.color,
                            ownerId: character.id,
                            pierceCount: 0,
                            explosiveRadius: 0,
                            bounceCount: 0,
                            isHoming: false,
                            homingStrength: 0,
                            splitCount: 0,
                            hitEnemies: []
                        });
                        character.lastShot = now;
                    }
                }

                // === ì ë³„ ê³ ìœ  ìŠ¤í‚¬/AI êµ¬í˜„ ===
                
                // ëª¨ë“  í”Œë ˆì´ì–´ë“¤ì„ ê³ ë ¤í•œ íƒ€ê²Ÿ ì„ íƒ
                const allPlayers = [player];
                
                // í”Œë ˆì´ì–´2ê°€ ìˆë‹¤ë©´ ì¶”ê°€
                if (this.gameState.player2 && this.gameState.multiplayerMode && !this.gameState.player2Dead) {
                    allPlayers.push(this.gameState.player2);
                }
                
                // ë‹¤ë¥¸ ì˜¨ë¼ì¸ í”Œë ˆì´ì–´ë“¤ë„ ì¶”ê°€
                if (this.gameState.otherPlayers) {
                    Object.values(this.gameState.otherPlayers).forEach(otherPlayer => {
                        if (otherPlayer && otherPlayer.isAlive !== false) {
                            allPlayers.push(otherPlayer);
                        }
                    });
                }
                
                // ê°€ì¥ ê°€ê¹Œìš´ í”Œë ˆì´ì–´ ì°¾ê¸°
                let targetPlayer = player;
                let minDistance = Infinity;
                
                allPlayers.forEach(p => {
                    if (p && p.isAlive !== false) {
                        const dx = (p.x + p.width/2) - (character.x + character.width/2);
                        const dy = (p.y + p.height/2) - (character.y + character.height/2);
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < minDistance) {
                            minDistance = distance;
                            targetPlayer = p;
                        }
                    }
                });
                
                // ê±°ë¦¬ ê³„ì‚° (ê°€ì¥ ê°€ê¹Œìš´ í”Œë ˆì´ì–´ ê¸°ì¤€)
                const dx = (targetPlayer.x + targetPlayer.width/2) - (character.x + character.width/2);
                const dy = (targetPlayer.y + targetPlayer.height/2) - (character.y + character.height/2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // ì†Œí™˜ì‚¬: ì£¼ê¸°ì ìœ¼ë¡œ ì  ì†Œí™˜
                if (character.type === 'summoner' && now - character.lastSummon > (character.summonCooldown || 8000)) {
                    const summonCount = character.summonCount || 1;
                    for (let i = 0; i < summonCount; i++) {
                        const spawnX = character.x + (Math.random() - 0.5) * 80;
                        const spawnY = character.y + (Math.random() - 0.5) * 80;
                        const summonedEnemy = this.createEnemy(character.summonType || 'basic');
                        summonedEnemy.x = Math.max(0, Math.min(this.canvas.width - summonedEnemy.width, spawnX));
                        summonedEnemy.y = Math.max(50, Math.min(this.canvas.height - this.GROUND_Y - summonedEnemy.height, spawnY));
                        this.gameState.enemies.push(summonedEnemy);
                    }
                    this.createFloatingText(character.x + character.width/2, character.y-20, 'ì†Œí™˜!', 'yellow');
                    character.lastSummon = now;
                }

                // ìœ ë ¹: ë¬´ì  ìƒíƒœ í† ê¸€
                if (character.type === 'ghost' && now - character.lastInvincibility > (character.invincibilityCooldown || 3000)) {
                    character.isInvincible = !character.isInvincible;
                    character.lastInvincibility = now;
                    this.createFloatingText(character.x + character.width/2, character.y-20, character.isInvincible ? 'ë¬´ì !' : 'ì·¨ì•½!', character.isInvincible ? 'white' : 'red');
                }

                // ìˆœê°„ì´ë™ë³‘: ìˆœê°„ì´ë™
                if (character.type === 'teleporter' && now - character.lastTeleport > (character.teleportCooldown || 4000)) {
                    const newX = player.x + (Math.random() - 0.5) * 200;
                    const newY = player.y + (Math.random() - 0.5) * 200;
                    character.x = Math.max(0, Math.min(this.canvas.width - character.width, newX));
                    character.y = Math.max(50, Math.min(this.canvas.height - this.GROUND_Y - character.height, newY));
                    this.createCollectParticles(character.x, character.y, character.color);
                    this.createFloatingText(character.x + character.width/2, character.y-20, 'ìˆœê°„ì´ë™!', 'cyan');
                    character.lastTeleport = now;
                }

                // ìŠ¬ë¼ì„ë³‘: ëŠë ¤ì§€ëŠ” íƒ„í™˜ ë°œì‚¬
                if (character.type === 'spitter' && distance < 600 && now - character.lastShot > character.shootInterval * this.gameState.timeSlowEffect) {
                    const angle = Math.atan2(dy, dx);
                    this.gameState.projectiles.push({
                        id: Date.now() + Math.random(),
                        x: character.x + character.width / 2,
                        y: character.y + character.height / 2,
                        vx: Math.cos(angle) * 6,
                        vy: Math.sin(angle) * 6,
                        radius: 4,
                        damage: character.damage,
                        life: 100,
                        color: character.color,
                        ownerId: character.id,
                        slowEffect: character.slowEffect || 0.5,
                        slowDuration: character.slowDuration || 3000
                    });
                    character.lastShot = now;
                }

                // í¡í˜ˆì : ê°€ì¥ ê°€ê¹Œìš´ í”Œë ˆì´ì–´ì— ë‹¿ìœ¼ë©´ ì²´ë ¥ í¡ìˆ˜
                if (character.type === 'leech' && targetPlayer) {
                    const dx = (targetPlayer.x + targetPlayer.width/2) - (character.x + character.width/2);
                    const dy = (targetPlayer.y + targetPlayer.height/2) - (character.y + character.height/2);
                    const touchDistance = Math.sqrt(dx*dx + dy*dy);
                    if (touchDistance < 30 && now - character.lastLeech > 1000) {
                        const leechAmount = character.leechAmount || 10;
                        targetPlayer.health = Math.max(0, targetPlayer.health - leechAmount);
                        character.health = Math.min(character.maxHealth, character.health + leechAmount);
                        this.createFloatingText(targetPlayer.x + targetPlayer.width/2, targetPlayer.y-20, `-${leechAmount} í¡í˜ˆ`, 'red');
                        this.createFloatingText(character.x + character.width/2, character.y-20, `+${leechAmount} í¡ìˆ˜`, 'green');
                        character.lastLeech = now;
                    }
                }

                // ì§€ë¢° ì : ê°€ì¥ ê°€ê¹Œìš´ í”Œë ˆì´ì–´ ê·¼ì²˜ì—ì„œ í­ë°œ
                if (character.type === 'mine' && targetPlayer) {
                    const dx = (targetPlayer.x + targetPlayer.width/2) - (character.x + character.width/2);
                    const dy = (targetPlayer.y + targetPlayer.height/2) - (character.y + character.height/2);
                    const mineDistance = Math.sqrt(dx*dx + dy*dy);
                    if (mineDistance < (character.explodeRadius || 60)) {
                        this.createExplosion(character.x + character.width/2, character.y + character.height/2, 80, character.damage, character.id);
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'í­ë°œ!', 'orange');
                        this.gameState.enemies = this.gameState.enemies.filter(e => e !== character);
                        return;
                    }
                }

                // ë¹™ê²° ì : ê°€ì¥ ê°€ê¹Œìš´ í”Œë ˆì´ì–´ë¥¼ ì–¼ë¦¼
                if (character.type === 'freezer' && distance < 600 && now - character.lastFreeze > (character.freezeCooldown || 5000)) {
                    targetPlayer.speed *= 0.3;
                    this.createFloatingText(targetPlayer.x + targetPlayer.width/2, targetPlayer.y-20, 'ë¹™ê²°!', 'lightblue');
                    setTimeout(() => {
                        targetPlayer.speed = this.ENEMY_TYPES[targetPlayer.type]?.speed || 5;
                    }, character.freezeDuration || 2000);
                    character.lastFreeze = now;
                }

                // ë°˜ì‚¬ ì : íƒ„í™˜ ë°˜ì‚¬
                if (character.type === 'reflector' && Math.random() < (character.reflectChance || 0.3)) {
                    // íƒ„í™˜ ë°˜ì‚¬ ë¡œì§ì€ ë°œì‚¬ì²´ ì¶©ëŒ ì²˜ë¦¬ì—ì„œ êµ¬í˜„
                }

                // íëŸ¬ ì : ì£¼ë³€ ì  íšŒë³µ
                if (character.type === 'healer' && now - character.lastHeal > (character.healCooldown || 4000)) {
                    this.gameState.enemies.forEach(enemy => {
                        if (enemy !== character) {
                            const dx = (enemy.x + enemy.width/2) - (character.x + character.width/2);
                            const dy = (enemy.y + enemy.height/2) - (character.y + character.height/2);
                            const healDistance = Math.sqrt(dx*dx + dy*dy);
                            if (healDistance < (character.healRadius || 120)) {
                                enemy.health = Math.min(enemy.maxHealth, enemy.health + (character.healAmount || 15));
                                this.createFloatingText(enemy.x + enemy.width/2, enemy.y-20, `+${character.healAmount || 15}`, 'green');
                            }
                        }
                    });
                    this.createFloatingText(character.x + character.width/2, character.y-20, 'ì¹˜ìœ !', 'green');
                    character.lastHeal = now;
                }

                // í¬íƒˆ ì : ìˆœê°„ì´ë™
                if (character.type === 'portal' && now - character.lastTeleport > (character.teleportCooldown || 3000)) {
                    const newX = player.x + (Math.random() - 0.5) * 150;
                    const newY = player.y + (Math.random() - 0.5) * 150;
                    character.x = Math.max(0, Math.min(this.canvas.width - character.width, newX));
                    character.y = Math.max(50, Math.min(this.canvas.height - this.GROUND_Y - character.height, newY));
                    this.createCollectParticles(character.x, character.y, character.color);
                    this.createFloatingText(character.x + character.width/2, character.y-20, 'í¬íƒˆ!', 'purple');
                    character.lastTeleport = now;
                }

                // í­ë°œ ì : ì£½ì„ ë•Œ í­ë°œ (ì  ì‚¬ë§ ì²˜ë¦¬ì—ì„œ êµ¬í˜„)

                // ìì„ ì : ìœ ë„ íƒ„í™˜ ë°œì‚¬
                if (character.type === 'magnet' && distance < 600 && now - character.lastShot > character.shootInterval * this.gameState.timeSlowEffect) {
                    const angle = Math.atan2(dy, dx);
                    this.gameState.projectiles.push({
                        id: Date.now() + Math.random(),
                        x: character.x + character.width / 2,
                        y: character.y + character.height / 2,
                        vx: Math.cos(angle) * 5,
                        vy: Math.sin(angle) * 5,
                        radius: 3,
                        damage: character.damage,
                        life: 120,
                        color: character.color,
                        ownerId: character.id,
                        isHoming: true,
                        homingStrength: 0.1
                    });
                    character.lastShot = now;
                }

                // ì €ì£¼ ì : ì €ì£¼ íš¨ê³¼
                if (character.type === 'curse' && distance < 600 && now - character.lastCurse > (character.curseCooldown || 6000)) {
                    player.damageReductionFactor = 0.7;
                    this.createFloatingText(player.x + player.width/2, player.y-20, 'ì €ì£¼!', 'purple');
                    setTimeout(() => {
                        player.damageReductionFactor = 1;
                    }, character.curseDuration || 2500);
                    character.lastCurse = now;
                }

                // í”Œë¡œí„°: ììœ ë¡œìš´ ì›€ì§ì„
                if (character.type === 'floater') {
                    if (now - character.lastDirectionChange > 2000) {
                        character.floatDirection = Math.random() * Math.PI * 2;
                        character.lastDirectionChange = now;
                    }
                    character.vx += Math.cos(character.floatDirection) * 0.5;
                    character.vy += Math.sin(character.floatDirection) * 0.5;
                }

                // í˜ì´ì €: í˜ì´ì¦ˆ ìŠ¤í‚¬
                if (character.type === 'phaser' && now - character.lastPhase > (character.phaseCooldown || 8000)) {
                    character.isPhasing = true;
                    character.globalAlpha = 0.3;
                    this.createFloatingText(character.x + character.width/2, character.y-20, 'í˜ì´ì¦ˆ!', 'cyan');
                    setTimeout(() => {
                        character.isPhasing = false;
                        character.globalAlpha = 1;
                    }, character.phaseDuration || 2000);
                    character.lastPhase = now;
                }

                // === ìƒˆë¡œìš´ ì  10ì¢… AI ë¡œì§ ===
                
                // ë‹Œì: ì€ì‹  ëª¨ë“œ
                if (character.type === 'ninja' && now - character.lastStealth > (character.stealthCooldown || 5000)) {
                    character.isStealthed = true;
                    character.globalAlpha = 0.2;
                    this.createFloatingText(character.x + character.width/2, character.y-20, 'ì€ì‹ !', 'gray');
                    setTimeout(() => {
                        character.isStealthed = false;
                        character.globalAlpha = 1;
                    }, character.stealthDuration || 2000);
                    character.lastStealth = now;
                }

                // ìŠ¤ë‚˜ì´í¼: ì¥ê±°ë¦¬ ê³µê²©
                if (character.type === 'sniper' && distance < (character.range || 400) && now - character.lastShot > character.shootInterval * this.gameState.timeSlowEffect) {
                    const angle = Math.atan2(dy, dx);
                    this.gameState.projectiles.push({
                        id: Date.now() + Math.random(),
                        x: character.x + character.width / 2,
                        y: character.y + character.height / 2,
                        vx: Math.cos(angle) * 12,
                        vy: Math.sin(angle) * 12,
                        radius: 2,
                        damage: character.damage,
                        life: 150,
                        color: character.color,
                        ownerId: character.id
                    });
                    character.lastShot = now;
                }

                // ê´‘ì „ì‚¬: ë¶„ë…¸ ëª¨ë“œ
                if (character.type === 'berserker' && character.health < character.maxHealth * (character.rageThreshold || 0.3) && !character.isRaging) {
                    character.isRaging = true;
                    character.speed *= character.rageSpeedBoost || 1.5;
                    character.damage *= character.rageDamageBoost || 1.8;
                    this.createFloatingText(character.x + character.width/2, character.y-20, 'ë¶„ë…¸!', 'red');
                }

                // ì†Œí™˜ì‚¬: ì†Œí™˜ ëŠ¥ë ¥
                if (character.type === 'summoner' && now - character.lastSummon > (character.summonCooldown || 8000)) {
                    for (let i = 0; i < (character.summonCount || 2); i++) {
                        const spawnX = character.x + (Math.random() - 0.5) * 100;
                        const spawnY = character.y + (Math.random() - 0.5) * 100;
                        const summonedEnemy = this.createEnemy(character.summonType || 'basic');
                        summonedEnemy.x = Math.max(0, Math.min(this.canvas.width - summonedEnemy.width, spawnX));
                        summonedEnemy.y = Math.max(50, Math.min(this.canvas.height - this.GROUND_Y - summonedEnemy.height, spawnY));
                        this.gameState.enemies.push(summonedEnemy);
                    }
                    this.createFloatingText(character.x + character.width/2, character.y-20, 'ì†Œí™˜!', 'yellow');
                    character.lastSummon = now;
                }

                // ê°€ë””ì–¸: ë°©íŒ¨ ëª¨ë“œ
                if (character.type === 'guardian' && now - character.lastShield > (character.shieldCooldown || 6000)) {
                    character.isShielded = true;
                    character.damageReductionFactor = 0.3;
                    this.createFloatingText(character.x + character.width/2, character.y-20, 'ë°©íŒ¨!', 'lightblue');
                    setTimeout(() => {
                        character.isShielded = false;
                        character.damageReductionFactor = 1;
                    }, character.shieldDuration || 3000);
                    character.lastShield = now;
                }

                // ì–´ìŒ”ì‹ : ë’¤ì¹˜ê¸° ê³µê²©
                if (character.type === 'assassin' && distance < 50 && now - character.lastBackstab > 2000) {
                    const backstabDamage = character.damage * (character.backstabMultiplier || 2.0);
                    player.health = Math.max(0, player.health - backstabDamage);
                    this.createFloatingText(player.x + player.width/2, player.y-20, `-${backstabDamage} ë’¤ì¹˜ê¸°!`, 'red');
                    character.lastBackstab = now;
                }

                // í—¤ë¹„: ì¤‘í™”ê¸° ê³µê²©
                if (character.type === 'heavy' && distance < 600 && now - character.lastShot > character.shootInterval * this.gameState.timeSlowEffect) {
                    const angle = Math.atan2(dy, dx);
                    this.gameState.projectiles.push({
                        id: Date.now() + Math.random(),
                        x: character.x + character.width / 2,
                        y: character.y + character.height / 2,
                        vx: Math.cos(angle) * 4,
                        vy: Math.sin(angle) * 4,
                        radius: 8,
                        damage: character.damage,
                        life: 100,
                        color: character.color,
                        ownerId: character.id,
                        splashDamage: true,
                        splashRadius: character.splashRadius || 60
                    });
                    character.lastShot = now;
                }

                // í­ê²©ê¸°: í­ë°œì„± íƒ„í™˜
                if (character.type === 'bomber' && distance < 600 && now - character.lastShot > character.shootInterval * this.gameState.timeSlowEffect) {
                    const angle = Math.atan2(dy, dx);
                    this.gameState.projectiles.push({
                        id: Date.now() + Math.random(),
                        x: character.x + character.width / 2,
                        y: character.y + character.height / 2,
                        vx: Math.cos(angle) * 6,
                        vy: Math.sin(angle) * 6,
                        radius: 5,
                        damage: character.damage,
                        life: 120,
                        color: character.color,
                        ownerId: character.id,
                        explosiveRadius: character.explosionRadius || 50
                    });
                    character.lastShot = now;
                }

                // ë©”ë”•: ì¹˜ë£Œ ëŠ¥ë ¥
                if (character.type === 'medic' && now - character.lastHeal > (character.healCooldown || 10000)) {
                    this.gameState.enemies.forEach(enemy => {
                        if (enemy !== character) {
                            const dx = (enemy.x + enemy.width/2) - (character.x + character.width/2);
                            const dy = (enemy.y + enemy.height/2) - (character.y + character.height/2);
                            const healDistance = Math.sqrt(dx*dx + dy*dy);
                            if (healDistance < (character.healRadius || 150)) {
                                enemy.health = Math.min(enemy.maxHealth, enemy.health + (character.healAmount || 20));
                                this.createFloatingText(enemy.x + enemy.width/2, enemy.y-20, `+${character.healAmount || 20}`, 'green');
                            }
                        }
                    });
                    this.createFloatingText(character.x + character.width/2, character.y-20, 'ì¹˜ìœ !', 'green');
                    character.lastHeal = now;
                }

                // ë“œë¡ : í˜¸ë²„ ëª¨ë“œ
                if (character.type === 'drone' && now - character.lastHover > (character.hoverCooldown || 4000)) {
                    character.isHovering = true;
                    character.speed *= 0.5;
                    this.createFloatingText(character.x + character.width/2, character.y-20, 'í˜¸ë²„!', 'cyan');
                    setTimeout(() => {
                        character.isHovering = false;
                        character.speed = this.ENEMY_TYPES.drone.speed;
                    }, character.hoverDuration || 2000);
                    character.lastHover = now;
                }

                // === ìƒˆë¡œìš´ ì  10ì¢… AI ë¡œì§ (ìŠ¤í‚¬ 2ê°œì”©) ===
                
                // íƒ€ì„í‚¤í¼: ìŠ¤í‚¬1 - ì‹œê°„ ì—­í–‰, ìŠ¤í‚¬2 - ì‹œê°„ ê°€ì†
                if (character.type === 'timekeeper') {
                    // ìŠ¤í‚¬1: ì‹œê°„ ì—­í–‰ (6ì´ˆ ì¿¨)
                    if (now - character.lastTimeReverse > 6000) {
                        this.gameState.timeSlowEffect = 0.3; // ì‹œê°„ì„ ëŠë¦¬ê²Œ
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ì‹œê°„ ì—­í–‰!', '#ff6b9d');
                        setTimeout(() => {
                            this.gameState.timeSlowEffect = 1;
                        }, 3000);
                        character.lastTimeReverse = now;
                    }
                    // ìŠ¤í‚¬2: ì‹œê°„ ê°€ì† (8ì´ˆ ì¿¨)
                    if (now - character.lastTimeAccel > (character.timeAccelCooldown || 8000)) {
                        this.gameState.timeSlowEffect = 1.0; // ì‹œê°„ì„ ì •ìƒ ì†ë„ë¡œ
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ì‹œê°„ ê°€ì†!', '#ff6b9d');
                        setTimeout(() => {
                            this.gameState.timeSlowEffect = 1;
                        }, 2000);
                        character.lastTimeAccel = now;
                    }
                }

                // ê·¸ë˜ë¹„í‹°: ìŠ¤í‚¬1 - ì¤‘ë ¥ì¥, ìŠ¤í‚¬2 - ë°˜ì¤‘ë ¥
                if (character.type === 'gravity') {
                    // ìŠ¤í‚¬1: ì¤‘ë ¥ì¥ (8ì´ˆ ì¿¨)
                    if (now - character.lastGravity > (character.gravityCooldown || 8000)) {
                        const dx = (character.x + character.width/2) - (player.x + player.width/2);
                        const dy = (character.y + character.height/2) - (player.y + player.height/2);
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < 200) {
                            player.vx += (dx/dist) * 0.8;
                            player.vy += (dy/dist) * 0.8;
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ì¤‘ë ¥ì¥!', '#9d4edd');
                        character.lastGravity = now;
                    }
                    // ìŠ¤í‚¬2: ë°˜ì¤‘ë ¥ (6ì´ˆ ì¿¨)
                    if (now - character.lastAntiGravity > (character.antiGravityCooldown || 6000)) {
                        const dx = (character.x + character.width/2) - (player.x + player.width/2);
                        const dy = (character.y + character.height/2) - (player.y + player.height/2);
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < 150) {
                            player.vx -= (dx/dist) * 1.2;
                            player.vy -= (dy/dist) * 1.2;
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ë°˜ì¤‘ë ¥!', '#9d4edd');
                        character.lastAntiGravity = now;
                    }
                }

                // ì—ì½”: ìŠ¤í‚¬1 - ì—ì½” ë°œì‚¬, ìŠ¤í‚¬2 - ìŒíŒŒ ê³µê²©
                if (character.type === 'echo') {
                    const dx = (player.x + player.width/2) - (character.x + character.width/2);
                    const dy = (player.y + player.height/2) - (character.y + character.height/2);
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    // ìŠ¤í‚¬1: ì—ì½” ë°œì‚¬ (ë°œì‚¬ ê°„ê²©)
                    if (distance < 600 && now - character.lastEcho > character.shootInterval * this.gameState.timeSlowEffect) {
                        const angle = Math.atan2(dy, dx);
                        for (let i = 0; i < 3; i++) {
                            setTimeout(() => {
                                this.gameState.projectiles.push({
                                    id: Date.now() + Math.random(),
                                    x: character.x + character.width / 2,
                                    y: character.y + character.height / 2,
                                    vx: Math.cos(angle) * 7,
                                    vy: Math.sin(angle) * 7,
                                    radius: 4,
                                    damage: character.damage,
                                    life: 100,
                                    color: character.color,
                                    ownerId: character.id
                                });
                            }, i * 500);
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ì—ì½”!', '#4cc9f0');
                        character.lastEcho = now;
                    }
                    // ìŠ¤í‚¬2: ìŒíŒŒ ê³µê²© (10ì´ˆ ì¿¨)
                    if (now - character.lastSonicWave > (character.sonicWaveCooldown || 10000)) {
                        const angle = Math.atan2(dy, dx);
                        for (let i = 0; i < 8; i++) {
                            const spreadAngle = angle + (i - 4) * 0.3;
                            this.gameState.projectiles.push({
                                id: Date.now() + Math.random(),
                                x: character.x + character.width / 2,
                                y: character.y + character.height / 2,
                                vx: Math.cos(spreadAngle) * 6,
                                vy: Math.sin(spreadAngle) * 6,
                                radius: 5,
                                damage: character.damage * 1.5,
                                life: 120,
                                color: character.color,
                                ownerId: character.id
                            });
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ìŒíŒŒ!', '#4cc9f0');
                        character.lastSonicWave = now;
                    }
                }

                // ë³´ë¥´í…ìŠ¤: ìŠ¤í‚¬1 - ì†Œìš©ëŒì´, ìŠ¤í‚¬2 - íšŒì˜¤ë¦¬
                if (character.type === 'vortex') {
                    // ìŠ¤í‚¬1: ì†Œìš©ëŒì´ (10ì´ˆ ì¿¨)
                    if (now - character.lastVortex > (character.vortexCooldown || 10000)) {
                        const dx = (character.x + character.width/2) - (player.x + player.width/2);
                        const dy = (character.y + character.height/2) - (player.y + player.height/2);
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < 250) {
                            player.vx += (dx/dist) * 2.0;
                            player.vy += (dy/dist) * 2.0;
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ë³´ë¥´í…ìŠ¤!', '#7209b7');
                        character.lastVortex = now;
                    }
                    // ìŠ¤í‚¬2: íšŒì˜¤ë¦¬ (7ì´ˆ ì¿¨)
                    if (now - character.lastWhirlwind > (character.whirlwindCooldown || 7000)) {
                        const dx = (player.x + player.width/2) - (character.x + character.width/2);
                        const dy = (player.y + player.height/2) - (character.y + character.height/2);
                        const angle = Math.atan2(dy, dx);
                        for (let i = 0; i < 12; i++) {
                            const spinAngle = angle + (i * Math.PI / 6);
                            this.gameState.projectiles.push({
                                id: Date.now() + Math.random(),
                                x: character.x + character.width / 2,
                                y: character.y + character.height / 2,
                                vx: Math.cos(spinAngle) * 5,
                                vy: Math.sin(spinAngle) * 5,
                                radius: 4,
                                damage: character.damage,
                                life: 80,
                                color: character.color,
                                ownerId: character.id
                            });
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'íšŒì˜¤ë¦¬!', '#7209b7');
                        character.lastWhirlwind = now;
                    }
                }

                // í”„ë¦¬ì¦˜: ìŠ¤í‚¬1 - í”„ë¦¬ì¦˜ ë¶„ì‚°, ìŠ¤í‚¬2 - ë ˆì´ì €
                if (character.type === 'prism') {
                    const dx = (player.x + player.width/2) - (character.x + character.width/2);
                    const dy = (player.y + player.height/2) - (character.y + character.height/2);
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    // ìŠ¤í‚¬1: í”„ë¦¬ì¦˜ ë¶„ì‚° (ë°œì‚¬ ê°„ê²©)
                    if (distance < 600 && now - character.lastPrism > character.shootInterval * this.gameState.timeSlowEffect) {
                        const angle = Math.atan2(dy, dx);
                        for (let i = 0; i < 5; i++) {
                            const spreadAngle = angle - Math.PI/3 + (Math.PI/3 * i / 2);
                            this.gameState.projectiles.push({
                                id: Date.now() + Math.random(),
                                x: character.x + character.width / 2,
                                y: character.y + character.height / 2,
                                vx: Math.cos(spreadAngle) * 6,
                                vy: Math.sin(spreadAngle) * 6,
                                radius: 3,
                                damage: character.damage,
                                life: 90,
                                color: character.color,
                                ownerId: character.id
                            });
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'í”„ë¦¬ì¦˜!', '#f72585');
                        character.lastPrism = now;
                    }
                    // ìŠ¤í‚¬2: ë ˆì´ì € (8ì´ˆ ì¿¨)
                    if (now - character.lastLaser > (character.laserCooldown || 8000)) {
                        const angle = Math.atan2(dy, dx);
                        this.gameState.projectiles.push({
                            id: Date.now() + Math.random(),
                            x: character.x + character.width / 2,
                            y: character.y + character.height / 2,
                            vx: Math.cos(angle) * 12,
                            vy: Math.sin(angle) * 12,
                            radius: 2,
                            damage: character.damage * 2,
                            life: 150,
                            color: character.color,
                            ownerId: character.id
                        });
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ë ˆì´ì €!', '#f72585');
                        character.lastLaser = now;
                    }
                }

                // í€€í…€: ìŠ¤í‚¬1 - ì–‘ì ìˆœê°„ì´ë™, ìŠ¤í‚¬2 - ì–‘ì ë¶„ì—´
                if (character.type === 'quantum') {
                    // ìŠ¤í‚¬1: ì–‘ì ìˆœê°„ì´ë™ (6ì´ˆ ì¿¨)
                    if (now - character.lastQuantum > (character.quantumCooldown || 6000)) {
                        const newX = character.x + (Math.random() - 0.5) * 300;
                        const newY = character.y + (Math.random() - 0.5) * 300;
                        character.x = Math.max(0, Math.min(this.canvas.width - character.width, newX));
                        character.y = Math.max(50, Math.min(this.canvas.height - this.GROUND_Y - character.height, newY));
                        this.createCollectParticles(character.x, character.y, character.color);
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'í€€í…€!', '#3a0ca3');
                        character.lastQuantum = now;
                    }
                    // ìŠ¤í‚¬2: ì–‘ì ë¶„ì—´ (12ì´ˆ ì¿¨)
                    if (now - character.lastQuantumSplit > (character.quantumSplitCooldown || 12000)) {
                        const dx = (player.x + player.width/2) - (character.x + character.width/2);
                        const dy = (player.y + player.height/2) - (character.y + character.height/2);
                        const angle = Math.atan2(dy, dx);
                        for (let i = 0; i < 3; i++) {
                            const splitAngle = angle + (i - 1) * 0.5;
                            this.gameState.projectiles.push({
                                id: Date.now() + Math.random(),
                                x: character.x + character.width / 2,
                                y: character.y + character.height / 2,
                                vx: Math.cos(splitAngle) * 8,
                                vy: Math.sin(splitAngle) * 8,
                                radius: 4,
                                damage: character.damage * 1.3,
                                life: 100,
                                color: character.color,
                                ownerId: character.id
                            });
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ì–‘ì ë¶„ì—´!', '#3a0ca3');
                        character.lastQuantumSplit = now;
                    }
                }

                // í¬ë¦¬ìŠ¤íƒˆ: ìŠ¤í‚¬1 - í¬ë¦¬ìŠ¤íƒˆ ë°©íŒ¨, ìŠ¤í‚¬2 - í¬ë¦¬ìŠ¤íƒˆ íŒŒí¸
                if (character.type === 'crystal') {
                    // ìŠ¤í‚¬1: í¬ë¦¬ìŠ¤íƒˆ ë°©íŒ¨ (15ì´ˆ ì¿¨)
                    if (now - character.lastCrystal > (character.crystalCooldown || 15000)) {
                        character.isCrystalShielded = true;
                        character.damageReductionFactor = 0.2; // 80% ë°ë¯¸ì§€ ê°ì†Œ
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'í¬ë¦¬ìŠ¤íƒˆ!', '#4361ee');
                        setTimeout(() => {
                            character.isCrystalShielded = false;
                            character.damageReductionFactor = 1;
                        }, 5000);
                        character.lastCrystal = now;
                    }
                    // ìŠ¤í‚¬2: í¬ë¦¬ìŠ¤íƒˆ íŒŒí¸ (10ì´ˆ ì¿¨)
                    if (now - character.lastCrystalShard > (character.crystalShardCooldown || 10000)) {
                        const dx = (player.x + player.width/2) - (character.x + character.width/2);
                        const dy = (player.y + player.height/2) - (character.y + character.height/2);
                        const angle = Math.atan2(dy, dx);
                        for (let i = 0; i < 6; i++) {
                            const shardAngle = angle + (i - 3) * 0.4;
                            this.gameState.projectiles.push({
                                id: Date.now() + Math.random(),
                                x: character.x + character.width / 2,
                                y: character.y + character.height / 2,
                                vx: Math.cos(shardAngle) * 7,
                                vy: Math.sin(shardAngle) * 7,
                                radius: 3,
                                damage: character.damage * 1.2,
                                life: 110,
                                color: character.color,
                                ownerId: character.id
                            });
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'í¬ë¦¬ìŠ¤íƒˆ íŒŒí¸!', '#4361ee');
                        character.lastCrystalShard = now;
                    }
                }



                // í”Œë¼ì¦ˆë§ˆ: ìŠ¤í‚¬1 - í”Œë¼ì¦ˆë§ˆ ì²´ì¸, ìŠ¤í‚¬2 - í”Œë¼ì¦ˆë§ˆ í­ë°œ
                if (character.type === 'plasma') {
                    const dx = (player.x + player.width/2) - (character.x + character.width/2);
                    const dy = (player.y + player.height/2) - (character.y + character.height/2);
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    // ìŠ¤í‚¬1: í”Œë¼ì¦ˆë§ˆ ì²´ì¸ (ë°œì‚¬ ê°„ê²©)
                    if (distance < 600 && now - character.lastPlasma > character.shootInterval * this.gameState.timeSlowEffect) {
                        const angle = Math.atan2(dy, dx);
                        for (let i = 0; i < 4; i++) {
                            const chainAngle = angle + (i - 2) * 0.3;
                            this.gameState.projectiles.push({
                                id: Date.now() + Math.random(),
                                x: character.x + character.width / 2,
                                y: character.y + character.height / 2,
                                vx: Math.cos(chainAngle) * 8,
                                vy: Math.sin(chainAngle) * 8,
                                radius: 5,
                                damage: character.damage,
                                life: 120,
                                color: character.color,
                                ownerId: character.id
                            });
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'í”Œë¼ì¦ˆë§ˆ!', '#06ffa5');
                        character.lastPlasma = now;
                    }
                    // ìŠ¤í‚¬2: í”Œë¼ì¦ˆë§ˆ í­ë°œ (12ì´ˆ ì¿¨)
                    if (now - character.lastPlasmaExplosion > (character.plasmaExplosionCooldown || 12000)) {
                        this.createExplosion(character.x + character.width/2, character.y + character.height/2, 120, character.damage * 2, character.id);
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'í”Œë¼ì¦ˆë§ˆ í­ë°œ!', '#06ffa5');
                        character.lastPlasmaExplosion = now;
                    }
                }

                // ë„¤ë·¸ë¼: ìŠ¤í‚¬1 - ë„¤ë·¸ë¼ êµ¬ë¦„, ìŠ¤í‚¬2 - ë³„ í­ë°œ
                if (character.type === 'nebula') {
                    // ìŠ¤í‚¬1: ë„¤ë·¸ë¼ êµ¬ë¦„ (12ì´ˆ ì¿¨)
                    if (now - character.lastNebula > (character.nebulaCooldown || 12000)) {
                        const dx = (character.x + character.width/2) - (player.x + player.width/2);
                        const dy = (character.y + character.height/2) - (player.y + player.height/2);
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < 180) {
                            player.health = Math.max(0, player.health - 8);
                            this.createFloatingText(player.x + player.width/2, player.y-20, '-8', '#ff9e00');
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ë„¤ë·¸ë¼!', '#ff9e00');
                        character.lastNebula = now;
                    }
                    // ìŠ¤í‚¬2: ë³„ í­ë°œ (8ì´ˆ ì¿¨)
                    if (now - character.lastStarExplosion > (character.starExplosionCooldown || 8000)) {
                        const dx = (player.x + player.width/2) - (character.x + character.width/2);
                        const dy = (player.y + player.height/2) - (character.y + character.height/2);
                        const angle = Math.atan2(dy, dx);
                        for (let i = 0; i < 10; i++) {
                            const starAngle = angle + (i * Math.PI / 5);
                            this.gameState.projectiles.push({
                                id: Date.now() + Math.random(),
                                x: character.x + character.width / 2,
                                y: character.y + character.height / 2,
                                vx: Math.cos(starAngle) * 6,
                                vy: Math.sin(starAngle) * 6,
                                radius: 4,
                                damage: character.damage * 1.4,
                                life: 100,
                                color: character.color,
                                ownerId: character.id
                            });
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ë³„ í­ë°œ!', '#ff9e00');
                        character.lastStarExplosion = now;
                    }
                }
                // ...

                // === ê° ë³´ìŠ¤ë³„ ê³ ìœ  ìŠ¤í‚¬ ===
                if (character.type === 'boss_alpha') {
                    // 1. ë¯¸ë‹ˆì–¸ ì†Œí™˜
                    if (now - character.lastSummon > character.summonCooldown) {
                        for (let i = 0; i < character.summonCount; i++) {
                            const spawnX = character.x + (Math.random() - 0.5) * 100;
                            const spawnY = character.y + (Math.random() - 0.5) * 100;
                            const summonedEnemy = this.createEnemy(character.summonType);
                            summonedEnemy.x = spawnX;
                            summonedEnemy.y = spawnY;
                            this.gameState.enemies.push(summonedEnemy);
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ë¯¸ë‹ˆì–¸ ì†Œí™˜!', 'yellow');
                        character.lastSummon = now;
                    }
                    // 2. ì—°ì† ëŒì§„
                    if (now - character.lastDash > character.dashCooldown) {
                        character.isDashing = true;
                        let dashIdx = 0;
                        const dash = () => {
                            if (dashIdx < character.dashCount) {
                                const angle = Math.atan2(player.y - character.y, player.x - character.x);
                                character.vx += Math.cos(angle) * 30;
                                character.vy += Math.sin(angle) * 30;
                                this.createFloatingText(character.x + character.width/2, character.y-20, 'ëŒì§„!', 'orange');
                                dashIdx++;
                                setTimeout(dash, character.dashDuration);
                            } else {
                                character.isDashing = false;
                            }
                        };
                        dash();
                        character.lastDash = now;
                    }
                    // 3. ê´‘ì—­ ì¶©ê²©íŒŒ
                    if (now - character.lastShockwave > character.shockwaveCooldown) {
                        this.createExplosion(character.x + character.width/2, character.y + character.height/2, 180, character.damage * 1.5, character.id);
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ì¶©ê²©íŒŒ!', 'red');
                        character.lastShockwave = now;
                    }
                }
                if (character.type === 'boss_beta') {
                    // 1. ì‰´ë“œ(ë¬´ì )
                    if (!character.isInvincible && now - character.lastShield > character.shieldCooldown) {
                        character.isInvincible = true;
                        character.invincibleEndTime = now + character.shieldDuration;
                        character.lastShield = now;
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ì‰´ë“œ!', 'lightblue');
                    }
                    if (character.isInvincible && now > character.invincibleEndTime) {
                        character.isInvincible = false;
                    }
                    // 2. íƒ„ë§‰ ë°œì‚¬
                    if (now - character.lastBarrage > character.barrageCooldown) {
                        const count = 18;
                        for (let i = 0; i < count; i++) {
                            const angle = (Math.PI * 2) * (i / count);
                            this.gameState.projectiles.push({
                                id: Date.now() + Math.random(),
                                x: character.x + character.width / 2,
                                y: character.y + character.height / 2,
                                vx: Math.cos(angle) * 7,
                                vy: Math.sin(angle) * 7,
                                radius: 5,
                                damage: character.damage * 0.7,
                                life: 90,
                                color: character.color,
                                ownerId: character.id
                            });
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'íƒ„ë§‰!', 'cyan');
                        character.lastBarrage = now;
                    }
                    // 3. ì²´ë ¥ íšŒë³µ
                    if (now - character.lastHeal > character.healCooldown) {
                        character.health = Math.min(character.maxHealth, character.health + character.healAmount);
                        this.createFloatingText(character.x + character.width/2, character.y-20, `+${character.healAmount} íšŒë³µ!`, 'green');
                        character.lastHeal = now;
                    }
                }
                if (character.type === 'boss_gamma') {
                    // 1. ìˆœê°„ì´ë™
                    if (now - character.lastTeleport > character.teleportCooldown) {
                        const newX = player.x + (Math.random() - 0.5) * character.teleportRange;
                        const newY = player.y + (Math.random() - 0.5) * character.teleportRange;
                        character.x = Math.max(0, Math.min(this.canvas.width - character.width, newX));
                        character.y = Math.max(50, Math.min(this.canvas.height - this.GROUND_Y - character.height, newY));
                        this.createCollectParticles(character.x, character.y, character.color);
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ìˆœê°„ì´ë™!', 'orange');
                        character.lastTeleport = now;
                    }
                    // 2. ë ˆì´ì €
                    if (now - character.lastLaser > character.laserCooldown) {
                        // í”Œë ˆì´ì–´ ë°©í–¥ìœ¼ë¡œ ê°•ë ¥í•œ ë ˆì´ì €(ì§ì„ ìƒ í­ë°œ)
                        const angle = Math.atan2(player.y - character.y, player.x - character.x);
                        for (let d = 60; d < 400; d += 40) {
                            const lx = character.x + character.width/2 + Math.cos(angle) * d;
                            const ly = character.y + character.height/2 + Math.sin(angle) * d;
                            this.createExplosion(lx, ly, 40, character.damage * 1.2, character.id);
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ë ˆì´ì €!', 'red');
                        character.lastLaser = now;
                    }
                    // 3. ì†ë„ ë²„í”„
                    if (!character.isSpeedBuffed && now - character.lastSpeedBuff > character.speedBuffCooldown) {
                        character.speed *= 2;
                        character.isSpeedBuffed = true;
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ì†ë„ ë²„í”„!', 'lime');
                        setTimeout(() => {
                            character.speed /= 2;
                            character.isSpeedBuffed = false;
                        }, character.speedBuffDuration);
                        character.lastSpeedBuff = now;
                    }
                }
                if (character.type === 'boss_delta') {
                    // 1. ë¸”ë™í™€ (ì¿¨ë‹¤ìš´ ì¦ê°€, íš¨ê³¼ ê°ì†Œ)
                    if (now - character.lastBlackhole > (character.blackholeCooldown || 15000)) {
                        const dx = (character.x + character.width/2) - (player.x + player.width/2);
                        const dy = (character.y + character.height/2) - (player.y + player.height/2);
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < 600) {
                            player.vx += dx/dist * 15; // íš¨ê³¼ ê°ì†Œ
                            player.vy += dy/dist * 15;
                            if (!character.lastBlackholeEffect || now - character.lastBlackholeEffect > 2000) {
                                this.createFloatingText(player.x + player.width/2, player.y-20, 'ë¸”ë™í™€!', 'purple');
                                character.lastBlackholeEffect = now;
                            }
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ë¸”ë™í™€!', 'purple');
                        character.lastBlackhole = now;
                    }
                    // 2. ê´‘ì—­ í­ë°œ (ë°ë¯¸ì§€ ê°ì†Œ)
                    if (now - character.lastExplosion > (character.explosionCooldown || 12000)) {
                        this.createExplosion(character.x + character.width/2, character.y + character.height/2, 100, character.damage * 0.8, character.id);
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ê´‘ì—­ í­ë°œ!', 'red');
                        character.lastExplosion = now;
                    }
                    // 3. í”Œë ˆì´ì–´ ë‘”í™” (íš¨ê³¼ ê°ì†Œ, ì¤‘ë³µ ë°©ì§€)
                    if (now - character.lastSlow > (character.slowCooldown || 10000)) {
                        if (!player.isSlowed) {
                            player.isSlowed = true;
                            player.originalSpeed = player.speed;
                            player.speed = Math.max(2, player.speed * 0.7); // ë‘”í™” íš¨ê³¼ ê°ì†Œ
                            this.createFloatingText(player.x + player.width/2, player.y-20, 'ë‘”í™”!', 'blue');
                            setTimeout(() => { 
                                player.speed = player.originalSpeed || 5; 
                                player.isSlowed = false;
                            }, character.slowDuration || 3000);
                        }
                        character.lastSlow = now;
                    }
                }
                if (character.type === 'boss_epsilon') {
                    // 1. ë¶„ì‹  ìƒì„±
                    if (!character.hasCloned && now - character.lastClone > character.cloneCooldown) {
                        for (let i = 0; i < character.clones; i++) {
                            const clone = this.createEnemy('boss_epsilon');
                            clone.health = Math.floor(character.health * 0.3);
                            clone.x = character.x + (Math.random() - 0.5) * 120;
                            clone.y = character.y + (Math.random() - 0.5) * 120;
                            this.gameState.enemies.push(clone);
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ë¶„ì‹ !', 'yellow');
                        character.hasCloned = true;
                        character.lastClone = now;
                    }
                    // 2. íƒ„í™˜ ë°˜ì‚¬
                    if (!character.isReflecting && now - character.lastReflect > character.reflectCooldown) {
                        character.isReflecting = true;
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'íƒ„í™˜ ë°˜ì‚¬!', 'cyan');
                        setTimeout(() => { character.isReflecting = false; }, character.reflectDuration);
                        character.lastReflect = now;
                    }
                    // 3. ì²´ë ¥ í¡ìˆ˜
                    if (now - character.lastDrain > character.drainCooldown) {
                        player.health = Math.max(0, player.health - character.drainAmount);
                        character.health = Math.min(character.maxHealth, character.health + character.drainAmount);
                        this.createFloatingText(player.x + player.width/2, player.y-20, `-${character.drainAmount} í¡ìˆ˜!`, 'purple');
                        this.createFloatingText(character.x + character.width/2, character.y-20, `+${character.drainAmount} í¡ìˆ˜!`, 'purple');
                        character.lastDrain = now;
                    }
                }
                if (character.type === 'boss_zeta') {
                    // 1. ì‹œê°„ ì™œê³¡(ìŠ¬ë¡œìš°) - ì¿¨ë‹¤ìš´ ì¦ê°€
                    if (!character.isTimeWarp && now - character.lastTimeWarp > (character.timeWarpCooldown || 12000)) {
                        this.gameState.timeSlowEffect = 0.6; // íš¨ê³¼ ê°ì†Œ
                        character.isTimeWarp = true;
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ì‹œê°„ ì™œê³¡!', 'blue');
                        setTimeout(() => {
                            this.gameState.timeSlowEffect = 1;
                            character.isTimeWarp = false;
                        }, character.timeWarpDuration || 2000);
                        character.lastTimeWarp = now;
                    }
                    // 2. ì—°ë°œ ì‚¬ê²© - ë°ë¯¸ì§€ ê°ì†Œ
                    if (!character.isRapidFire && now - character.lastRapidFire > (character.rapidFireCooldown || 10000)) {
                        character.isRapidFire = true;
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ì—°ë°œ ì‚¬ê²©!', 'orange');
                        let shots = 0;
                        const rapid = () => {
                            if (shots < 8) { // ë°œì‚¬ ìˆ˜ ê°ì†Œ
                                const angle = Math.atan2(player.y - character.y, player.x - character.x) + (Math.random()-0.5)*0.3;
                                this.gameState.projectiles.push({
                                    id: Date.now() + Math.random(),
                                    x: character.x + character.width / 2,
                                    y: character.y + character.height / 2,
                                    vx: Math.cos(angle) * 10, // ì†ë„ ê°ì†Œ
                                    vy: Math.sin(angle) * 10,
                                    radius: 4, // í¬ê¸° ê°ì†Œ
                                    damage: character.damage * 0.5, // ë°ë¯¸ì§€ ê°ì†Œ
                                    life: 80,
                                    color: character.color,
                                    ownerId: character.id
                                });
                                shots++;
                                setTimeout(rapid, 120); // ë°œì‚¬ ê°„ê²© ì¦ê°€
                            } else {
                                character.isRapidFire = false;
                            }
                        };
                        rapid();
                        character.lastRapidFire = now;
                    }
                    // 3. ëœë¤ ìœ„ì¹˜ ì´ë™ - ì¿¨ë‹¤ìš´ ì¦ê°€
                    if (now - character.lastRandomMove > (character.randomMoveCooldown || 15000)) {
                        character.x = Math.random() * (this.canvas.width - character.width);
                        character.y = Math.random() * (this.canvas.height - this.GROUND_Y - character.height);
                        this.createCollectParticles(character.x, character.y, character.color);
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ìˆœê°„ì´ë™!', 'cyan');
                        character.lastRandomMove = now;
                    }
                }
                if (character.type === 'boss_eta') {
                    // 1. ë ˆì´ì € (ë°ë¯¸ì§€ ê°ì†Œ, ì¿¨ë‹¤ìš´ ì¦ê°€)
                    if (now - character.lastLaser > (character.laserCooldown || 12000)) {
                        const angle = Math.atan2(player.y - character.y, player.x - character.x);
                        for (let d = 60; d < 300; d += 50) { // ë²”ìœ„ ê°ì†Œ
                            const lx = character.x + character.width/2 + Math.cos(angle) * d;
                            const ly = character.y + character.height/2 + Math.sin(angle) * d;
                            this.createExplosion(lx, ly, 30, character.damage * 0.8, character.id); // ë°ë¯¸ì§€ ê°ì†Œ
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ë ˆì´ì €!', 'red');
                        character.lastLaser = now;
                    }
                    // 2. ì—°ì† ì í”„ (ì í”„ ìˆ˜ ê°ì†Œ)
                    if (now - character.lastJump > (character.jumpCooldown || 10000)) {
                        let jumpIdx = 0;
                        const jump = () => {
                            if (jumpIdx < (character.jumpCount || 2)) { // ì í”„ ìˆ˜ ê°ì†Œ
                                character.vy = -(character.jumpPower || 20);
                                this.createFloatingText(character.x + character.width/2, character.y-20, 'ì í”„!', 'lime');
                                jumpIdx++;
                                setTimeout(jump, 500); // ê°„ê²© ì¦ê°€
                            }
                        };
                        jump();
                        character.lastJump = now;
                    }
                    // 3. ë°©ì–´ë ¥ ì¦ê°€ (íš¨ê³¼ ê°ì†Œ)
                    if (!character.isArmorBuffed && now - character.lastArmorBuff > (character.armorBuffCooldown || 15000)) {
                        character.armor = (character.armor || 0) + 10; // ë°©ì–´ë ¥ ê°ì†Œ
                        character.isArmorBuffed = true;
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ë°©ì–´ë ¥ ì¦ê°€!', 'blue');
                        setTimeout(() => {
                            character.armor = (character.armor || 0) - 10;
                            character.isArmorBuffed = false;
                        }, character.armorBuffDuration || 3000);
                        character.lastArmorBuff = now;
                    }
                }
                if (character.type === 'boss_theta') {
                    // 1. ë°œì‚¬ì²´ ë°˜ì‚¬ (ê°•í™”)
                    if (!character.isReflecting && now - character.lastReflectAll > (character.reflectAllCooldown || 8000)) {
                        character.isReflecting = true;
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ë°œì‚¬ì²´ ë°˜ì‚¬!', 'cyan');
                        setTimeout(() => { character.isReflecting = false; }, character.reflectAllDuration || 3000);
                        character.lastReflectAll = now;
                    }
                    // 2. ë„íƒ„ íƒ„í™˜ (ê°•í™”)
                    if (now - character.lastRicochet > (character.ricochetCooldown || 6000)) {
                        for (let i = 0; i < (character.ricochetCount || 6); i++) {
                            const angle = (Math.PI * 2) * (i / (character.ricochetCount || 6));
                            this.gameState.projectiles.push({
                                id: Date.now() + Math.random(),
                                x: character.x + character.width / 2,
                                y: character.y + character.height / 2,
                                vx: Math.cos(angle) * 12,
                                vy: Math.sin(angle) * 12,
                                radius: 6,
                                damage: character.damage * 0.8,
                                life: 150,
                                color: character.color,
                                ownerId: character.id,
                                bounceCount: 5
                            });
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ë„íƒ„ íƒ„í™˜!', 'orange');
                        character.lastRicochet = now;
                    }
                    // 3. í”Œë ˆì´ì–´ ìœ„ì¹˜ ì¶”ì  (ê°•í™”)
                    if (!character.isTracking && now - character.lastTrack > (character.trackCooldown || 10000)) {
                        character.isTracking = true;
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ìœ„ì¹˜ ì¶”ì !', 'purple');
                        // ì¶”ì  ì¤‘ì—ëŠ” í”Œë ˆì´ì–´ë¥¼ í–¥í•´ ë¹ ë¥´ê²Œ ì´ë™
                        const trackInterval = setInterval(() => {
                            if (!character.isTracking) {
                                clearInterval(trackInterval);
                                return;
                            }
                            const dx = player.x - character.x;
                            const dy = player.y - character.y;
                            const angle = Math.atan2(dy, dx);
                            character.vx += Math.cos(angle) * 2;
                            character.vy += Math.sin(angle) * 2;
                        }, 100);
                        setTimeout(() => { 
                            character.isTracking = false;
                            clearInterval(trackInterval);
                        }, character.trackDuration || 4000);
                        character.lastTrack = now;
                    }
                    // 4. ìƒˆë¡œìš´ ëŠ¥ë ¥: ì‹œê°„ ì—­í–‰ (í”Œë ˆì´ì–´ì˜ ëŠ¥ë ¥ì„ ì¼ì‹œì ìœ¼ë¡œ ë˜ëŒë¦¼)
                    if (now - character.lastTimeReverse > (character.timeReverseCooldown || 20000)) {
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ì‹œê°„ ì—­í–‰!', 'purple');
                        // í”Œë ˆì´ì–´ì˜ ëŠ¥ë ¥ì„ ì¼ì‹œì ìœ¼ë¡œ ë˜ëŒë¦¼
                        const originalSpeed = player.speed;
                        const originalDamage = player.baseDamage;
                        player.speed = Math.max(2, player.speed * 0.5);
                        player.baseDamage = Math.max(5, player.baseDamage * 0.7);
                        this.createFloatingText(player.x + player.width/2, player.y-20, 'ëŠ¥ë ¥ ì•½í™”!', 'red');
                        setTimeout(() => {
                            player.speed = originalSpeed;
                            player.baseDamage = originalDamage;
                            this.createFloatingText(player.x + player.width/2, player.y-20, 'ëŠ¥ë ¥ íšŒë³µ!', 'green');
                        }, 5000);
                        character.lastTimeReverse = now;
                    }
                }
            }
            
            // ë°œì‚¬ì²´ ìƒíƒœ ì—…ë°ì´íŠ¸ ë° ì¶©ëŒ ê°ì§€ (ìœ ë ¹ ë¬´ì  ìƒíƒœ ì²˜ë¦¬ ì¶”ê°€)
            updateProjectiles = () => {
                const projectilesToRemove = new Set();
                const player = this.gameState.player;
                
                // 1. ë°œì‚¬ì²´ ì´ë™/ìˆ˜ëª… ë° ë„íƒ„ ì²˜ë¦¬
                for (let i = 0; i < this.gameState.projectiles.length; i++) {
                    const p = this.gameState.projectiles[i];
                    
                    // ë„íƒ„ ì²˜ë¦¬
                    if (p.bounceCount && p.bounceCount > 0) {
                        if (p.x < 0 || p.x > this.canvas.width) {
                            p.vx *= -1;
                            p.bounceCount--;
                            p.x = Math.max(0, Math.min(this.canvas.width, p.x));
                        }
                        if (p.y < 0 || p.y > this.canvas.height) {
                            p.vy *= -1;
                            p.bounceCount--;
                            p.y = Math.max(0, Math.min(this.canvas.height, p.y));
                        }
                    }
                    
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life--;
                    if (
                        p.x < -100 || p.x > this.canvas.width + 100 ||
                        p.y < -100 || p.y > this.canvas.height + 100 ||
                        p.life <= 0
                    ) {
                        projectilesToRemove.add(i);
                        continue;
                    }
                }
                // Homing logic: adjust velocity of homing projectiles
                for (let i = 0; i < this.gameState.projectiles.length; i++) {
                    const p = this.gameState.projectiles[i];
                    if (p.isHoming) {
                        let nearest = null, minDist = 99999;
                        for (const enemy of this.gameState.enemies) {
                            const dx = enemy.x + enemy.width/2 - p.x;
                            const dy = enemy.y + enemy.height/2 - p.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist < minDist) { minDist = dist; nearest = enemy; }
                        }
                        // Homing parameters
                        const maxTurn = (p.homingStrength || 0.03) * Math.PI; // ìµœëŒ€ íšŒì „ ê°ë„ (ë¼ë””ì•ˆ)
                        const speed = Math.sqrt(p.vx*p.vx + p.vy*p.vy) || 8;
                        if (nearest) {
                            const dx = nearest.x + nearest.width/2 - p.x;
                            const dy = nearest.y + nearest.height/2 - p.y;
                            const targetAngle = Math.atan2(dy, dx);
                            let currentAngle = Math.atan2(p.vy, p.vx);
                            let delta = targetAngle - currentAngle;
                            // -PI ~ PIë¡œ ë³´ì •
                            while (delta > Math.PI) delta -= 2*Math.PI;
                            while (delta < -Math.PI) delta += 2*Math.PI;
                            // íšŒì „ ê°ë„ ì œí•œ
                            if (Math.abs(delta) > maxTurn) delta = maxTurn * Math.sign(delta);
                            const newAngle = currentAngle + delta;
                            p.vx = Math.cos(newAngle) * speed;
                            p.vy = Math.sin(newAngle) * speed;
                        } else {
                            // ì ì´ ì—†ìœ¼ë©´ ê¸°ì¡´ ë°©í–¥/ì†ë„ ìœ ì§€ (ì •ì§€í•˜ì§€ ì•ŠìŒ)
                            // ì•„ë¬´ê²ƒë„ í•˜ì§€ ì•ŠìŒ
                        }
                    }
                }
                // 2. í”Œë ˆì´ì–´ ë°œì‚¬ì²´ â†’ ì  ì¶©ëŒ
                for (let i = 0; i < this.gameState.projectiles.length; i++) {
                    const p = this.gameState.projectiles[i];
                    if (p.ownerId === 'player' || p.ownerId === 'player2') {
                        if (p.ownerId === 'player2') {
                            console.log('í”Œë ˆì´ì–´2 ë°œì‚¬ì²´ ì¶©ëŒ ì²´í¬:', p);
                        }
                        for (let j = 0; j < this.gameState.enemies.length; j++) {
                            const enemy = this.gameState.enemies[j];
                            if (!enemy) continue;
                            const dx = p.x - (enemy.x + enemy.width / 2);
                            const dy = p.y - (enemy.y + enemy.height / 2);
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < (p.radius || 0) + (enemy.width || 0) / 2) {
                                // ìœ ë ¹/ë³´ìŠ¤ ì‰´ë“œ ë¬´ì  ì²´í¬
                                if (enemy.type === 'ghost' && enemy.isInvincible) continue;
                                if (enemy.type === 'boss_beta' && enemy.isInvincible) continue;
                                
                                // ë°˜ì‚¬ ì  ë°˜ì‚¬ ì²´í¬
                                if (enemy.type === 'reflector' && Math.random() < (enemy.reflectChance || 0.3)) {
                                    // íƒ„í™˜ì„ ë°˜ì‚¬ì‹œí‚´ (90% ë°ë¯¸ì§€ë¡œ)
                                    const reflectedDamage = Math.floor(p.damage * 0.9);
                                    const angle = Math.atan2(p.vy, p.vx);
                                    const reflectedAngle = angle + Math.PI + (Math.random() - 0.5) * Math.PI / 2;
                                    
                                    this.gameState.projectiles.push({
                                        id: Date.now() + Math.random(),
                                        x: enemy.x + enemy.width / 2,
                                        y: enemy.y + enemy.height / 2,
                                        vx: Math.cos(reflectedAngle) * 6,
                                        vy: Math.sin(reflectedAngle) * 6,
                                        radius: p.radius,
                                        damage: reflectedDamage,
                                        life: 60,
                                        color: '#ff6b6b',
                                        ownerId: 'enemy',
                                        pierceCount: 0,
                                        explosiveRadius: 0,
                                        bounceCount: 0,
                                        isHoming: false,
                                        homingStrength: 0,
                                        splitCount: 0,
                                        hitEnemies: []
                                    });
                                    
                                    this.createFloatingText(enemy.x + enemy.width / 2, enemy.y, 'ë°˜ì‚¬!', 'orange');
                                    projectilesToRemove.add(i);
                                    continue;
                                }
                                
                                enemy.health -= p.damage;
                                // ì¹˜ëª…íƒ€ ì‹œê°ì  í”¼ë“œë°±
                                if (p.isCritical) {
                                    this.createFloatingText(enemy.x + enemy.width / 2, enemy.y, `-${p.damage} ì¹˜ëª…íƒ€!`, '#ff0000'); // ë¹¨ê°„ìƒ‰ìœ¼ë¡œ ì¹˜ëª…íƒ€ í‘œì‹œ
                                    this.createFloatingText(enemy.x + enemy.width / 2, enemy.y - 20, 'ğŸ’¥', '#ff0000'); // ì¹˜ëª…íƒ€ ì´ëª¨ì§€
                                } else {
                                    this.createFloatingText(enemy.x + enemy.width / 2, enemy.y, `-${p.damage}`, 'white');
                                }
                                this.createHitParticles(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                                // í­ë°œ ì‚¬ê²©
                                if (p.explosiveRadius && p.explosiveRadius > 0) {
                                    this.createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, p.explosiveRadius, Math.floor(p.damage / 2), p.ownerId);
                                }
                                // ë¶„ì—´ ì‚¬ê²©
                                if (p.splitCount && p.splitCount > 0) {
                                    this.createSplitProjectiles(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, p.damage, p.ownerId, p.radius, p.splitCount);
                                }
                                if (enemy.health <= 0) {
                                    this.addScore(enemy.points || 100);
                                    if (Math.random() < 0.4) this.gameState.items.push(this.createItem(enemy.x, enemy.y));
                                    // í­ë°œ ì  ì‚¬ë§ ì‹œ í­ë°œ
                                    if (enemy.type === 'exploder') {
                                        this.createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2, enemy.explodeRadius || 70, enemy.damage, enemy.id);
                                        this.createFloatingText(enemy.x + enemy.width/2, enemy.y-20, 'í­ë°œ!', 'orange');
                                    }
                                    // === ë³´ìŠ¤ ì‚¬ë§ ì²˜ë¦¬ ì¶”ê°€ ===
                                    if (enemy.type && enemy.type.startsWith('boss')) {
                                        if (this.bossSystem && this.bossSystem.currentBoss && this.bossSystem.currentBoss.id === enemy.id) {
                                            this.bossSystem.currentBoss = null;
                                        }
                                        this.checkBossWaveComplete(); // â† ë¨¼ì € í˜¸ì¶œ
                                        this.resetBossSystem();
                                    }
                                    // =========================
                                    this.gameState.enemies = this.gameState.enemies.filter(e => e !== enemy);
                                }
                                projectilesToRemove.add(i);
                                break;
                            }
                        }
                    }
                }
                // 3. ì  ë°œì‚¬ì²´ â†’ í”Œë ˆì´ì–´ ì¶©ëŒ
                for (let i = 0; i < this.gameState.projectiles.length; i++) {
                    const p = this.gameState.projectiles[i];
                    // Only enemy bullets (not player, player2, ally, or any player-owned projectiles) can hit the player
                    if (p.ownerId && p.ownerId !== 'player' && p.ownerId !== 'player2' && p.ownerId !== 'ally') {
                        // í”Œë ˆì´ì–´1 ì¶©ëŒ ì²´í¬
                        const dx = p.x - (player.x + player.width / 2);
                        const dy = p.y - (player.y + player.height / 2);
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < (p.radius || 0) + (player.width || 0) / 2) {
                            // ë¬´ì  ì²´í¬
                            if (Date.now() < player.invincibleEndTime) {
                                this.createFloatingText(player.x + player.width / 2, player.y, `ë¬´ì !`, 'gold');
                            } else {
                                let actualDamage = p.damage;
                                actualDamage = Math.max(0, actualDamage - player.armor);
                                if (Date.now() < player.shieldBoostEndTime) {
                                    actualDamage *= player.damageReductionFactor;
                                    this.createFloatingText(player.x + player.width / 2, player.y, `-${actualDamage.toFixed(0)} (ì‰´ë“œ)`, 'lightblue');
                                } else {
                                    this.createFloatingText(player.x + player.width / 2, player.y, `-${actualDamage.toFixed(0)}`, 'red');
                                }
                                player.health -= actualDamage;
                                this.createHitParticles(player.x + player.width / 2, player.y + player.height / 2);
                                player.lastHitById = p.ownerId;
                                
                                // ìŠ¬ë¼ì„ë³‘ ëŠë ¤ì§€ëŠ” íš¨ê³¼
                                if (p.slowEffect && p.slowDuration) {
                                    player.speed *= p.slowEffect;
                                    this.createFloatingText(player.x + player.width / 2, player.y - 30, 'ëŠë ¤ì§!', 'lightblue');
                                    setTimeout(() => {
                                        player.speed = this.ENEMY_TYPES[player.type]?.speed || 5;
                                    }, p.slowDuration);
                                }
                                
                                if (player.health <= 0) {
                                    if (this.gameState.multiplayerMode) {
                                        this.handlePlayerDeath('player1');
                                    } else {
                                        this.gameOver();
                                    }
                                }
                            }
                            projectilesToRemove.add(i);
                        }
                        
                        // í”Œë ˆì´ì–´2 ì¶©ëŒ ì²´í¬ (ë©€í‹°í”Œë ˆì´ ëª¨ë“œì¼ ë•Œë§Œ)
                        if (this.gameState.player2 && this.gameState.multiplayerMode && !this.gameState.player2Dead) {
                            const dx2 = p.x - (this.gameState.player2.x + this.gameState.player2.width / 2);
                            const dy2 = p.y - (this.gameState.player2.y + this.gameState.player2.height / 2);
                            const dist2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                            if (dist2 < (p.radius || 0) + (this.gameState.player2.width || 0) / 2) {
                                // ë¬´ì  ì²´í¬
                                if (Date.now() < this.gameState.player2.invincibleEndTime) {
                                    this.createFloatingText(this.gameState.player2.x + this.gameState.player2.width / 2, this.gameState.player2.y, `ë¬´ì !`, 'gold');
                                } else {
                                    let actualDamage = p.damage;
                                    actualDamage = Math.max(0, actualDamage - this.gameState.player2.armor);
                                    if (Date.now() < this.gameState.player2.shieldBoostEndTime) {
                                        actualDamage *= this.gameState.player2.damageReductionFactor;
                                        this.createFloatingText(this.gameState.player2.x + this.gameState.player2.width / 2, this.gameState.player2.y, `-${actualDamage.toFixed(0)} (ì‰´ë“œ)`, 'lightblue');
                                    } else {
                                        this.createFloatingText(this.gameState.player2.x + this.gameState.player2.width / 2, this.gameState.player2.y, `-${actualDamage.toFixed(0)}`, 'red');
                                    }
                                    this.gameState.player2.health -= actualDamage;
                                    this.createHitParticles(this.gameState.player2.x + this.gameState.player2.width / 2, this.gameState.player2.y + this.gameState.player2.height / 2);
                                    this.gameState.player2.lastHitById = p.ownerId;
                                    
                                    // ìŠ¬ë¼ì„ë³‘ ëŠë ¤ì§€ëŠ” íš¨ê³¼
                                    if (p.slowEffect && p.slowDuration) {
                                        this.gameState.player2.speed *= p.slowEffect;
                                        this.createFloatingText(this.gameState.player2.x + this.gameState.player2.width / 2, this.gameState.player2.y - 30, 'ëŠë ¤ì§!', 'lightblue');
                                        setTimeout(() => {
                                            this.gameState.player2.speed = 5;
                                        }, p.slowDuration);
                                    }
                                    
                                    if (this.gameState.player2.health <= 0) {
                                        this.handlePlayerDeath('player2');
                                    }
                                }
                                projectilesToRemove.add(i);
                            }
                        }
                        
                        // ë‹¤ë¥¸ ì˜¨ë¼ì¸ í”Œë ˆì´ì–´ë“¤ê³¼ì˜ ì¶©ëŒ ì²´í¬
                        if (this.gameState.otherPlayers) {
                            Object.entries(this.gameState.otherPlayers).forEach(([name, otherPlayer]) => {
                                if (otherPlayer && otherPlayer.isAlive !== false) {
                                    const dx = p.x - (otherPlayer.x + otherPlayer.width / 2);
                                    const dy = p.y - (otherPlayer.y + otherPlayer.height / 2);
                                    const dist = Math.sqrt(dx * dx + dy * dy);
                                    if (dist < (p.radius || 0) + (otherPlayer.width || 0) / 2) {
                                        // ë‹¤ë¥¸ í”Œë ˆì´ì–´ì—ê²Œ í”¼í•´ í‘œì‹œ (ì‹¤ì œë¡œëŠ” í”¼í•´ë¥¼ ì£¼ì§€ ì•ŠìŒ)
                                        this.createFloatingText(otherPlayer.x + otherPlayer.width / 2, otherPlayer.y, `-${p.damage}`, 'red');
                                        this.createHitParticles(otherPlayer.x + otherPlayer.width / 2, otherPlayer.y + otherPlayer.height / 2);
                                        projectilesToRemove.add(i);
                                    }
                                }
                            });
                        }
                    }
                }
                // 4. ë°œì‚¬ì²´ë¼ë¦¬ ì¶©ëŒ(í”Œë ˆì´ì–´ vs ì )
                for (let i = 0; i < this.gameState.projectiles.length; i++) {
                    const p1 = this.gameState.projectiles[i];
                    if (p1.ownerId === 'player' || p1.ownerId === 'player2') {
                        for (let j = 0; j < this.gameState.projectiles.length; j++) {
                            if (i === j) continue;
                            const p2 = this.gameState.projectiles[j];
                            if (p2.ownerId && p2.ownerId !== 'player' && p2.ownerId !== 'ally') {
                                const dx = p1.x - p2.x;
                                const dy = p1.y - p2.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist < (p1.radius || 0) + (p2.radius || 0)) {
                                    projectilesToRemove.add(i);
                                    projectilesToRemove.add(j);
                                }
                            }
                        }
                    }
                }
                // ì‹¤ì œë¡œ ì œê±°
                this.gameState.projectiles = this.gameState.projectiles.filter((_, idx) => !projectilesToRemove.has(idx));
            };

            // ë¶„ì—´ ì‚¬ê²© (Split Shot) ì‹œ ì‘ì€ ë°œì‚¬ì²´ ìƒì„±
            createSplitProjectiles = (x, y, baseDamage, ownerId, parentRadius, splitLevel) => {
                const numSplits = 3 + splitLevel; // ë ˆë²¨ì— ë”°ë¼ ë¶„ì—´ë˜ëŠ” ì‘ì€ íƒ„í™˜ ìˆ˜ ì¦ê°€
                const splitSpeed = 5; // ì‘ì€ íƒ„í™˜ ì†ë„
                const splitDamage = baseDamage * 0.5; // ì‘ì€ íƒ„í™˜ ë°ë¯¸ì§€ (ì›ë³¸ì˜ ì ˆë°˜)
                const splitRadius = parentRadius / 1.5; // ì‘ì€ íƒ„í™˜ ë°˜ì§€ë¦„

                for (let i = 0; i < numSplits; i++) {
                    const splitAngle = Math.random() * Math.PI * 2; // ë¬´ì‘ìœ„ ë°©í–¥
                    this.gameState.projectiles.push({
                        id: Date.now() + Math.random(),
                        x: x,
                        y: y,
                        vx: Math.cos(splitAngle) * splitSpeed,
                        vy: Math.sin(splitAngle) * splitSpeed,
                        radius: 3, // ê¸°ì¡´ 7ì—ì„œ 4ë¡œ í•˜í–¥
                        damage: splitDamage,
                        life: 60, // ì§§ì€ ìˆ˜ëª…
                        color: '#9932cc', // ë¶„ì—´ ì‚¬ê²© ìƒ‰ìƒ
                        ownerId: ownerId,
                        pierceCount: 0,
                        explosiveRadius: 0,
                        bounceCount: 0,
                        isHoming: false,
                        homingStrength: 0,
                        splitCount: 0, // ë¶„ì—´ëœ íƒ„í™˜ì€ ë‹¤ì‹œ ë¶„ì—´í•˜ì§€ ì•ŠìŒ
                        hitEnemies: []
                    });
                }
            }

            // í­ë°œ íš¨ê³¼ ìƒì„± (ìˆ˜ë¥˜íƒ„ í­ë°œì—ë§Œ ì‚¬ìš©ë¨)
            createExplosion = (x, y, radius, damage, ownerId) => { // ownerId ì¶”ê°€
                // íŒŒí‹°í´ ìƒì„±
                for (let i = 0; i < 30; i++) {
                    this.gameState.particles.push({
                        x: x, y: y,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        life: 40, maxLife: 40,
                        color: '#ff4500', // ì£¼í™©ìƒ‰ í­ë°œ ìƒ‰ìƒ
                        size: Math.random() * 5 + 2
                    });
                }

                // í”Œë ˆì´ì–´ì—ê²Œ ë²”ìœ„ í”¼í•´ ì ìš© (ìˆ˜ë¥˜íƒ„ í­ë°œì—ë§Œ í•´ë‹¹)
                const player = this.gameState.player;
                let dx = x - (player.x + player.width / 2);
                let dy = y - (player.y + player.height / 2);
                let distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < radius + player.width / 2) {
                    // í”Œë ˆì´ì–´ ë¬´ì  ìƒíƒœ ì²´í¬
                    if (Date.now() < player.invincibleEndTime) {
                        this.createFloatingText(player.x + player.width / 2, player.y, `ë¬´ì !`, 'gold');
                    } else {
                        // í”Œë ˆì´ì–´ê°€ ë°œì‚¬í•œ ìˆ˜ë¥˜íƒ„ í­ë°œì—ëŠ” í”¼í•´ë¥¼ ì…ì§€ ì•Šë„ë¡
                        if (ownerId === 'player') {
                            this.createFloatingText(player.x + player.width / 2, player.y, `íšŒí”¼!`, 'cyan');
                            // ìˆ˜ë¥˜íƒ„ í­ë°œì— ì˜í•œ ì‚¬ë§ì€ ê¸°ë¡í•˜ì§€ ì•ŠìŒ
                            return; 
                        }

                        let actualDamage = damage;
                        // ë°©ì–´ë ¥ ì ìš©
                        actualDamage = Math.max(0, actualDamage - this.gameState.player.armor);
                        if (Date.now() < player.shieldBoostEndTime) {
                            actualDamage *= player.damageReductionFactor;
                            this.createFloatingText(player.x + player.width / 2, player.y, `-${actualDamage.toFixed(0)} (ì‰´ë“œ)`, 'lightblue');
                        } else {
                            this.createFloatingText(player.x + player.width / 2, player.y, `-${actualDamage.toFixed(0)}`, 'red'); // ë°ë¯¸ì§€ í…ìŠ¤íŠ¸
                        }
                        player.health -= actualDamage;
                        this.createHitParticles(player.x + player.width / 2, player.y + player.height / 2);
                        
                        // í­ë°œë¡œ ì¸í•œ í”¼í•´ì¼ ê²½ìš° ë§ˆì§€ë§‰ í”¼í•´ì ID ì €ì¥ (ìˆ˜ë¥˜íƒ„ì´ ì•„ë‹Œ ë‹¤ë¥¸ í­ë°œì— ëŒ€ë¹„)
                        this.gameState.player.lastHitById = ownerId;

                        if (player.health <= 0) {
                            if (this.gameState.multiplayerMode) {
                                this.handlePlayerDeath('player1');
                            } else {
                                this.gameOver();
                            }
                        }
                        
                                        // í”Œë ˆì´ì–´2 ì²´ë ¥ ì²´í¬ (ë©€í‹°í”Œë ˆì´ ëª¨ë“œì¼ ë•Œë§Œ)
                if (this.gameState.player2 && this.gameState.multiplayerMode && this.gameState.player2.health <= 0) {
                    this.handlePlayerDeath('player2');
                }
                
                // ë‹¤ë¥¸ ì˜¨ë¼ì¸ í”Œë ˆì´ì–´ë“¤ê³¼ì˜ í­ë°œ ì¶©ëŒ ì²´í¬
                if (this.gameState.otherPlayers) {
                    Object.entries(this.gameState.otherPlayers).forEach(([name, otherPlayer]) => {
                        if (otherPlayer && otherPlayer.isAlive !== false) {
                            const dx = x - (otherPlayer.x + otherPlayer.width / 2);
                            const dy = y - (otherPlayer.y + otherPlayer.height / 2);
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < radius + otherPlayer.width / 2) {
                                // ë‹¤ë¥¸ í”Œë ˆì´ì–´ì—ê²Œ í”¼í•´ í‘œì‹œ (ì‹¤ì œë¡œëŠ” í”¼í•´ë¥¼ ì£¼ì§€ ì•ŠìŒ)
                                this.createFloatingText(otherPlayer.x + otherPlayer.width / 2, otherPlayer.y, `-${damage}`, 'red');
                                this.createHitParticles(otherPlayer.x + otherPlayer.width / 2, otherPlayer.y + otherPlayer.height / 2);
                            }
                        }
                    });
                }
                    }
                }

                // ì ë“¤ì—ê²Œ ë²”ìœ„ í”¼í•´ ì ìš© (ìˆ˜ë¥˜íƒ„ í­ë°œì—ë§Œ í•´ë‹¹)
                this.gameState.enemies.forEach(enemy => {
                    dx = x - (enemy.x + enemy.width / 2);
                    dy = y - (enemy.y + enemy.height / 2);
                    distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < radius + enemy.width / 2) {
                        // ìœ ë ¹ ë¬´ì  ìƒíƒœ ì²´í¬
                        if (enemy.type === 'ghost' && enemy.isInvincible) return;
                        // ë² íƒ€ ë³´ìŠ¤ ì‰´ë“œ ì²´í¬
                        if (enemy.type === 'boss_beta' && enemy.isInvincible) return;
                        // ë°©íŒ¨ë³‘ ë°©ì–´ ì²´í¬ (í­ë°œì€ ì „ë°©/í›„ë°© ìƒê´€ì—†ì´ í”¼í•´)
                        if (enemy.type === 'shielded') {
                            enemy.health -= damage * 0.5; // ë°©íŒ¨ë³‘ì€ í­ë°œ í”¼í•´ 50% ê°ì†Œ
                            this.createFloatingText(enemy.x + enemy.width / 2, enemy.y, `-${(damage * 0.5).toFixed(0)} (ë°©ì–´)`, 'orange');
                        } else {
                            enemy.health -= damage; // ì ì—ê²Œë„ ë™ì¼í•œ í­ë°œ ë°ë¯¸ì§€
                            this.createFloatingText(enemy.x + enemy.width / 2, enemy.y, `-${damage}`, 'white');
                        }
                        this.createHitParticles(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                        if (enemy.health <= 0) {
                            // ì  ì²˜ì¹˜ ë¡œì§ (ì ìˆ˜, ì•„ì´í…œ ë“œë¡­ ë“±)
                            this.addScore(enemy.points || 100);
                            if (Math.random() < 0.4) this.gameState.items.push(this.createItem(enemy.x, enemy.y));
                            

                            
                            this.gameState.enemies = this.gameState.enemies.filter(e => e.id !== enemy.id);
                        }
                    }
                });

                // ì•„êµ°ì—ê²Œ ë²”ìœ„ í”¼í•´ ì ìš©
                this.gameState.allies.forEach(ally => {
                    dx = x - (ally.x + ally.width / 2);
                    dy = y - (ally.y + ally.height / 2);
                    distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < radius + ally.width / 2) {
                         // ì•„êµ°ì´ ë°œì‚¬í•œ ìˆ˜ë¥˜íƒ„ í­ë°œì—ëŠ” í”¼í•´ë¥¼ ì…ì§€ ì•Šë„ë¡
                        if (ownerId === ally.id) {
                            this.createFloatingText(ally.x + ally.width / 2, ally.y, `íšŒí”¼!`, 'cyan');
                            return; 
                        }

                        ally.health -= damage;
                        this.createFloatingText(ally.x + ally.width / 2, ally.y, `-${damage}`, 'orange');
                        this.createHitParticles(ally.x + ally.width / 2, ally.y + ally.height / 2);
                        if (ally.health <= 0) {
                            this.gameState.allies = this.gameState.allies.filter(a => a.id !== ally.id);
                            this.createFloatingText(ally.x + ally.width / 2, ally.y, `ì‚¬ë§!`, 'grey');
                        }
                    }
                });
            }
            
            // ì•„ì´í…œ ìƒíƒœ ì—…ë°ì´íŠ¸ ë° í”Œë ˆì´ì–´ ì¶©ëŒ ê°ì§€
            updateItems = () => {
                const player = this.gameState.player;
                const now = Date.now();

                // ìì„ íš¨ê³¼ ì ìš©
                if (now < player.magnetEndTime) {
                    this.gameState.items.forEach(item => {
                        const dx = (player.x + player.width / 2) - (item.x + item.width / 2);
                        const dy = (player.y + player.height / 2) - (item.y + item.height / 2);
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < player.magnetRadius) {
                            const force = 0.5; // ìì„ í˜
                            item.vx += (dx / distance) * force;
                            item.vy += (dy / distance) * force;
                        }
                    });
                }


                this.gameState.items = this.gameState.items.filter(item => {
                    if (item.collected) return false; // ì´ë¯¸ ìˆ˜ì§‘ëœ ì•„ì´í…œì€ ì œê±°
                    
                    // ì¤‘ë ¥ ì ìš©
                    if (!item.onGround) {
                        item.vy += this.GRAVITY;
                    }
                    
                    // ì§€ë©´ ì¶©ëŒ ì²˜ë¦¬ (ë°”ìš´ìŠ¤ íš¨ê³¼)
                    if (item.y + item.height > this.canvas.height - this.GROUND_Y) {
                        item.y = this.canvas.height - this.GROUND_Y - item.height;
                        item.vy = -item.vy * 0.5; // ë°”ìš´ìŠ¤ íš¨ê³¼
                        if (Math.abs(item.vy) < 2) {
                            item.vy = 0;
                            item.onGround = true;
                        }
                    }
                    
                    // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                    item.x += item.vx;
                    item.y += item.vy;
                    
                    // ë§ˆì°° ì ìš©
                    item.vx *= 0.98;
                    
                    // í™”ë©´ ê²½ê³„ ì œí•œ
                    item.x = Math.max(0, Math.min(this.canvas.width - item.width, item.x));
                    
                    // ì§€ë©´ì— ìˆì„ ë•Œë§Œ ë– ë‹¤ë‹ˆëŠ” ì• ë‹ˆë©”ì´ì…˜
                    if (item.onGround) {
                        item.y += Math.sin(Date.now() * 0.003 + item.bobOffset) * 1;
                    }
                    
                    // í”Œë ˆì´ì–´ì™€ ì¶©ëŒ ì²´í¬
                    if (player.x < item.x + item.width &&
                        player.x + player.width > item.x &&
                        player.y < item.y + item.height &&
                        player.y + player.height > item.y) {
                        
                        this.collectItem(item); // ì•„ì´í…œ ìˆ˜ì§‘
                        return false; // ì•„ì´í…œ ì œê±°
                    }
                    
                    // í”Œë ˆì´ì–´2ì™€ ì¶©ëŒ ì²´í¬ (ë©€í‹°í”Œë ˆì´ ëª¨ë“œì¼ ë•Œë§Œ)
                    if (this.gameState.player2 && this.gameState.multiplayerMode) {
                        const player2 = this.gameState.player2;
                        if (player2.x < item.x + item.width &&
                            player2.x + player2.width > item.x &&
                            player2.y < item.y + item.height &&
                            player2.y + player2.height > item.y) {
                            
                            this.collectItemPlayer2(item); // í”Œë ˆì´ì–´2 ì•„ì´í…œ ìˆ˜ì§‘
                            return false; // ì•„ì´í…œ ì œê±°
                        }
                    }
                    
                    return true; // ì•„ì´í…œ ìœ ì§€
                });
            }
            
            // í”Œë ˆì´ì–´2 ì•„ì´í…œ ìˆ˜ì§‘ ì‹œ íš¨ê³¼ ì ìš©
            collectItemPlayer2 = (item) => {
                const player2 = this.gameState.player2;
                const now = Date.now();
                
                switch (item.type) {
                    case 'health':
                        player2.health = Math.min(player2.maxHealth, player2.health + item.effect);
                        this.createFloatingText(player2.x + player2.width / 2, player2.y, `+${item.effect}`, 'green');
                        this.showMessage(`P2 +${item.effect} ì²´ë ¥!`, '', 1500);
                        break;
                    case 'ammo':
                        player2.ammo = Math.min(player2.maxAmmo, player2.ammo + item.effect);
                        this.createFloatingText(player2.x + player2.width / 2, player2.y, `+${item.effect}`, 'blue');
                        this.showMessage(`P2 +${item.effect} íƒ„ì•½!`, '', 1500);
                        break;
                    case 'speed':
                        player2.speed = Math.min(10, player2.speed + item.effect);
                        this.showMessage(`P2 ì†ë„ ì¦ê°€!`, `+${item.effect}`, 1500);
                        break;
                    case 'shield':
                        player2.maxHealth += item.effect;
                        player2.health = Math.min(player2.maxHealth, player2.health + item.effect);
                        this.showMessage(`P2 ë°©ì–´ë§‰ ê°•í™”!`, `+${item.effect} ìµœëŒ€ ì²´ë ¥`, 1500);
                        break;
                    case 'damage':
                        player2.baseDamage = (player2.baseDamage || 25) + item.effect;
                        this.showMessage(`P2 ê³µê²©ë ¥ ì¦ê°€!`, `+${item.effect} ë°ë¯¸ì§€`, 1500);
                        break;
                    case 'multishot':
                        player2.multishot = Math.min(99, (player2.multishot || 1) + 1);
                        this.showMessage(`P2 ë‹¤ì¤‘ ë°œì‚¬!`, `${player2.multishot}ë°œ ë™ì‹œ ë°œì‚¬`, 2000);
                        break;
                    case 'megahealth':
                        player2.health = Math.min(player2.maxHealth, player2.health + item.effect);
                        this.createFloatingText(player2.x + player2.width / 2, player2.y, `+${item.effect}`, 'lime');
                        this.showMessage(`P2 ë©”ê°€ íë§!`, `+${item.effect} ì²´ë ¥`, 2000);
                        break;
                    case 'rapid':
                        player2.rapidFireTime = (Date.now() + 10000);
                        this.showMessage(`P2 ì—°ë°œ ëª¨ë“œ!`, '10ì´ˆê°„ ë¹ ë¥¸ ë°œì‚¬', 2000);
                        break;
                    case 'invincibility':
                        player2.invincibleEndTime = now + item.effect;
                        this.showMessage(`P2 ë¬´ì !`, `${item.effect / 1000}ì´ˆê°„ ë¬´ì `, 2000);
                        break;
                    case 'shield_boost':
                        player2.shieldBoostEndTime = now + item.duration;
                        player2.damageReductionFactor = item.effect;
                        this.showMessage(`P2 ì‰´ë“œ ê°•í™”!`, `ë°›ëŠ” í”¼í•´ ${item.effect * 100}% ê°ì†Œ`, 2000);
                        break;
                    case 'time_slow':
                        this.gameState.timeSlowEndTime = now + item.duration;
                        this.gameState.timeSlowEffect = item.effect;
                        this.showMessage(`P2 ì‹œê°„ ë‘”í™”!`, `ëª¨ë“  ì  ëŠë ¤ì§`, 2000);
                        break;
                    case 'magnet':
                        player2.magnetEndTime = now + item.duration;
                        this.showMessage(`P2 ìì„!`, `ì•„ì´í…œì„ ëŒì–´ë‹¹ê¹ë‹ˆë‹¤`, 2000);
                        break;
                    case 'health_regen':
                        player2.healthRegenEndTime = now + item.duration;
                        player2.lastRegenTick = now;
                        player2.effect = item.effect;
                        player2.tickInterval = item.tickInterval;
                        this.showMessage(`P2 ì²´ë ¥ ì¬ìƒ!`, `${item.duration / 1000}ì´ˆê°„ ì²´ë ¥ íšŒë³µ`, 2000);
                        break;
                    case 'ally_summon':
                        this.showMessage(`P2 ì•„êµ° ì†Œí™˜!`, `ë“ ë“ í•œ ì•„êµ°ì´ í•©ë¥˜í•©ë‹ˆë‹¤!`, 2000);
                        this.spawnAlly(player2.x + (player2.width / 2), player2.y + (player2.height / 2));
                        break;
                    case 'orbiting_knife':
                        player2.orbitingKnives.push({
                            angle: Math.random() * Math.PI * 2,
                            radius: 60,
                            speed: 0.05,
                            damage: 15,
                            lastHit: 0,
                            cooldown: 200,
                            color: this.ITEM_TYPES.find(i => i.type === 'orbiting_knife').color,
                            emoji: this.ITEM_TYPES.find(i => i.type === 'orbiting_knife').emoji
                        });
                        this.showMessage(`P2 íšŒì „ ì¹¼ë‚  íšë“!`, `í”Œë ˆì´ì–´ ì£¼ìœ„ë¥¼ ë•ë‹ˆë‹¤!`, 2000);
                        break;
                    case 'piercing_shot':
                        player2.piercingShot = Math.min(99, player2.piercingShot + item.effect);
                        this.showMessage(`P2 ê´€í†µ ì‚¬ê²©!`, `íƒ„í™˜ì´ ì ì„ ê´€í†µí•©ë‹ˆë‹¤! (Lv.${player2.piercingShot})`, 2000);
                        break;
                    case 'explosive_shot':
                        player2.explosiveShot = Math.min(99, player2.explosiveShot + item.effect);
                        this.showMessage(`P2 í­ë°œ ì‚¬ê²©!`, `íƒ„í™˜ì´ í­ë°œí•©ë‹ˆë‹¤! (Lv.${player2.explosiveShot})`, 2000);
                        break;
                    case 'ricochet_shot':
                        player2.ricochetLevel = Math.min(99, player2.ricochetLevel + item.effect);
                        this.showMessage(`P2 ë„íƒ„ ì‚¬ê²©!`, `íƒ„í™˜ì´ ë²½ì—ì„œ íŠ•ê²¨ ë‚˜ê°‘ë‹ˆë‹¤! (Lv.${player2.ricochetLevel})`, 2000);
                        break;
                    case 'homing_shot':
                        player2.homingLevel = Math.min(99, player2.homingLevel + item.effect);
                        this.showMessage(`P2 ìœ ë„ ì‚¬ê²©!`, `íƒ„í™˜ì´ ì ì„ ì¶”ì í•©ë‹ˆë‹¤! (Lv.${player2.homingLevel})`, 2000);
                        break;
                    case 'split_shot':
                        player2.splitLevel = Math.min(99, player2.splitLevel + item.effect);
                        this.showMessage(`P2 ë¶„ì—´ ì‚¬ê²©!`, `íƒ„í™˜ì´ ë¶„ì—´í•˜ì—¬ ì¶”ê°€ í”¼í•´ë¥¼ ì¤ë‹ˆë‹¤! (Lv.${player2.splitLevel})`, 2000);
                        break;
                    case 'life_steal':
                        player2.lifeStealPercent = Math.min(0.2, player2.lifeStealPercent + item.effect);
                        this.showMessage(`P2 ìƒëª…ë ¥ í¡ìˆ˜!`, `í”¼í•´ëŸ‰ì˜ ${(player2.lifeStealPercent * 100).toFixed(0)}% ì²´ë ¥ íšŒë³µ!`, 2000);
                        break;
                    case 'crit_chance':
                        player2.critChance = Math.min(0.5, player2.critChance + item.effect);
                        this.showMessage(`P2 ì¹˜ëª…íƒ€ í™•ë¥ !`, `ì¹˜ëª…íƒ€ í™•ë¥  ${(player2.critChance * 100).toFixed(0)}%`, 2000);
                        break;
                    case 'cooldown_reduction':
                        player2.cooldownReduction = Math.min(0.5, player2.cooldownReduction + item.effect);
                        this.showMessage(`P2 ì¬ì‚¬ìš© ëŒ€ê¸°ì‹œê°„ ê°ì†Œ!`, `ë°œì‚¬ ì†ë„ ${(player2.cooldownReduction * 100).toFixed(0)}% ì¦ê°€!`, 2000);
                        break;
                    case 'armor':
                        player2.armor += item.effect;
                        this.showMessage(`P2 ë°©ì–´ë ¥!`, `í”¼í•´ëŸ‰ ${item.effect} ê°ì†Œ!`, 2000);
                        break;
                    case 'time_stop':
                        this.gameState.timeStopEndTime = now + item.effect;
                        this.gameState.timeSlowEffect = 0;
                        this.showMessage(`P2 ì‹œê°„ ì •ì§€!`, `${item.effect / 1000}ì´ˆê°„ ëª¨ë“  ì  ì •ì§€!`, 2000);
                        break;
                    case 'ammo_regen':
                        player2.ammoRegenEndTime = now + item.duration;
                        player2.lastAmmoRegenTick = now;
                        player2.ammoRegenAmount = item.effect;
                        this.showMessage(`P2 íƒ„ì•½ ì¬ìƒ!`, `${item.duration / 1000}ì´ˆê°„ íƒ„ì•½ ìë™ íšŒë³µ!`, 2000);
                        break;
                    default:
                        break;
                }
            };

            // ì•„ì´í…œ ìˆ˜ì§‘ ì‹œ íš¨ê³¼ ì ìš©
            collectItem = (item) => {
                const player = this.gameState.player;
                const now = Date.now();
                
                switch (item.type) {
                    case 'health':
                        player.health = Math.min(player.maxHealth, player.health + item.effect);
                        this.createFloatingText(player.x + player.width / 2, player.y, `+${item.effect}`, 'green'); // ì²´ë ¥ í…ìŠ¤íŠ¸
                        this.showMessage(`+${item.effect} ì²´ë ¥!`, '', 1500);
                        break;
                    case 'ammo':
                        player.ammo = Math.min(player.maxAmmo, player.ammo + item.effect);
                        this.createFloatingText(player.x + player.width / 2, player.y, `+${item.effect}`, 'blue'); // íƒ„ì•½ í…ìŠ¤íŠ¸
                        this.showMessage(`+${item.effect} íƒ„ì•½!`, '', 1500);
                        break;
                    case 'speed':
                        player.speed = Math.min(10, player.speed + item.effect);
                        this.showMessage(`ì†ë„ ì¦ê°€!`, `+${item.effect}`, 1500);
                        break;
                    case 'shield':
                        player.maxHealth += item.effect;
                        player.health = Math.min(player.maxHealth, player.health + item.effect); // ìµœëŒ€ ì²´ë ¥ ì¦ê°€ ì‹œ í˜„ì¬ ì²´ë ¥ë„ ì¦ê°€
                        this.showMessage(`ë°©ì–´ë§‰ ê°•í™”!`, `+${item.effect} ìµœëŒ€ ì²´ë ¥`, 1500);
                        break;
                    case 'damage':
                        player.baseDamage = (player.baseDamage || 25) + item.effect; // ê¸°ë³¸ ê³µê²©ë ¥ 25ë¡œ ìˆ˜ì • ë°˜ì˜
                        this.showMessage(`ê³µê²©ë ¥ ì¦ê°€!`, `+${item.effect} ë°ë¯¸ì§€`, 1500);
                        break;
                    case 'multishot':
                        player.multishot = Math.min(99, (player.multishot || 1) + 1);
                        this.showMessage(`ë‹¤ì¤‘ ë°œì‚¬!`, `${player.multishot}ë°œ ë™ì‹œ ë°œì‚¬`, 2000);
                        break;
                    case 'megahealth':
                        player.health = Math.min(player.maxHealth, player.health + item.effect);
                        this.createFloatingText(player.x + player.width / 2, player.y, `+${item.effect}`, 'lime'); // ë©”ê°€ íë§ í…ìŠ¤íŠ¸
                        this.showMessage(`ë©”ê°€ íë§!`, `+${item.effect} ì²´ë ¥`, 2000);
                        break;
                    case 'rapid':
                        player.rapidFireTime = (Date.now() + 10000); // 10ì´ˆê°„ ë¹ ë¥¸ ë°œì‚¬
                        this.showMessage(`ì—°ë°œ ëª¨ë“œ!`, '10ì´ˆê°„ ë¹ ë¥¸ ë°œì‚¬', 2000);
                        break;
                    case 'invincibility':
                        player.invincibleEndTime = now + item.effect;
                        this.showMessage(`ë¬´ì !`, `${item.effect / 1000}ì´ˆê°„ ë¬´ì `, 2000);
                        break;
                    case 'grenade':
                        this.throwGrenade(); // ìˆ˜ë¥˜íƒ„ íˆ¬ì²™
                        this.showMessage(`ìˆ˜ë¥˜íƒ„!`, `ì ë“¤ì„ ë‚ ë ¤ë²„ë¦¬ì„¸ìš”!`, 1500);
                        break;
                    case 'shield_boost':
                        player.shieldBoostEndTime = now + item.duration;
                        player.damageReductionFactor = item.effect;
                        this.showMessage(`ì‰´ë“œ ê°•í™”!`, `ë°›ëŠ” í”¼í•´ ${item.effect * 100}% ê°ì†Œ`, 2000);
                        break;
                    case 'time_slow':
                        this.gameState.timeSlowEndTime = now + item.duration;
                        this.gameState.timeSlowEffect = item.effect;
                        this.showMessage(`ì‹œê°„ ë‘”í™”!`, `ëª¨ë“  ì  ëŠë ¤ì§`, 2000);
                        break;
                    case 'magnet':
                        player.magnetEndTime = now + item.duration;
                        this.showMessage(`ìì„!`, `ì•„ì´í…œì„ ëŒì–´ë‹¹ê¹ë‹ˆë‹¤`, 2000);
                        break;
                    case 'health_regen':
                        player.healthRegenEndTime = now + item.duration;
                        player.lastRegenTick = now; // ì²« í‹±ì€ ë°”ë¡œ ì ìš©
                        player.effect = item.effect; // ì²´ë ¥ ì¬ìƒëŸ‰ ì €ì¥
                        player.tickInterval = item.tickInterval; // ì²´ë ¥ ì¬ìƒ ê°„ê²© ì €ì¥
                        this.showMessage(`ì²´ë ¥ ì¬ìƒ!`, `${item.duration / 1000}ì´ˆê°„ ì²´ë ¥ íšŒë³µ`, 2000);
                        break;
                    case 'ally_summon':
                        this.showMessage(`ì•„êµ° ì†Œí™˜!`, `ë“ ë“ í•œ ì•„êµ°ì´ í•©ë¥˜í•©ë‹ˆë‹¤!`, 2000);
                        this.spawnAlly(player.x + (player.width / 2), player.y + (player.height / 2)); // í”Œë ˆì´ì–´ ìœ„ì¹˜ì— ì†Œí™˜
                        break;
                    case 'orbiting_knife':
                        player.orbitingKnives.push({
                            angle: Math.random() * Math.PI * 2, // ì´ˆê¸° ë¬´ì‘ìœ„ ê°ë„
                            radius: 60, // í”Œë ˆì´ì–´ë¡œë¶€í„°ì˜ ê±°ë¦¬
                            speed: 0.05, // ê°ì†ë„
                            damage: 15, // ì¹¼ë‚  ê³µê²©ë ¥
                            lastHit: 0, // ë§ˆì§€ë§‰ ê³µê²© ì‹œê°„ (ì¿¨ë‹¤ìš´ìš©)
                            cooldown: 200, // ê³µê²© ì¿¨ë‹¤ìš´ (ms)
                            color: this.ITEM_TYPES.find(i => i.type === 'orbiting_knife').color, // ì•„ì´í…œ íƒ€ì…ì—ì„œ ìƒ‰ìƒ ê°€ì ¸ì˜¤ê¸°
                            emoji: this.ITEM_TYPES.find(i => i.type === 'orbiting_knife').emoji // ì•„ì´í…œ íƒ€ì…ì—ì„œ ì´ëª¨ì§€ ê°€ì ¸ì˜¤ê¸°
                        });
                        this.showMessage(`íšŒì „ ì¹¼ë‚  íšë“!`, `í”Œë ˆì´ì–´ ì£¼ìœ„ë¥¼ ë•ë‹ˆë‹¤!`, 2000);
                        break;
                    case 'piercing_shot':
                        player.piercingShot = Math.min(99, player.piercingShot + item.effect);
                        this.showMessage(`ê´€í†µ ì‚¬ê²©!`, `íƒ„í™˜ì´ ì ì„ ê´€í†µí•©ë‹ˆë‹¤! (Lv.${player.piercingShot})`, 2000);
                        break;
                    case 'explosive_shot':
                        player.explosiveShot = Math.min(99, player.explosiveShot + item.effect);
                        this.showMessage(`í­ë°œ ì‚¬ê²©!`, `íƒ„í™˜ì´ í­ë°œí•©ë‹ˆë‹¤! (Lv.${player.explosiveShot})`, 2000);
                        break;
                    case 'ricochet_shot':
                        player.ricochetLevel = Math.min(99, player.ricochetLevel + item.effect);
                        this.showMessage(`ë„íƒ„ ì‚¬ê²©!`, `íƒ„í™˜ì´ ë²½ì—ì„œ íŠ•ê²¨ ë‚˜ê°‘ë‹ˆë‹¤! (Lv.${player.ricochetLevel})`, 2000);
                        break;
                    case 'homing_shot':
                        player.homingLevel = Math.min(99, player.homingLevel + item.effect);
                        this.showMessage(`ìœ ë„ ì‚¬ê²©!`, `íƒ„í™˜ì´ ì ì„ ì¶”ì í•©ë‹ˆë‹¤! (Lv.${player.homingLevel})`, 2000);
                        break;
                    case 'split_shot':
                        player.splitLevel = Math.min(99, player.splitLevel + item.effect);
                        this.showMessage(`ë¶„ì—´ ì‚¬ê²©!`, `íƒ„í™˜ì´ ë¶„ì—´í•˜ì—¬ ì¶”ê°€ í”¼í•´ë¥¼ ì¤ë‹ˆë‹¤! (Lv.${player.splitLevel})`, 2000);
                        break;
                    case 'life_steal':
                        player.lifeStealPercent = Math.min(0.2, player.lifeStealPercent + item.effect); // ìµœëŒ€ 20%
                        this.showMessage(`ìƒëª…ë ¥ í¡ìˆ˜!`, `í”¼í•´ëŸ‰ì˜ ${(player.lifeStealPercent * 100).toFixed(0)}% ì²´ë ¥ íšŒë³µ!`, 2000);
                        break;
                    case 'crit_chance':
                        player.critChance = Math.min(0.5, player.critChance + item.effect); // ìµœëŒ€ 50%
                        this.showMessage(`ì¹˜ëª…íƒ€ í™•ë¥ !`, `ì¹˜ëª…íƒ€ í™•ë¥  ${(player.critChance * 100).toFixed(0)}%`, 2000);
                        break;
                    case 'cooldown_reduction':
                        player.cooldownReduction = Math.min(0.5, player.cooldownReduction + item.effect); // ìµœëŒ€ 50%
                        this.showMessage(`ì¬ì‚¬ìš© ëŒ€ê¸°ì‹œê°„ ê°ì†Œ!`, `ë°œì‚¬ ì†ë„ ${(player.cooldownReduction * 100).toFixed(0)}% ì¦ê°€!`, 2000);
                        break;
                    case 'armor':
                        player.armor += item.effect;
                        this.showMessage(`ë°©ì–´ë ¥!`, `í”¼í•´ëŸ‰ ${item.effect} ê°ì†Œ!`, 2000);
                        break;
                    case 'time_stop':
                        this.gameState.timeStopEndTime = now + item.effect;
                        this.gameState.timeSlowEffect = 0; // ëª¨ë“  ì  ì •ì§€
                        this.showMessage(`ì‹œê°„ ì •ì§€!`, `${item.effect / 1000}ì´ˆê°„ ëª¨ë“  ì  ì •ì§€!`, 2000);
                        break;
                    case 'ammo_regen':
                        player.ammoRegenEndTime = now + item.duration;
                        player.lastAmmoRegenTick = now;
                        player.ammoRegenAmount = item.effect;
                        this.showMessage(`íƒ„ì•½ ì¬ìƒ!`, `${item.duration / 1000}ì´ˆê°„ íƒ„ì•½ ìë™ íšŒë³µ!`, 2000);
                        break;
                }
                
                this.createCollectParticles(item.x, item.y, item.color); // ì•„ì´í…œ ìˆ˜ì§‘ íŒŒí‹°í´ ìƒì„±
                this.addScore(50); // ì•„ì´í…œ ìˆ˜ì§‘ ì‹œ ì ìˆ˜ íšë“
                this.updateHUD(); // HUD ì—…ë°ì´íŠ¸
            }
            
            // í”¼ê²© íŒŒí‹°í´ ìƒì„±
            createHitParticles = (x, y) => {
                for (let i = 0; i < 6; i++) {
                    this.gameState.particles.push({
                        x: x, y: y,
                        vx: (Math.random() - 0.5) * 6, // ë¬´ì‘ìœ„ X ì†ë„
                        vy: (Math.random() - 0.5) * 6, // ë¬´ì‘ìœ„ Y ì†ë„
                        life: 30, maxLife: 30, // ìˆ˜ëª…
                        color: '#ff6b6b', // ìƒ‰ìƒ (ë¹¨ê°„ìƒ‰)
                        size: Math.random() * 3 + 1 // í¬ê¸°
                    });
                }
            }
            
            // ì•„ì´í…œ ìˆ˜ì§‘ íŒŒí‹°í´ ìƒì„±
            createCollectParticles = (x, y, color) => {
                for (let i = 0; i < 8; i++) {
                    this.gameState.particles.push({
                        x: x, y: y,
                        vx: (Math.random() - 0.5) * 4, // ë¬´ì‘ìœ„ X ì†ë„
                        vy: (Math.random() - 0.5) * 4, // ë¬´ì‘ìœ„ Y ì†ë„
                        life: 40, maxLife: 40, // ìˆ˜ëª…
                        color: color, // ì•„ì´í…œ ìƒ‰ìƒ
                        size: Math.random() * 4 + 2 // í¬ê¸°
                    });
                }
            }

            // ë– ë‹¤ë‹ˆëŠ” í…ìŠ¤íŠ¸ ìƒì„± (ì²´ë ¥ ë³€í™” ë“±)
            createFloatingText = (x, y, text, color) => {
                this.gameState.floatingTexts.push({
                    x: x,
                    y: y,
                    text: text,
                    color: color,
                    life: 60, // í…ìŠ¤íŠ¸ ìˆ˜ëª… (í”„ë ˆì„)
                    maxLife: 60,
                    vy: -1 // ìœ„ë¡œ ì´ë™í•˜ëŠ” ì†ë„
                });
            }
            
            // íŒŒí‹°í´ ìƒíƒœ ì—…ë°ì´íŠ¸
            updateParticles = () => {
                this.gameState.particles = this.gameState.particles.filter(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vx *= 0.98; // ì†ë„ ê°ì†Œ (ë§ˆì°°)
                    particle.vy *= 0.98; // ì†ë„ ê°ì†Œ (ë§ˆì°°)
                    particle.life--; // ìˆ˜ëª… ê°ì†Œ
                    
                    return particle.life > 0; // ìˆ˜ëª…ì´ ë‚¨ì€ íŒŒí‹°í´ë§Œ ìœ ì§€
                });
            }

            // ë– ë‹¤ë‹ˆëŠ” í…ìŠ¤íŠ¸ ìƒíƒœ ì—…ë°ì´íŠ¸
            updateFloatingTexts = () => {
                this.gameState.floatingTexts = this.gameState.floatingTexts.filter(text => {
                    text.y += text.vy; // ìœ„ë¡œ ì´ë™
                    text.life--; // ìˆ˜ëª… ê°ì†Œ
                    return text.life > 0; // ìˆ˜ëª…ì´ ë‚¨ì€ í…ìŠ¤íŠ¸ë§Œ ìœ ì§€
                });
            }
            
            // ì›¨ì´ë¸Œ ì™„ë£Œ ì²´í¬ (ìƒˆë¡œìš´ ë³´ìŠ¤ ì‹œìŠ¤í…œ)
            checkWaveComplete = () => {
                // í…ŒìŠ¤íŒ… ì¡´ì—ì„œëŠ” ì›¨ì´ë¸Œ ì™„ë£Œ ì²´í¬ ì•ˆí•¨
                if (this.gameMode === 'testzone') return;
                
                // ë³´ìŠ¤ ì›¨ì´ë¸Œ ì™„ë£Œ ì²´í¬
                if (this.gameState.wave % 10 === 0) {
                    this.checkBossWaveComplete();
                } else {
                    this.checkNormalWaveComplete();
                }
            }
            
            // ë³´ìŠ¤ ì›¨ì´ë¸Œ ì™„ë£Œ ì²´í¬
            checkBossWaveComplete = () => {
                // ë³´ìŠ¤ê°€ ëª¨ë‘ ì£½ì—ˆê³ , ê²Œì„ì´ ì§„í–‰ ì¤‘ì¼ ë•Œ
                const bossCount = this.gameState.enemies.filter(e => e.type && e.type.startsWith('boss')).length;
                if (this.bossSystem && this.bossSystem.isActive && bossCount === 0 && this.gameState.gameStatus === 'playing') {
                    this.completeWave();
                }
            }
            
            // ì¼ë°˜ ì›¨ì´ë¸Œ ì™„ë£Œ ì²´í¬
            checkNormalWaveComplete = () => {
                // ëª¨ë“  ì ì´ ì£½ì—ˆê³ , ê²Œì„ì´ ì§„í–‰ ì¤‘ì¼ ë•Œ
                if (this.gameState.enemies.length === 0 && this.gameState.gameStatus === 'playing') {
                    this.completeWave();
                }
            }
            
            // ì›¨ì´ë¸Œ ì™„ë£Œ ì²˜ë¦¬
            completeWave = () => {
                this.gameState.gameStatus = 'wave-complete';
                this.showMessage(`ì›¨ì´ë¸Œ ${this.gameState.wave} ì™„ë£Œ!`, 'ë‹¤ìŒ ì›¨ì´ë¸Œ ì¤€ë¹„ ì¤‘...', 3000);
                this.gameState.wave++;
                
                // ë¶€í™œ ì‹œìŠ¤í…œ ì²´í¬ (ë©€í‹°í”Œë ˆì´ ëª¨ë“œì¼ ë•Œë§Œ)
                if (this.gameState.multiplayerMode) {
                    this.checkRevivalSystem();
                }
                
                setTimeout(() => {
                    this.gameState.gameStatus = 'spawning';
                    this.spawnInitialWave();
                    this.gameState.gameStatus = 'playing';
                }, 3000);
            }

            // ë¶€í™œ ì‹œìŠ¤í…œ ì²´í¬
            checkRevivalSystem = () => {
                // í”Œë ˆì´ì–´1ì´ ì£½ì–´ìˆê³  í”Œë ˆì´ì–´2ê°€ ì‚´ì•„ìˆì„ ë•Œ
                if (this.gameState.player1Dead && !this.gameState.player2Dead) {
                    this.gameState.revivalWaveCount++;
                    if (this.gameState.revivalWaveCount >= 5) {
                        this.revivePlayer('player1');
                    } else {
                        this.showMessage(`í”Œë ˆì´ì–´1 ë¶€í™œê¹Œì§€`, `${5 - this.gameState.revivalWaveCount}ì›¨ì´ë¸Œ ë‚¨ìŒ`, 2000);
                    }
                }
                // í”Œë ˆì´ì–´2ê°€ ì£½ì–´ìˆê³  í”Œë ˆì´ì–´1ì´ ì‚´ì•„ìˆì„ ë•Œ
                else if (this.gameState.player2Dead && !this.gameState.player1Dead) {
                    this.gameState.revivalWaveCount++;
                    if (this.gameState.revivalWaveCount >= 5) {
                        this.revivePlayer('player2');
                    } else {
                        this.showMessage(`í”Œë ˆì´ì–´2 ë¶€í™œê¹Œì§€`, `${5 - this.gameState.revivalWaveCount}ì›¨ì´ë¸Œ ë‚¨ìŒ`, 2000);
                    }
                }
            }
            
            // ë³´ìŠ¤ ì‹œìŠ¤í…œ ë¦¬ì…‹
            resetBossSystem = () => {
                console.log('ë³´ìŠ¤ ì‹œìŠ¤í…œ ë¦¬ì…‹');
                if (this.bossSystem) {
                    this.bossSystem.isActive = false;
                    this.bossSystem.currentBoss = null;
                    this.bossSystem.spawnLock = false;
                }
                this.gameState.gameStatus = 'playing'; // í˜¹ì‹œë¼ë„ ìƒíƒœê°€ ê¼¬ì˜€ì„ ë•Œ ë³µêµ¬
                // ë³´ìŠ¤ ì²´ë ¥ë°” ìˆ¨ê¸°ê¸°
                const bossBarContainer = document.getElementById('bossBarContainer');
                if (bossBarContainer) {
                    bossBarContainer.style.display = 'none';
                }
                this.showMessage('ë³´ìŠ¤ ì²˜ì¹˜!', 'í›Œë¥­í•œ ì „íˆ¬ì˜€ìŠµë‹ˆë‹¤!', 2000);
            }
                        
            // ê²Œì„ ì˜¤ë²„ ì²˜ë¦¬
            gameOver = () => {
                this.gameState.gameStatus = 'game-over'; // ê²Œì„ ìƒíƒœë¥¼ 'ê²Œì„ ì˜¤ë²„'ë¡œ ë³€ê²½
                this.showMessage('ê²Œì„ ì˜¤ë²„!', `ìµœì¢… ì ìˆ˜: ${this.gameState.score.toLocaleString()}`, 5000, true);
                // ì–´ë–¤ ì ì—ê²Œ ì£½ì—ˆëŠ”ì§€ ì½˜ì†”ì— ì¶œë ¥
                const lastHitById = this.gameState.player.lastHitById;
                if (lastHitById) {
                    // lastHitByIdê°€ ì ì˜ IDì¼ ê²½ìš° í•´ë‹¹ ì ì˜ ì •ë³´ë¥¼ ì°¾ìŒ
                    const killerEnemy = this.gameState.enemies.find(enemy => enemy.id === lastHitById);
                    if (killerEnemy) {
                        const enemyType = this.ENEMY_TYPES[killerEnemy.type];
                        if (enemyType) {
                            console.log(`í”Œë ˆì´ì–´ê°€ '${enemyType.name}'ì—ê²Œ ì‚¬ë§í–ˆìŠµë‹ˆë‹¤.`);
                        } else {
                            console.log(`í”Œë ˆì´ì–´ê°€ '${killerEnemy.type}' íƒ€ì… ì ì—ê²Œ ì‚¬ë§í–ˆìŠµë‹ˆë‹¤.`);
                        }
                    } else if (lastHitById === 'player') { // í”Œë ˆì´ì–´ ìŠ¤ìŠ¤ë¡œì—ê²Œ í”¼í•´ë¥¼ ì…ì€ ê²½ìš° (ìˆ˜ë¥˜íƒ„ ë“±)
                        console.log('í”Œë ˆì´ì–´ê°€ ìŠ¤ìŠ¤ë¡œì—ê²Œ í”¼í•´ë¥¼ ì…ì–´ ì‚¬ë§í–ˆìŠµë‹ˆë‹¤.');
                    } else {
                        console.log(`í”Œë ˆì´ì–´ê°€ ì•Œ ìˆ˜ ì—†ëŠ” ì ì—ê²Œ ì‚¬ë§í–ˆìŠµë‹ˆë‹¤ (ID: ${lastHitById}).`);
                    }
                } else {
                    console.log('í”Œë ˆì´ì–´ê°€ ì ì—ê²Œ ì§ì ‘ì ì¸ ê³µê²© ì—†ì´ ì‚¬ë§í–ˆìŠµë‹ˆë‹¤ (ì˜ˆ: ë‚™ì‚¬).');
                }
                // 5ì´ˆ í›„ ê²Œì„ ì¬ì‹œì‘ (ì‹œì‘ í™”ë©´ìœ¼ë¡œ ëŒì•„ê°€ì§€ ì•ŠìŒ)
                const restartBtn = document.getElementById('restartButton');
                restartBtn.style.display = 'block';
                restartBtn.onclick = () => {
                    restartBtn.style.display = 'none';
                    this.resetGame();
                };
            }
            
            // ê²Œì„ ì´ˆê¸°í™”
            resetGame = () => {
                // ê²Œì„ ìƒíƒœë¥¼ ì´ˆê¸°ê°’ìœ¼ë¡œ ì¬ì„¤ì •
                this.gameState = {
                    player: {
                        x: this.canvas.width / 2, y: this.canvas.height / 2,
                        width: 40, height: 40,
                        vx: 0, vy: 0,
                        health: 150, maxHealth: 150, // ê¸°ë³¸ê°’ 100ìœ¼ë¡œ ë³€ê²½
                        ammo: 30, maxAmmo: 30, // ê¸°ë³¸ê°’ 100ìœ¼ë¡œ ë³€ê²½
                        speed: 5, jumpPower: 15,
                        onGround: false, facing: 0,
                        expression: this.getRandomExpression(),
                        color: '#6366f1',
                        baseDamage: 10, // ê¸°ë³¸ê°’ 10ìœ¼ë¡œ ë³€ê²½
                        multishot: 1,
                        rapidFireTime: 0,
                        damageReductionFactor: 1,
                        shieldBoostEndTime: 0,
                        healthRegenEndTime: 0,
                        lastRegenTick: 0,
                        magnetEndTime: 0,
                        magnetRadius: 200,
                        lastHitById: null, // ì´ˆê¸°í™”
                        type: 'player', // í”Œë ˆì´ì–´ íƒ€ì…
                        orbitingKnives: [], // íšŒì „ ì¹¼ë‚  ì´ˆê¸°í™”
                        piercingShot: 0, // ê´€í†µ ì‚¬ê²© ì´ˆê¸°í™”
                        explosiveShot: 0, // í­ë°œ ì‚¬ê²© ì´ˆê¸°í™”
                        ricochetLevel: 0, // ë„íƒ„ ì‚¬ê²© ì´ˆê¸°í™”
                        homingLevel: 0, // ìœ ë„ ì‚¬ê²© ì´ˆê¸°í™”
                        splitLevel: 0, // ë¶„ì—´ ì‚¬ê²© ì´ˆê¸°í™”
                        lifeStealPercent: 0, // ìƒëª…ë ¥ í¡ìˆ˜ ì´ˆê¸°í™”
                        critChance: 0, // ì¹˜ëª…íƒ€ í™•ë¥  ì´ˆê¸°í™”
                        critMultiplier: 1.5, // ì¹˜ëª…íƒ€ ë°°ìœ¨ ì´ˆê¸°í™”
                        cooldownReduction: 0, // ì¬ì‚¬ìš© ëŒ€ê¸°ì‹œê°„ ê°ì†Œ ì´ˆê¸°í™”
                        armor: 0, // ë°©ì–´ë ¥ ì´ˆê¸°í™”
                        timeStopEndTime: 0, // ì‹œê°„ ì •ì§€ ì´ˆê¸°í™”
                        ammoRegenEndTime: 0, // íƒ„ì•½ ì¬ìƒ ì´ˆê¸°í™”
                        lastAmmoRegenTick: 0, // ë§ˆì§€ë§‰ íƒ„ì•½ ì¬ìƒ í‹± ì´ˆê¸°í™”
                        ammoRegenAmount: 0, // íƒ„ì•½ ì¬ìƒëŸ‰ ì´ˆê¸°í™”
                        dashCooldown: 0, // ë§ˆì§€ë§‰ ëŒ€ì‹œ ì‹œê°
                        dashEndTime: 0, // ëŒ€ì‹œ ì¢…ë£Œ ì‹œê°
                        isDashing: false, // ëŒ€ì‹œ ì¤‘ ì—¬ë¶€
                        reloadTime: 1500, // ê¸°ë³¸ ì¬ì¥ì „ ì‹œê°„(ms)
                        isReloading: false,
                        machineGunMode: false, // ê¸°ê´€ë‹¨ì´ íŒ¨ì‹œë¸Œ
                        machineGunPenalty: false, // ê¸°ê´€ë‹¨ì´ íŒ¨ë„í‹°
                        reloadPenalty: 0, // íŒ¨ì‹œë¸Œë¡œ ì¸í•œ ì¶”ê°€ ì¬ì¥ì „ ì‹œê°„(ms)
                        gunRecoil: 0,
                        gunRecoilTarget: 0,
                    },
                    enemies: [],
                    projectiles: [],
                    items: [],
                    particles: [],
                    floatingTexts: [],
                    allies: [], // ì•„êµ° ë°°ì—´ ì´ˆê¸°í™”
                    score: 0,
                    wave: 1,
                    gameStatus: 'playing', // ê²Œì„ ì˜¤ë²„ í›„ ë°”ë¡œ í”Œë ˆì´ ìƒíƒœë¡œ ì „í™˜
                    message: '',
                    messageTimer: 0,
                    playerSlowedEndTime: 0,
                    timeSlowEndTime: 0,
                    timeSlowEffect: 1,
                    waveSpawning: false,
                    isHost: false,
                    isHostSet: false,
                    multiplayerMode: false
                };
                
                // ë³´ìŠ¤ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
                this.bossSystem = {
                    isActive: false,
                    currentBoss: null,
                    spawnLock: false
                };
                
                this.spawnInitialWave(); // ìƒˆ ê²Œì„ ì‹œì‘ ì‹œ ì´ˆê¸° ì›¨ì´ë¸Œ ìƒì„±
                this.updateHUD(); // HUD ì—…ë°ì´íŠ¸ (ì´ˆê¸°í™”ëœ ê°’ìœ¼ë¡œ)
                this.hideMessage(); // ë©”ì‹œì§€ ìˆ¨ê¸°ê¸°
                this.gameLoop(); // ê²Œì„ ë£¨í”„ ì¬ì‹œì‘
            }

            // ê²Œì„ ë©”ì‹œì§€ í‘œì‹œ
            showMessage = (text, subText, duration, showRestart) => {
                const messageEl = document.getElementById('gameMessage');
                const messageTextEl = document.getElementById('messageText');
                const messageSubTextEl = document.getElementById('messageSubText');
                const restartBtn = document.getElementById('restartButton');
                messageTextEl.textContent = text;
                messageSubTextEl.textContent = subText;
                messageEl.style.display = 'block';
                if (showRestart) {
                    restartBtn.style.display = 'block';
                } else if (restartBtn) {
                    restartBtn.style.display = 'none';
                }
                if (!showRestart) {
                    setTimeout(() => {
                        this.hideMessage();
                    }, duration);
                }
            }
            
            // ê²Œì„ ë©”ì‹œì§€ ìˆ¨ê¸°ê¸°
            hideMessage = () => {
                document.getElementById('gameMessage').style.display = 'none';
            }

            // ë³´ìƒ ì„ íƒ í™”ë©´ í‘œì‹œ
            showRewardSelection = (type = 'score') => {
                this.canvas.style.filter = 'blur(10px)';
                document.querySelector('.hud').style.display = 'none';
                document.getElementById('rewardSelectionScreen').style.display = 'flex';
                const titleEl = document.getElementById('rewardSelectionTitle');
                if (type === 'boss') {
                    titleEl.textContent = 'ë³´ìŠ¤ ì²˜ì¹˜! ë³´ìƒì„ ì„ íƒí•˜ì„¸ìš”.';
                } else {
                    titleEl.textContent = 'ì ìˆ˜ ë‹¬ì„±! ë³´ìƒì„ ì„ íƒí•˜ì„¸ìš”.';
                }
                const rewardOptionsEl = document.getElementById('rewardOptions');
                rewardOptionsEl.innerHTML = '';
                const shuffledRewards = [...this.REWARD_OPTIONS].sort(() => 0.5 - Math.random());
                const selectedRewards = shuffledRewards.slice(0, 3);
                selectedRewards.forEach(option => {
                    const button = document.createElement('button');
                    button.className = 'reward-button';
                    button.textContent = option.text;
                    button.addEventListener('click', () => {
                        this.applyReward(option.type, option.value);
                        this.hideRewardSelection();
                        this.gameState.gameStatus = 'playing';
                        this.updateHUD();
                        if (typeof this.gameLoop === 'function') {
                            this.gameLoop();
                        }
                    });
                    rewardOptionsEl.appendChild(button);
                });
            };

            // ë³´ìƒ ì„ íƒ í™”ë©´ ìˆ¨ê¸°ê¸°
            hideRewardSelection = () => {
                this.canvas.style.filter = 'blur(0px)'; // ìº”ë²„ìŠ¤ ë¸”ëŸ¬ ì œê±°
                document.querySelector('.hud').style.display = 'flex'; // HUD í‘œì‹œ
                document.getElementById('rewardSelectionScreen').style.display = 'none'; // ë³´ìƒ í™”ë©´ ìˆ¨ê¹€
            }

            // ì„ íƒëœ ë³´ìƒ ì ìš©
            applyReward = (type, value) => {
                const player = this.gameState.player;
                const player2 = this.gameState.player2;
                
                // ë©€í‹°í”Œë ˆì´ ëª¨ë“œì—ì„œ íŒ¨ì‹œë¸Œ ëŠ¥ë ¥ ê³µìœ 
                const applyToPlayer = (targetPlayer) => {
                    if (!targetPlayer) return;
                    
                    switch (type) {
                        case 'tank':
                            targetPlayer.maxHealth += 100;
                            targetPlayer.health = Math.min(targetPlayer.maxHealth, targetPlayer.health + 100);
                            targetPlayer.speed -= 4;
                            break;
                        case 'speedster':
                            targetPlayer.speed += 10;
                            targetPlayer.dashCooldown = Math.max(0, targetPlayer.dashCooldown - 10000);
                            targetPlayer.baseDamage *= 0.95;
                            targetPlayer.reloadPenalty += 3000;
                            break;
                        case 'machine_gun':
                            targetPlayer.machineGunMode = true;
                            targetPlayer.machineGunPenalty = true;
                            targetPlayer.reloadPenalty += 5000;
                            break;
                        case 'homing_master':
                            targetPlayer.homingLevel = 3;
                            targetPlayer.homingPenalty = true;
                            break;
                        case 'ricochet_shot':
                            targetPlayer.ricochetLevel = 1;
                            break;
                        case 'vampire':
                            targetPlayer.lifeStealPercent += 0.03;
                            targetPlayer.reloadPenalty += 2000;
                            break;
                        case 'knife_shield':
                            for (let i = 0; i < 3; i++) {
                                targetPlayer.orbitingKnives.push({
                                    angle: Math.random() * Math.PI * 2,
                                    radius: 60,
                                    speed: 0.05,
                                    damage: 15,
                                    lastHit: 0,
                                    cooldown: 200,
                                    color: this.ITEM_TYPES.find(i => i.type === 'orbiting_knife').color,
                                    emoji: this.ITEM_TYPES.find(i => i.type === 'orbiting_knife').emoji
                                });
                            }
                            break;
                        case 'crit_master':
                            targetPlayer.critChance += 0.2;
                            targetPlayer.maxHealth = Math.floor(targetPlayer.maxHealth * 0.9);
                            targetPlayer.health = Math.min(targetPlayer.maxHealth, targetPlayer.health);
                            break;
                        case 'armor':
                            targetPlayer.armor += 5;
                            break;
                        case 'ammo_overflow':
                            targetPlayer.ammoRegenEndTime = Date.now() + 10000;
                            targetPlayer.ammoRegenAmount = 10;
                            targetPlayer.maxAmmo += 20;
                            break;
                        case 'maxHealth':
                            targetPlayer.maxHealth += value;
                            targetPlayer.health = Math.min(targetPlayer.maxHealth, targetPlayer.health + value);
                            break;
                        case 'currentHealth':
                            targetPlayer.health = Math.min(targetPlayer.maxHealth, targetPlayer.health + value);
                            break;
                        case 'damage':
                            targetPlayer.baseDamage += value;
                            break;
                        case 'speed':
                            targetPlayer.speed += value;
                            break;
                        case 'multishot':
                            targetPlayer.multishot = Math.min(99, (targetPlayer.multishot || 1) + 1);
                            break;
                        case 'orbiting_knife':
                            targetPlayer.orbitingKnives.push({
                                angle: Math.random() * Math.PI * 2,
                                radius: 60,
                                speed: 0.05,
                                damage: 15,
                                lastHit: 0,
                                cooldown: 200,
                                color: this.ITEM_TYPES.find(i => i.type === 'orbiting_knife').color,
                                emoji: this.ITEM_TYPES.find(i => i.type === 'orbiting_knife').emoji
                            });
                            break;
                        case 'piercing_shot':
                            targetPlayer.piercingShot = Math.min(99, targetPlayer.piercingShot + value);
                            break;
                        case 'explosive_shot':
                            targetPlayer.explosiveShot = Math.min(99, targetPlayer.explosiveShot + value);
                            break;
                        case 'ricochet_shot':
                            targetPlayer.ricochetLevel = Math.min(99, targetPlayer.ricochetLevel + value);
                            break;
                        case 'homing_shot':
                            targetPlayer.homingLevel = Math.min(99, targetPlayer.homingLevel + value);
                            break;
                        case 'split_shot':
                            targetPlayer.splitLevel = Math.min(99, targetPlayer.splitLevel + value);
                            break;
                        case 'life_steal':
                            targetPlayer.lifeStealPercent = Math.min(0.2, targetPlayer.lifeStealPercent + value);
                            break;
                        case 'crit_chance':
                            targetPlayer.critChance = Math.min(0.5, targetPlayer.critChance + value);
                            break;
                        case 'cooldown_reduction':
                            targetPlayer.cooldownReduction = Math.min(0.5, targetPlayer.cooldownReduction + value);
                            break;
                        case 'armor':
                            targetPlayer.armor += value;
                            break;
                        case 'ammo':
                            targetPlayer.ammo = Math.min(targetPlayer.maxAmmo, targetPlayer.ammo + value);
                            break;
                        case 'max_ammo':
                            targetPlayer.maxAmmo += value;
                            targetPlayer.ammo = Math.min(targetPlayer.maxAmmo, targetPlayer.ammo + value);
                            break;
                    }
                };
                
                // ë©€í‹°í”Œë ˆì´ ëª¨ë“œì—ì„œ ë‘ í”Œë ˆì´ì–´ ëª¨ë‘ì—ê²Œ ì ìš©
                if (this.gameState.multiplayerMode && player2) {
                    applyToPlayer(player);
                    applyToPlayer(player2);
                } else {
                    // ì†”ë¡œ ëª¨ë“œì—ì„œëŠ” í”Œë ˆì´ì–´1ì—ê²Œë§Œ ì ìš©
                    applyToPlayer(player);
                }
                
                // ë©”ì‹œì§€ í‘œì‹œ (ê¸°ì¡´ ë©”ì‹œì§€ë“¤ ìœ ì§€)
                switch (type) {
                    case 'tank':
                        this.showMessage('íƒ±í¬ê°€ ë˜ì–´!', 'ìµœëŒ€ ì²´ë ¥ +100, ì´ë™ ì†ë„ -4', 2000);
                        break;
                    case 'speedster':
                        this.showMessage('ë¹¨ë¼ì§„ë‹¤ì•„ì•„ì•„ì•„!', 'ì†ë„ +10, ëŒ€ì‹œ ì¿¨íƒ€ì„ -10ì´ˆ, ê³µê²©ë ¥ -5%, ì¬ì¥ì „ +3ì´ˆ', 2000);
                        break;
                    case 'machine_gun':
                        this.showMessage('ê¸°ê´€ë‹¨ì´!', 'ì—°ì‚¬, ì¬ì¥ì „ +5ì´ˆ, ê³µê²©ë ¥ -50%', 2000);
                        break;
                    case 'homing_master':
                        this.showMessage('ìœ ë„íƒ„!', 'ìœ ë„íƒ„ Lv.3, ê³µê²©ë ¥ -5%', 2000);
                        break;
                    case 'ricochet_shot':
                        this.showMessage('íƒ±íƒ±ë³¼!', 'ì´ì•Œì´ ë²½ì— íŠ•ê¹€', 2000);
                        break;
                    case 'vampire':
                        this.showMessage('ë±€íŒŒì´ì–´!', 'í¡í˜ˆ, ì¬ì¥ì „ +2ì´ˆ', 2000);
                        break;
                    case 'knife_shield':
                        this.showMessage('ì¹¼ë‚ ì´ ë‚˜ë¥¼ ê°ì‹¸ë„¤!', 'ì¹¼ë‚  3ê°œ ìƒì„±', 2000);
                        break;
                    case 'crit_master':
                        this.showMessage('ìŠ¤ì¹˜ê¸°ë§Œ í•´ë„ ì¹˜ëª…íƒ€!', 'ì¹˜ëª…íƒ€ +20%, ì²´ë ¥ -10%', 2000);
                        break;
                    case 'armor':
                        this.showMessage('ë°©ì–´ë ¥!', 'í”¼í•´ëŸ‰ 5 ê°ì†Œ', 2000);
                        break;
                    case 'ammo_overflow':
                        this.showMessage('íƒ„ì•½ì´ ë„˜ì³!', 'íƒ„ì•½ ìë™ íšŒë³µ, íƒ„ì•½í†µ +20', 2000);
                        break;
                    case 'maxHealth':
                        this.showMessage(`ìµœëŒ€ ì²´ë ¥ +${value}!`, '', 1500);
                        break;
                    case 'currentHealth':
                        this.createFloatingText(player.x + player.width / 2, player.y, `+${value}`, 'green');
                        this.showMessage(`ì²´ë ¥ +${value}!`, '', 1500);
                        break;
                    case 'damage':
                        this.showMessage(`ê³µê²©ë ¥ +${value}!`, '', 1500);
                        break;
                    case 'speed':
                        this.showMessage(`ì´ë™ ì†ë„ +${value}!`, '', 1500);
                        break;
                    case 'multishot':
                        this.showMessage(`ë‹¤ì¤‘ ë°œì‚¬!`, `${player.multishot}ë°œ ë™ì‹œ ë°œì‚¬`, 2000);
                        break;
                    case 'orbiting_knife':
                        this.showMessage(`íšŒì „ ì¹¼ë‚  íšë“!`, `í”Œë ˆì´ì–´ ì£¼ìœ„ë¥¼ ë•ë‹ˆë‹¤!`, 2000);
                        break;
                    case 'piercing_shot':
                        this.showMessage(`ê´€í†µ ì‚¬ê²©!`, `íƒ„í™˜ì´ ì ì„ ê´€í†µí•©ë‹ˆë‹¤! (Lv.${player.piercingShot})`, 2000);
                        break;
                    case 'explosive_shot':
                        this.showMessage(`í­ë°œ ì‚¬ê²©!`, `íƒ„í™˜ì´ í­ë°œí•©ë‹ˆë‹¤! (Lv.${player.explosiveShot})`, 2000);
                        break;
                    case 'ricochet_shot':
                        this.showMessage(`ë„íƒ„ ì‚¬ê²©!`, `íƒ„í™˜ì´ ë²½ì—ì„œ íŠ•ê²¨ ë‚˜ê°‘ë‹ˆë‹¤! (Lv.${player.ricochetLevel})`, 2000);
                        break;
                    case 'homing_shot':
                        this.showMessage(`ìœ ë„ ì‚¬ê²©!`, `íƒ„í™˜ì´ ì ì„ ì¶”ì í•©ë‹ˆë‹¤! (Lv.${player.homingLevel})`, 2000);
                        break;
                    case 'split_shot':
                        this.showMessage(`ë¶„ì—´ ì‚¬ê²©!`, `íƒ„í™˜ì´ ë¶„ì—´í•˜ì—¬ ì¶”ê°€ í”¼í•´ë¥¼ ì¤ë‹ˆë‹¤! (Lv.${player.splitLevel})`, 2000);
                        break;
                    case 'life_steal':
                        this.showMessage(`ìƒëª…ë ¥ í¡ìˆ˜!`, `í”¼í•´ëŸ‰ì˜ ${(player.lifeStealPercent * 100).toFixed(0)}% ì²´ë ¥ íšŒë³µ!`, 2000);
                        break;
                    case 'crit_chance':
                        this.showMessage(`ì¹˜ëª…íƒ€ í™•ë¥ !`, `ì¹˜ëª…íƒ€ í™•ë¥  ${(player.critChance * 100).toFixed(0)}%`, 2000);
                        break;
                    case 'cooldown_reduction':
                        this.showMessage(`ì¬ì‚¬ìš© ëŒ€ê¸°ì‹œê°„ ê°ì†Œ!`, `ë°œì‚¬ ì†ë„ ${(player.cooldownReduction * 100).toFixed(0)}% ì¦ê°€!`, 2000);
                        break;
                    case 'time_stop':
                        this.gameState.timeStopEndTime = Date.now() + value;
                        this.gameState.timeSlowEffect = 0;
                        this.showMessage(`ì‹œê°„ ì •ì§€!`, `${value / 1000}ì´ˆê°„ ëª¨ë“  ì  ì •ì§€!`, 2000);
                        break;
                    case 'ammo_regen':
                        this.showMessage(`íƒ„ì•½ ì¬ìƒ!`, `5ì´ˆê°„ íƒ„ì•½ ìë™ íšŒë³µ!`, 2000);
                        break;
                    case 'invincibility':
                        this.showMessage(`ë¬´ì !`, `${value / 1000}ì´ˆê°„ ë¬´ì  ìƒíƒœ!`, 2000);
                        break;
                    case 'shield_boost':
                        this.showMessage(`ì‰´ë“œ ê°•í™”!`, `${value / 1000}ì´ˆê°„ í”¼í•´ëŸ‰ 50% ê°ì†Œ!`, 2000);
                        break;
                    case 'magnet':
                        this.showMessage(`ìì„ íš¨ê³¼!`, `${value / 1000}ì´ˆê°„ ì•„ì´í…œ ìë™ ìˆ˜ì§‘!`, 2000);
                        break;
                    case 'health_regen':
                        this.showMessage(`ì²´ë ¥ ì¬ìƒ!`, `${value / 1000}ì´ˆê°„ ì²´ë ¥ ìë™ íšŒë³µ!`, 2000);
                        break;
                    case 'rapid':
                        this.showMessage(`ì—°ë°œ ëª¨ë“œ!`, `${value / 1000}ì´ˆê°„ ë°œì‚¬ ì†ë„ ì¦ê°€!`, 2000);
                        break;
                    case 'max_health':
                        this.showMessage(`ìµœëŒ€ ì²´ë ¥ +${value}!`, '', 1500);
                        break;
                    case 'ammo':
                        this.showMessage(`íƒ„ì•½ +${value}!`, '', 1500);
                        break;
                    case 'max_ammo':
                        this.showMessage(`ìµœëŒ€ íƒ„ì•½ +${value}!`, '', 1500);
                        break;
                }
                this.updateHUD();
            }
            
            // HUD ì—…ë°ì´íŠ¸ (ì²´ë ¥, íƒ„ì•½, ì ìˆ˜, ì›¨ì´ë¸Œ, ë¯¸ë‹ˆë§µ)
            updateHUD = () => {
                const player = this.gameState.player;
                const now = Date.now();
                
                // ì²´ë ¥ ë°” ì—…ë°ì´íŠ¸
                const healthPercent = (Math.max(0, player.health) / player.maxHealth) * 100;
                document.getElementById('healthFill').style.width = healthPercent + '%';
                
                // ì£½ì€ í”Œë ˆì´ì–´1ì€ íŠ¹ë³„í•œ í‘œì‹œ
                if (this.gameState.player1Dead) {
                    document.getElementById('healthText').textContent = 'ì‚¬ë§';
                    document.getElementById('healthFill').style.background = 'linear-gradient(90deg, #666, #999)';
                } else {
                    document.getElementById('healthText').textContent = `${Math.max(0, player.health.toFixed(0))}/${player.maxHealth.toFixed(0)}`;
                }
                
                // íƒ„ì•½ ë°” ì—…ë°ì´íŠ¸
                const ammoPercent = (player.ammo / player.maxAmmo) * 100;
                document.getElementById('ammoFill').style.width = ammoPercent + '%';
                
                // ì¬ì¥ì „ ì¤‘ì¼ ë•ŒëŠ” ë‹¤ë¥¸ ìƒ‰ìƒìœ¼ë¡œ í‘œì‹œ
                if (player.isReloading) {
                    document.getElementById('ammoFill').style.background = 'linear-gradient(90deg, #ff6b6b, #ff8e8e)';
                    document.getElementById('ammoText').textContent = 'ì¬ì¥ì „ ì¤‘...';
                } else {
                    document.getElementById('ammoFill').style.background = 'linear-gradient(90deg, #3b82f6, #60a5fa)';
                    document.getElementById('ammoText').textContent = `${player.ammo.toFixed(0)}/${player.maxAmmo.toFixed(0)}`;
                }
                
                // ì ìˆ˜ ë° ì›¨ì´ë¸Œ ì—…ë°ì´íŠ¸
                document.getElementById('scoreText').textContent = this.gameState.score.toLocaleString();
                document.getElementById('waveText').textContent = `ì›¨ì´ë¸Œ ${this.gameState.wave}`;
                document.getElementById('enemyCount').textContent = `ì : ${this.gameState.enemies.length}ë§ˆë¦¬`;

                // ìƒˆë¡œìš´ ìŠ¤íƒ¯ ì—…ë°ì´íŠ¸
                document.getElementById('speedText').textContent = player.speed;
                document.getElementById('damageText').textContent = player.baseDamage;
                document.getElementById('multishotText').textContent = player.multishot;

                // í™œì„± íš¨ê³¼ ì—…ë°ì´íŠ¸
                const invincibilityEl = document.getElementById('invincibilityEffect');
                const shieldBoostEl = document.getElementById('shieldBoostEffect');
                const timeSlowEl = document.getElementById('timeSlowEffect');
                const magnetEl = document.getElementById('magnetEffect');
                const healthRegenEl = document.getElementById('healthRegenEffect');
                const rapidFireEl = document.getElementById('rapidFireEffect');
                const piercingShotEl = document.getElementById('piercingShotEffect'); 
                const explosiveShotEl = document.getElementById('explosiveShotEffect'); 
                const orbitingKnivesEl = document.getElementById('orbitingKnivesEffect'); 
                const ricochetShotEl = document.getElementById('ricochetShotEffect'); 
                const homingShotEl = document.getElementById('homingShotEffect'); 
                const splitShotEl = document.getElementById('splitShotEffect'); 
                const ammoRegenEl = document.getElementById('ammoRegenEffect');
                const timeStopEl = document.getElementById('timeStopEffect');
                const dashEl = document.getElementById('dashEffect');
                
                // í™œì„± íš¨ê³¼ ì»¨í…Œì´ë„ˆ í‘œì‹œ/ìˆ¨ê¹€ ì²˜ë¦¬
                const activeEffectsContainer = document.getElementById('activeEffectsContainer');
                const hasActiveEffects = now < player.invincibleEndTime || 
                                       now < player.shieldBoostEndTime || 
                                       now < this.gameState.timeSlowEndTime || 
                                       now < player.magnetEndTime || 
                                       now < player.healthRegenEndTime || 
                                       now < player.rapidFireTime || 
                                       player.piercingShot > 0 || 
                                       player.explosiveShot > 0 || 
                                       player.orbitingKnives.length > 0 || 
                                       player.ricochetLevel > 0 || 
                                       player.homingLevel > 0 || 
                                       player.splitLevel > 0 || 
                                       now < player.ammoRegenEndTime || 
                                       now < this.gameState.timeStopEndTime || 
                                       player.isDashing || 
                                       now - player.dashCooldown < 1000 || 
                                       player.lifeStealPercent > 0 || 
                                       player.critChance > 0 || 
                                       player.cooldownReduction > 0 || 
                                       player.armor > 0;
                
                if (hasActiveEffects) {
                    activeEffectsContainer.style.display = 'block';
                } else {
                    activeEffectsContainer.style.display = 'none';
                }

                invincibilityEl.textContent = now < player.invincibleEndTime ? `ë¬´ì : ${( (player.invincibleEndTime - now) / 1000).toFixed(1)}ì´ˆ` : '';
                shieldBoostEl.textContent = now < player.shieldBoostEndTime ? `ì‰´ë“œ ê°•í™”: ${( (player.shieldBoostEndTime - now) / 1000).toFixed(1)}ì´ˆ (${(1 - player.damageReductionFactor) * 100}% ê°ì†Œ)` : '';
                timeSlowEl.textContent = now < this.gameState.timeSlowEndTime && this.gameState.timeSlowEffect > 0 ? `ì‹œê°„ ë‘”í™”: ${( (this.gameState.timeSlowEndTime - now) / 1000).toFixed(1)}ì´ˆ` : '';
                magnetEl.textContent = now < player.magnetEndTime ? `ìì„: ${( (player.magnetEndTime - now) / 1000).toFixed(1)}ì´ˆ` : '';
                healthRegenEl.textContent = now < player.healthRegenEndTime ? `ì²´ë ¥ ì¬ìƒ: ${( (player.healthRegenEndTime - now) / 1000).toFixed(1)}ì´ˆ` : '';
                rapidFireEl.textContent = now < player.rapidFireTime ? `ì—°ë°œ: ${( (player.rapidFireTime - now) / 1000).toFixed(1)}ì´ˆ` : '';
                piercingShotEl.textContent = player.piercingShot > 0 ? `ê´€í†µ ì‚¬ê²©: ${player.piercingShot}íšŒ` : '';
                explosiveShotEl.textContent = player.explosiveShot > 0 ? `í­ë°œ ì‚¬ê²©: Lv.${player.explosiveShot}` : '';
                orbitingKnivesEl.textContent = player.orbitingKnives.length > 0 ? `íšŒì „ ì¹¼ë‚ : ${player.orbitingKnives.length}ê°œ` : '';
                ricochetShotEl.textContent = player.ricochetLevel > 0 ? `ë„íƒ„ ì‚¬ê²©: Lv.${player.ricochetLevel}` : '';
                homingShotEl.textContent = player.homingLevel > 0 ? `ìœ ë„ ì‚¬ê²©: Lv.${player.homingLevel}` : '';
                splitShotEl.textContent = player.splitLevel > 0 ? `ë¶„ì—´ ì‚¬ê²©: Lv.${player.splitLevel}` : '';
                ammoRegenEl.textContent = now < player.ammoRegenEndTime ? `íƒ„ì•½ ì¬ìƒ: ${( (player.ammoRegenEndTime - now) / 1000).toFixed(1)}ì´ˆ` : '';
                timeStopEl.textContent = now < this.gameState.timeStopEndTime ? `ì‹œê°„ ì •ì§€: ${( (this.gameState.timeStopEndTime - now) / 1000).toFixed(1)}ì´ˆ` : '';
                if (dashEl) {
                    if (player.isDashing) dashEl.textContent = `ëŒ€ì‹œ: ë¬´ì !`;
                    else if (now - player.dashCooldown < 1000) dashEl.textContent = `ëŒ€ì‹œ ì¿¨íƒ€ì„: ${((1000 - (now - player.dashCooldown))/1000).toFixed(1)}ì´ˆ`;
                    else dashEl.textContent = '';
                }


                // íŒ¨ì‹œë¸Œ ìŠ¤í‚¬ ì—…ë°ì´íŠ¸
                const lifeStealEl = document.getElementById('lifeStealEffect');
                const critChanceEl = document.getElementById('critChanceEffect');
                const cooldownReductionEl = document.getElementById('cooldownReductionEffect');
                const armorEl = document.getElementById('armorEffect');

                lifeStealEl.textContent = player.lifeStealPercent > 0 ? `ìƒëª…ë ¥ í¡ìˆ˜: ${(player.lifeStealPercent * 100).toFixed(0)}%` : '';
                critChanceEl.textContent = player.critChance > 0 ? `ì¹˜ëª…íƒ€ í™•ë¥ : ${(player.critChance * 100).toFixed(0)}%` : '';
                cooldownReductionEl.textContent = player.cooldownReduction > 0 ? `ì¬ì‚¬ìš© ëŒ€ê¸°ì‹œê°„ ê°ì†Œ: ${(player.cooldownReduction * 100).toFixed(0)}%` : '';
                armorEl.textContent = player.armor > 0 ? `ë°©ì–´ë ¥: ${player.armor}` : '';

                // ë¯¸ë‹ˆë§µ ì—…ë°ì´íŠ¸
                this.updateMinimap();


                // ë³´ìŠ¤ ì²´ë ¥ë°” í‘œì‹œ
                const bossBarContainer = document.getElementById('bossBarContainer');
                const bossBar = document.getElementById('bossBar');
                const bossName = document.getElementById('bossName');
                
                if (this.bossSystem && this.bossSystem.isActive && this.bossSystem.currentBoss) {
                    const boss = this.bossSystem.currentBoss;
                    bossBarContainer.style.display = 'block';
                    bossName.textContent = this.ENEMY_TYPES[boss.type].name;
                    bossBar.style.width = Math.max(0, (boss.health / boss.maxHealth) * 100) + '%';
                } else {
                    bossBarContainer.style.display = 'none';
                }
                
                // í”Œë ˆì´ì–´2 HUD ì—…ë°ì´íŠ¸ (ë©€í‹°í”Œë ˆì´ ëª¨ë“œì¼ ë•Œë§Œ)
                if (this.gameState.player2 && this.gameState.multiplayerMode) {
                    const player2 = this.gameState.player2;
                    
                    // í”Œë ˆì´ì–´2 ì²´ë ¥ ë°” ì—…ë°ì´íŠ¸
                    const healthPercent2 = (Math.max(0, player2.health) / player2.maxHealth) * 100;
                    document.getElementById('healthFill2').style.width = healthPercent2 + '%';
                    
                    // ì£½ì€ í”Œë ˆì´ì–´2ëŠ” íŠ¹ë³„í•œ í‘œì‹œ
                    if (this.gameState.player2Dead) {
                        document.getElementById('healthText2').textContent = 'ì‚¬ë§';
                        document.getElementById('healthFill2').style.background = 'linear-gradient(90deg, #666, #999)';
                        document.getElementById('ammoText2').textContent = 'ë¶€í™œ ëŒ€ê¸°';
                        document.getElementById('ammoFill2').style.background = 'linear-gradient(90deg, #666, #999)';
                    } else {
                        document.getElementById('healthText2').textContent = `${Math.max(0, player2.health.toFixed(0))}/${player2.maxHealth.toFixed(0)}`;
                        
                        // í”Œë ˆì´ì–´2 íƒ„ì•½ ë°” ì—…ë°ì´íŠ¸
                        const ammoPercent2 = (player2.ammo / player2.maxAmmo) * 100;
                        document.getElementById('ammoFill2').style.width = ammoPercent2 + '%';
                        
                        // ì¬ì¥ì „ ì¤‘ì¼ ë•ŒëŠ” ë‹¤ë¥¸ ìƒ‰ìƒìœ¼ë¡œ í‘œì‹œ
                        if (player2.isReloading) {
                            document.getElementById('ammoFill2').style.background = 'linear-gradient(90deg, #ff6b6b, #ff8e8e)';
                            document.getElementById('ammoText2').textContent = 'ì¬ì¥ì „ ì¤‘...';
                        } else {
                            document.getElementById('ammoFill2').style.background = 'linear-gradient(90deg, #ef4444, #f87171)';
                            document.getElementById('ammoText2').textContent = `${player2.ammo.toFixed(0)}/${player2.maxAmmo.toFixed(0)}`;
                        }
                    }
                    
                    // í”Œë ˆì´ì–´2 HUD í‘œì‹œ
                    document.getElementById('player2HUD').style.display = 'flex';
                } else {
                    // í”Œë ˆì´ì–´2 HUD ìˆ¨ê¸°ê¸°
                    document.getElementById('player2HUD').style.display = 'none';
                }
                
                // 5. updateHUDì— XP/ì ìˆ˜ í‘œì‹œ ì¶”ê°€ (í…ŒìŠ¤íŒ… ì¡´ì—ì„œëŠ” ì ìˆ˜ë§Œ)
                if (this.gameMode === 'testzone') {
                    document.getElementById('xpText').textContent = `ì ìˆ˜: ${this.gameState.score}`;
                    // í…ŒìŠ¤íŒ… ì¡´ì—ì„œëŠ” ìƒì  ë²„íŠ¼ ìˆ¨ê¸°ê¸°, í…ŒìŠ¤íŠ¸ ì¡´ ë²„íŠ¼ ë³´ì´ê¸°
                    document.getElementById('shopButton').style.display = 'none';
                    document.getElementById('testZoneHUDButton').style.display = 'inline-block';
                } else {
                    document.getElementById('xpText').textContent = `XP: ${this.xp}`;
                    // ì†”ë¡œ í”Œë ˆì´ì—ì„œëŠ” ìƒì  ë²„íŠ¼ ë³´ì´ê¸°, í…ŒìŠ¤íŠ¸ ì¡´ ë²„íŠ¼ ìˆ¨ê¸°ê¸°
                    document.getElementById('shopButton').style.display = 'inline-block';
                    document.getElementById('testZoneHUDButton').style.display = 'none';
                }
            }
            
            // ë¯¸ë‹ˆë§µ ì—…ë°ì´íŠ¸ (í”Œë ˆì´ì–´, ì , ì•„ì´í…œ ìœ„ì¹˜ í‘œì‹œ)
            updateMinimap = () => {
                const minimapPlayer = document.getElementById('minimapPlayer');
                const minimap = document.getElementById('minimap');
                
                // í”Œë ˆì´ì–´ ìœ„ì¹˜ ê³„ì‚° ë° ì—…ë°ì´íŠ¸
                const playerX = (this.gameState.player.x / this.canvas.width) * 120;
                const playerY = (this.gameState.player.y / this.canvas.height) * 120;
                
                minimapPlayer.style.left = playerX + 'px';
                minimapPlayer.style.top = playerY + 'px';
                
                // ê¸°ì¡´ ì /ì•„ì´í…œ ë„íŠ¸ ì œê±°
                const existingDots = minimap.querySelectorAll('.minimap-enemy, .minimap-item, .minimap-ally, .minimap-other-player');
                existingDots.forEach(dot => dot.remove());
                
                // ì  ë„íŠ¸ ì¶”ê°€
                this.gameState.enemies.forEach(enemy => {
                    const enemyX = (enemy.x / this.canvas.width) * 120;
                    const enemyY = (enemy.y / this.canvas.height) * 120;
                    
                    const dot = document.createElement('div');
                    dot.className = 'minimap-enemy';
                    dot.style.left = enemyX + 'px';
                    dot.style.top = enemyY + 'px';
                    minimap.appendChild(dot);
                });
                
                // ì•„ì´í…œ ë„íŠ¸ ì¶”ê°€
                this.gameState.items.forEach(item => {
                    const itemX = (item.x / this.canvas.width) * 120;
                    const itemY = (item.y / this.canvas.height) * 120;
                    
                    const dot = document.createElement('div');
                    dot.className = 'minimap-item';
                    dot.style.left = itemX + 'px';
                    dot.style.top = itemY + 'px';
                    minimap.appendChild(dot);
                });

                // ì•„êµ° ë„íŠ¸ ì¶”ê°€
                this.gameState.allies.forEach(ally => {
                    const allyX = (ally.x / this.canvas.width) * 120;
                    const allyY = (ally.y / this.canvas.height) * 120;
                    
                    const dot = document.createElement('div');
                    dot.className = 'minimap-ally';
                    dot.style.left = allyX + 'px';
                    dot.style.top = allyY + 'px';
                    dot.style.backgroundColor = ally.color;
                    dot.style.width = '3px';
                    dot.style.height = '3px';
                    dot.style.borderRadius = '50%';
                    minimap.appendChild(dot);
                });
                
                // ë‹¤ë¥¸ í”Œë ˆì´ì–´ë“¤ ë„íŠ¸ ì¶”ê°€
                if (this.gameState.otherPlayers) {
                    Object.values(this.gameState.otherPlayers).forEach(otherPlayer => {
                        if (otherPlayer && otherPlayer.isAlive !== false) {
                            const playerX = (otherPlayer.x / this.canvas.width) * 120;
                            const playerY = (otherPlayer.y / this.canvas.height) * 120;
                            
                            const dot = document.createElement('div');
                            dot.className = 'minimap-other-player';
                            dot.style.left = playerX + 'px';
                            dot.style.top = playerY + 'px';
                            dot.style.backgroundColor = otherPlayer.color || '#60a5fa';
                            dot.style.width = '4px';
                            dot.style.height = '4px';
                            dot.style.borderRadius = '50%';
                            dot.style.border = '1px solid white';
                            minimap.appendChild(dot);
                        }
                    });
                }
                
                // í”Œë ˆì´ì–´2 ë„íŠ¸ ì¶”ê°€ (ë¡œì»¬ ë©€í‹°í”Œë ˆì´ì–´)
                if (this.gameState.player2 && this.gameState.multiplayerMode && !this.gameState.player2Dead) {
                    const player2X = (this.gameState.player2.x / this.canvas.width) * 120;
                    const player2Y = (this.gameState.player2.y / this.canvas.height) * 120;
                    
                    const dot = document.createElement('div');
                    dot.className = 'minimap-other-player';
                    dot.style.left = player2X + 'px';
                    dot.style.top = player2Y + 'px';
                    dot.style.backgroundColor = this.gameState.player2.color || '#f59e0b';
                    dot.style.width = '4px';
                    dot.style.height = '4px';
                    dot.style.borderRadius = '50%';
                    dot.style.border = '1px solid white';
                    minimap.appendChild(dot);
                }
            }
            
            // ìºë¦­í„° (í”Œë ˆì´ì–´ ë° ì ) ê·¸ë¦¬ê¸° (ìœ ë ¹ ë¬´ì  ìƒíƒœ ì‹œ ì‹œê°ì  íš¨ê³¼ ì¶”ê°€)
            drawCharacter = (character) => {
                this.ctx.save(); // í˜„ì¬ ìº”ë²„ìŠ¤ ìƒíƒœ ì €ì¥
                
                // ê·¸ë¦¼ì ê·¸ë¦¬ê¸° (ë³€í™˜ ì „)
                this.ctx.globalAlpha = 0.2;
                this.ctx.fillStyle = 'black';
                this.ctx.fillRect(character.x + 3, character.y + character.height + 3, character.width, 5);
                
                // í”Œë ˆì´ì–´ ìºë¦­í„° ê·¸ë¦¬ê¸° (ë³€í™˜ ì ìš©)
                if (character.type === 'player' || character.type === 'player2') {
                    // ìºë¦­í„°ì˜ ì¤‘ì‹¬ìœ¼ë¡œ ìº”ë²„ìŠ¤ ì›ì  ì´ë™
                    this.ctx.translate(character.x + character.width / 2, character.y + character.height / 2);
                    // ë§ˆìš°ìŠ¤ ë°©í–¥ìœ¼ë¡œ í”Œë ˆì´ì–´ íšŒì „ (ìºë¦­í„°ì˜ ê¸°ë³¸ ë°©í–¥ì´ ì˜¤ë¥¸ìª½ì´ë¼ê³  ê°€ì •í•˜ê³  180ë„ íšŒì „ ë³´ì •)
                    this.ctx.rotate(character.facing + Math.PI); 

                    // ì£½ì€ í”Œë ˆì´ì–´ëŠ” ë°˜íˆ¬ëª…í•˜ê²Œ í‘œì‹œ
                    if ((character.type === 'player' && this.gameState.player1Dead) || 
                        (character.type === 'player2' && this.gameState.player2Dead)) {
                        this.ctx.globalAlpha = 0.3;
                    } else {
                        this.ctx.globalAlpha = 0.8;
                    }
                    
                    this.ctx.fillStyle = character.color;
                    this.ctx.shadowBlur = 15;
                    this.ctx.shadowColor = character.color;
                    this.ctx.beginPath();
                    this.ctx.roundRect(-character.width / 2, -character.height / 2, character.width, character.height, 8);
                    this.ctx.fill();

                    // ê¸€ë˜ìŠ¤ íš¨ê³¼
                    this.ctx.globalAlpha = 0.3;
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    this.ctx.beginPath();
                    this.ctx.roundRect(-character.width / 2, -character.height / 2, character.width, character.height / 2, 8);
                    this.ctx.fill();

                    // í‘œì • ê·¸ë¦¬ê¸°
                    this.ctx.globalAlpha = 1;
                    this.ctx.fillStyle = 'white';
                    const fontSize = '16px';
                    this.ctx.font = `${fontSize} Poppins`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(character.expression, 0, 0); // ìƒˆë¡œìš´ ì›ì (0,0)ì— ê·¸ë¦¬ê¸°

                    // í”Œë ˆì´ì–´ ì´ ì´ëª¨ì§€ ê·¸ë¦¬ê¸° (ë°˜ë™ íš¨ê³¼ í¬í•¨)
                    this.ctx.font = '20px Poppins'; // ì´ ì´ëª¨ì§€ í¬ê¸°
                    this.ctx.fillStyle = 'black'; // ì´ ìƒ‰ìƒ ê²€ì •ìƒ‰ìœ¼ë¡œ ë³€ê²½
                    
                    // ì´ ë°˜ë™ íš¨ê³¼ ì ìš©
                    const recoilOffset = character.gunRecoil || 0;
                    
                    // ì´ ì´ëª¨ì§€ë¥¼ í”Œë ˆì´ì–´ì˜ ì™¼ìª½ (ìºë¦­í„° ì¤‘ì‹¬ ê¸°ì¤€ ì™¼ìª½)ì— ê³ ì • + ë°˜ë™
                    const gunOffsetX = -character.width / 2 - 10 - recoilOffset; // ë°˜ë™ìœ¼ë¡œ ë’¤ë¡œ ë°€ë¦¼
                    const weaponEmoji = (this.currentWeapon === 'melee') ? 'ğŸ”ª' : 'ğŸ”«';
                    this.ctx.fillText(weaponEmoji, gunOffsetX, 0); // ë°˜ë™ ì˜¤í”„ì…‹ ì ìš©

                    // í”Œë ˆì´ì–´2 í‘œì‹œ (ë©€í‹°í”Œë ˆì´ ëª¨ë“œì—ì„œë§Œ)
                    if (character.type === 'player2') {
                        this.ctx.font = '12px Poppins';
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                        this.ctx.fillText('P2', character.width / 2 + 15, -character.height / 2 - 10);
                    }

                } else {
                    // ë¹„-í”Œë ˆì´ì–´ ìºë¦­í„° (ì , ì•„êµ°) ê·¸ë¦¬ê¸° (ë³€í™˜ ì—†ìŒ)
                    // ìºë¦­í„° ëª¸ì²´ (ê¸€ë˜ìŠ¤ íš¨ê³¼)
                    this.ctx.globalAlpha = 0.8;
                    this.ctx.fillStyle = character.color;
                    
                    // ë³´ìŠ¤ëŠ” ë” ê°•í•œ ê¸€ë¡œìš° íš¨ê³¼, ìœ ë ¹ì€ ë¬´ì  ìƒíƒœ ì‹œ ë‹¤ë¥¸ íš¨ê³¼
                    if (character.type && character.type.startsWith('boss')) { // ëª¨ë“  ë³´ìŠ¤ íƒ€ì…ì— ì ìš©
                        this.ctx.shadowBlur = 25;
                        this.ctx.shadowColor = character.color;
                        if (character.type === 'boss_beta' && character.isInvincible) { // ë² íƒ€ ë³´ìŠ¤ ì‰´ë“œ ì‹œ
                            this.ctx.globalAlpha = 0.4;
                            this.ctx.shadowBlur = 15;
                            this.ctx.shadowColor = 'rgba(135, 206, 235, 0.8)'; // ìŠ¤ì¹´ì´ë¸”ë£¨ ê¸€ë¡œìš°
                        }
                    } else if (character.type === 'ghost' && character.isInvincible) {
                        this.ctx.globalAlpha = 0.4; // ë¬´ì  ìƒíƒœ ì‹œ ë°˜íˆ¬ëª…
                        this.ctx.shadowBlur = 10;
                        this.ctx.shadowColor = 'rgba(255, 255, 255, 0.7)'; // í°ìƒ‰ ê¸€ë¡œìš°
                    } else if (character.type === 'berserker' && character.isRaging) {
                        this.ctx.shadowBlur = 20;
                        this.ctx.shadowColor = 'red'; // ê´‘ì „ì‚¬ ê´‘í­í™” ì‹œ ë¶‰ì€ ê¸€ë¡œìš°
                    } else if (character.type === 'phaser' && character.isPhasing) {
                        this.ctx.globalAlpha = 0.3; // í˜ì´ì¦ˆ ìƒíƒœ ì‹œ ë°˜íˆ¬ëª…
                        this.ctx.shadowBlur = 15;
                        this.ctx.shadowColor = 'rgba(6, 182, 212, 0.8)'; // ì‹œì•ˆ ê¸€ë¡œìš°
                    } else {
                        this.ctx.shadowBlur = 15;
                        this.ctx.shadowColor = character.color;
                    }
                    
                    this.ctx.beginPath();
                    this.ctx.roundRect(character.x, character.y, character.width, character.height, 8);
                    this.ctx.fill();
                    
                    // ê¸€ë˜ìŠ¤ íš¨ê³¼
                    this.ctx.globalAlpha = 0.3;
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    this.ctx.beginPath();
                    this.ctx.roundRect(character.x, character.y, character.width, character.height / 2, 8);
                    this.ctx.fill();
                    
                    // í‘œì • ê·¸ë¦¬ê¸°
                    this.ctx.globalAlpha = 1;
                    this.ctx.fillStyle = 'white';
                    
                    // ë³´ìŠ¤ëŠ” ë” í° í°íŠ¸
                    const fontSize = character.type && character.type.startsWith('boss') ? '20px' : '16px'; // character.type ì²´í¬ ì¶”ê°€
                    this.ctx.font = `${fontSize} Poppins`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(character.expression, character.x + character.width / 2, character.y + character.height / 2);
                    
                    // ì  íƒ€ì… í‘œì‹œ (ì‘ì€ ì•„ì´ì½˜)
                    if (character.type && character !== this.gameState.player) { // character.type ì²´í¬ ì¶”ê°€
                        this.ctx.font = '10px Poppins';
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        let typeIcon = '';
                        switch (character.type) {
                            case 'fast': typeIcon = 'âš¡'; break;
                            case 'tank': typeIcon = 'ğŸ›¡'; break;
                            case 'sniper': typeIcon = 'ğŸ¯'; break;
                            case 'bomber': typeIcon = 'ğŸ’£'; break;
                            case 'guardian': typeIcon = 'ğŸ›¡ï¸'; break;
                            case 'assassin': typeIcon = 'ğŸ—¡'; break;
                            case 'heavy': typeIcon = 'ğŸ’ª'; break;
                            case 'ghost': typeIcon = 'ğŸ‘»'; break; 
                            case 'medic': typeIcon = 'â•'; break; 
                            case 'summoner': typeIcon = 'ğŸŒ€'; break; 
                            case 'jumper': typeIcon = 'â¬†ï¸'; break; 
                            case 'shielded': typeIcon = 'ğŸ›¡ï¸'; break; 
                            case 'teleporter': typeIcon = 'ğŸ’«'; break; 
                            case 'drone': typeIcon = 'ğŸ“¡'; break; 
                            case 'spitter': typeIcon = 'ğŸ¦ '; break; 
                            case 'berserker': typeIcon = 'ğŸ’¢'; break; 
                            case 'boss_alpha': typeIcon = 'Î±'; break; // ì•ŒíŒŒ ë³´ìŠ¤ ì•„ì´ì½˜
                            case 'boss_beta': typeIcon = 'Î²'; break; // ë² íƒ€ ë³´ìŠ¤ ì•„ì´ì½˜
                            case 'boss_gamma': typeIcon = 'Î³'; break; // ê°ë§ˆ ë³´ìŠ¤ ì•„ì´ì½˜
                            case 'leech': typeIcon = 'ğŸ©¸'; break; // í¡í˜ˆ ì 
                            case 'mine': typeIcon = 'ğŸ’£'; break; // ì§€ë¢° ì 
                            case 'freezer': typeIcon = 'â„ï¸'; break; // ë¹™ê²° ì 
                            case 'reflector': typeIcon = 'ğŸª'; break; // ë°˜ì‚¬ ì 
                            case 'healer': typeIcon = 'ğŸ’š'; break; // íëŸ¬ ì 
                            case 'portal': typeIcon = 'ğŸŒ€'; break; // í¬íƒˆ ì 
                            case 'exploder': typeIcon = 'ğŸ’¥'; break; // í­ë°œ ì 
                            case 'magnet': typeIcon = 'ğŸ§²'; break; // ìì„ ì 
                            case 'curse': typeIcon = 'ğŸ‘¹'; break; // ì €ì£¼ ì 
                            case 'floater': typeIcon = 'ğŸ¦‹'; break; // í”Œë¡œí„°
                            case 'phaser': typeIcon = 'ğŸ‘»'; break; // í˜ì´ì €
                            case 'ally': typeIcon = 'ğŸ¤–'; break; // ì•„êµ° ì•„ì´ì½˜
                            default: typeIcon = ''; break;
                        }
                        if (typeIcon) {
                            this.ctx.fillText(typeIcon, character.x + character.width - 8, character.y + 8);
                        }
                    }
                    
                    // ì²´ë ¥ ë°” ê·¸ë¦¬ê¸°
                    if (character.health < character.maxHealth || (character.type && character.type.startsWith('boss')) || character.type === 'ally') { // ë³´ìŠ¤, ì•„êµ°ë„ í•­ìƒ ì²´ë ¥ë°” í‘œì‹œ
                        const barWidth = character.width;
                        const barHeight = (character.type && character.type.startsWith('boss')) ? 6 : 4; // character.type ì²´í¬ ì¶”ê°€
                        const barX = character.x;
                        const barY = character.y - 12;
                        
                        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                        this.ctx.fillRect(barX, barY, barWidth, barHeight);
                        
                        let healthColor;
                        if (character === this.gameState.player) {
                            healthColor = '#22c55e';
                        } else if (character.type && character.type.startsWith('boss')) { // character.type ì²´í¬ ì¶”ê°€
                            healthColor = '#dc2626';
                        } else if (character.type === 'ally') { // ì•„êµ° ì²´ë ¥ë°” ìƒ‰ìƒ
                            healthColor = '#90ee90';
                        } else {
                            healthColor = character.color;
                        }
                        
                        this.ctx.fillStyle = healthColor;
                        this.ctx.fillRect(barX, barY, (character.health / character.maxHealth) * barWidth, barHeight);
                    }
                }
                
                this.ctx.restore(); // ì €ì¥ëœ ìº”ë²„ìŠ¤ ìƒíƒœ ë³µì›
            }

            // íšŒì „ ì¹¼ë‚  ê·¸ë¦¬ê¸° ë° ì¶©ëŒ ê°ì§€
            drawOrbitingKnives = () => {
                const player = this.gameState.player;
                const now = Date.now();

                player.orbitingKnives.forEach(knife => {
                    // ê°ë„ ì—…ë°ì´íŠ¸ (ì‹œê°„ ë‘”í™” íš¨ê³¼ ì ìš©)
                    knife.angle += knife.speed * (this.gameState.timeSlowEffect < 1 ? this.gameState.timeSlowEffect : 1);

                    // ì¹¼ë‚  ìœ„ì¹˜ ê³„ì‚°
                    const knifeX = player.x + player.width / 2 + Math.cos(knife.angle) * knife.radius;
                    const knifeY = player.y + player.height / 2 + Math.sin(knife.angle) * knife.radius;

                    // ì¹¼ë‚  ê·¸ë¦¬ê¸°
                    this.ctx.save();
                    this.ctx.globalAlpha = 0.9;
                    this.ctx.fillStyle = knife.color;
                    this.ctx.shadowBlur = 10;
                    this.ctx.shadowColor = knife.color;
                    this.ctx.beginPath();
                    this.ctx.roundRect(knifeX - 5, knifeY - 5, 10, 10, 2); // ì‘ì€ ì‚¬ê°í˜•ìœ¼ë¡œ ì¹¼ë‚  í‘œí˜„
                    this.ctx.fill();
                    this.ctx.globalAlpha = 1;
                    this.ctx.font = '12px Poppins';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(knife.emoji, knifeX, knifeY);
                    this.ctx.restore();

                    // ì ê³¼ì˜ ì¶©ëŒ ê°ì§€
                    this.gameState.enemies = this.gameState.enemies.filter(enemy => {
                        const dx = knifeX - (enemy.x + enemy.width / 2);
                        const dy = knifeY - (enemy.y + enemy.height / 2);
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        // ì¿¨ë‹¤ìš´ ì²´í¬ ë° ì¶©ëŒ ë²”ìœ„ ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
                        if (distance < 15 + enemy.width / 2 && now - knife.lastHit > knife.cooldown) { // 15ëŠ” ì¹¼ë‚ ì˜ ëŒ€ëµì ì¸ ë°˜ì§€ë¦„
                            // ìœ ë ¹, ë°©íŒ¨ë³‘, ë² íƒ€ ë³´ìŠ¤ ì‰´ë“œ ë¬´ì  ìƒíƒœ ì²´í¬
                            if (enemy.type === 'ghost' && enemy.isInvincible) return true;
                            if (enemy.type === 'boss_beta' && enemy.isInvincible) return true;

                            let actualDamage = knife.damage;
                            if (enemy.type === 'shielded') {
                                const angleToKnife = Math.atan2(dy, dx);
                                const angleDiff = Math.abs(angleToKnife - enemy.facing);
                                if (angleDiff < enemy.shieldAngle || angleDiff > (2 * Math.PI - enemy.shieldAngle)) {
                                    // ë°©íŒ¨ë³‘ì´ ì¹¼ë‚ ì„ ë°©ì–´í•˜ëŠ” ë°©í–¥ì— ìˆìœ¼ë©´ í”¼í•´ ê°ì†Œ
                                    actualDamage *= 0.1;
                                    this.createFloatingText(enemy.x + enemy.width / 2, enemy.y, `-${actualDamage.toFixed(0)} (ë°©ì–´)`, 'orange');
                                } else {
                                    this.createFloatingText(enemy.x + enemy.width / 2, enemy.y, `-${actualDamage.toFixed(0)}`, 'white');
                                }
                            } else {
                                this.createFloatingText(enemy.x + enemy.width / 2, enemy.y, `-${actualDamage.toFixed(0)}`, 'white');
                            }
                            enemy.health -= actualDamage;

                            this.createHitParticles(knifeX, knifeY);
                            knife.lastHit = now; // ì´ ì¹¼ë‚ ì˜ ë§ˆì§€ë§‰ ê³µê²© ì‹œê°„ ì—…ë°ì´íŠ¸

                            // ìƒëª…ë ¥ í¡ìˆ˜ (Life Steal) ì ìš©
                            if (player.lifeStealPercent > 0) {
                                const healedAmount = actualDamage * player.lifeStealPercent;
                                player.health = Math.min(player.maxHealth, player.health + healedAmount);
                                this.createFloatingText(player.x + player.width / 2, player.y - 20, `+${healedAmount.toFixed(0)} í¡ìˆ˜`, 'lightgreen');
                            }

                            if (enemy.health <= 0) {
                                this.addScore(enemy.points);
                                if (Math.random() < 0.4) this.gameState.items.push(this.createItem(enemy.x, enemy.y));
                                // === ë³´ìŠ¤ ì‚¬ë§ ì²˜ë¦¬ ì¶”ê°€ ===
                                if (enemy.type && enemy.type.startsWith('boss')) {
                                    if (this.bossSystem && this.bossSystem.currentBoss && this.bossSystem.currentBoss.id === enemy.id) {
                                        this.bossSystem.currentBoss = null;
                                    }
                                    this.checkBossWaveComplete(); // â† ë¨¼ì € í˜¸ì¶œ
                                    this.resetBossSystem();
                                }
                                // =========================
                                this.gameState.enemies = this.gameState.enemies.filter(e => e !== enemy);
                                return false; // ì  ì œê±°
                            }
                        }
                        return true; // ì  ìœ ì§€
                    });
                });
            }
            
            // ë°œì‚¬ì²´ ê·¸ë¦¬ê¸°
            drawProjectile = (projectile) => {
                this.ctx.save();
                this.ctx.globalAlpha = 0.8;
                this.ctx.fillStyle = projectile.color;
                this.ctx.shadowBlur = 8;
                this.ctx.shadowColor = projectile.color;
                this.ctx.beginPath();
                this.ctx.arc(projectile.x, projectile.y, projectile.radius, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.restore();
            }
            
            // ì•„ì´í…œ ê·¸ë¦¬ê¸°
            drawItem = (item) => {
                this.ctx.save();
                this.ctx.globalAlpha = 0.9;
                this.ctx.fillStyle = item.color;
                this.ctx.shadowBlur = 10;
                this.ctx.shadowColor = item.color;
                this.ctx.beginPath();
                this.ctx.roundRect(item.x, item.y, item.width, item.height, 4);
                this.ctx.fill();
                
                // ì•„ì´í…œ ì•„ì´ì½˜ ê·¸ë¦¬ê¸°
                this.ctx.globalAlpha = 1;
                this.ctx.font = '12px Poppins';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(item.emoji, item.x + item.width / 2, item.y + item.height / 2);
                
                this.ctx.restore();
            }
            
            // íŒŒí‹°í´ ê·¸ë¦¬ê¸°
            drawParticle = (particle) => {
                this.ctx.save();
                this.ctx.globalAlpha = particle.life / particle.maxLife; // ìˆ˜ëª…ì— ë”°ë¼ íˆ¬ëª…ë„ ì¡°ì ˆ
                this.ctx.fillStyle = particle.color;
                this.ctx.beginPath();
                this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.restore();
            }

            // ë– ë‹¤ë‹ˆëŠ” í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸°
            drawFloatingText = (text) => {
                this.ctx.save();
                this.ctx.globalAlpha = text.life / text.maxLife; // ìˆ˜ëª…ì— ë”°ë¼ íˆ¬ëª…ë„ ì¡°ì ˆ
                this.ctx.fillStyle = text.color;
                this.ctx.font = 'bold 16px Poppins';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(text.text, text.x, text.y);
                this.ctx.restore();
            }
            
            // ë°°ê²½ ê·¸ë¦¬ê¸°
            drawBackground = () => {
                // ë°°ê²½ ê·¸ë¼ë°ì´ì…˜
                const gradient = this.ctx.createLinearGradient(0, 0, this.canvas.width, this.canvas.height);
                gradient.addColorStop(0, '#667eea');
                gradient.addColorStop(1, '#764ba2');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // ì§€ë©´ ê·¸ë¦¬ê¸°
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                this.ctx.fillRect(0, this.canvas.height - this.GROUND_Y, this.canvas.width, this.GROUND_Y);
            }
            
            // ëª¨ë“  ê²Œì„ ìš”ì†Œ ë Œë”ë§
            render = () => {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); // ìº”ë²„ìŠ¤ ì´ˆê¸°í™”
                
                this.drawBackground(); // ë°°ê²½ ê·¸ë¦¬ê¸°
                
                // ìºë¦­í„° ê·¸ë¦¬ê¸°
                this.drawCharacter(this.gameState.player);
                // í”Œë ˆì´ì–´2 ê·¸ë¦¬ê¸° (ë©€í‹°í”Œë ˆì´ ëª¨ë“œì¼ ë•Œë§Œ)
                if (this.gameState.player2 && this.gameState.multiplayerMode) {
                    this.drawCharacter(this.gameState.player2);
                }
                this.gameState.enemies.forEach(enemy => this.drawCharacter(enemy));
                this.gameState.allies.forEach(ally => this.drawCharacter(ally));
                
                // íšŒì „ ì¹¼ë‚  ê·¸ë¦¬ê¸° ë° ì¶©ëŒ
                this.drawOrbitingKnives();
                
                // íŒŒí‹°í´ ê·¸ë¦¬ê¸°
                this.gameState.particles.forEach(particle => this.drawParticle(particle));
                
                // ë°œì‚¬ì²´ ê·¸ë¦¬ê¸°
                this.gameState.projectiles.forEach(projectile => this.drawProjectile(projectile));
                
                // ì•„ì´í…œ ê·¸ë¦¬ê¸°
                this.gameState.items.forEach(item => this.drawItem(item));
                
                // ë– ë‹¤ë‹ˆëŠ” í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸°
                this.gameState.floatingTexts.forEach(text => this.drawFloatingText(text));
                
                // íŒŒí‹°í´ ìƒíƒœ ì—…ë°ì´íŠ¸
                this.updateParticles();
                
                // ë°œì‚¬ì²´ ìƒíƒœ ì—…ë°ì´íŠ¸ ë° ì¶©ëŒ ê°ì§€
                this.updateProjectiles();
                
                // ì•„ì´í…œ ìƒíƒœ ì—…ë°ì´íŠ¸ ë° í”Œë ˆì´ì–´ ì¶©ëŒ ê°ì§€
                this.updateItems();
                
                // HUD ì—…ë°ì´íŠ¸
                this.updateHUD();
                this.updateFloatingTexts();
            }
            // ê²Œì„ ë£¨í”„
            gameLoop = () => {
                // ì‹œê°„ ì •ì§€/ë‘”í™” í•´ì œ ì²´í¬
                const now = Date.now();
                if (now > this.gameState.timeStopEndTime && now > this.gameState.timeSlowEndTime) {
                    this.gameState.timeSlowEffect = 1;
                } else if (now > this.gameState.timeStopEndTime && now < this.gameState.timeSlowEndTime) {
                    this.gameState.timeSlowEffect = 0.5;
                } else if (now < this.gameState.timeStopEndTime) {
                    this.gameState.timeSlowEffect = 0;
                } else if (now < this.gameState.timeSlowEndTime) {
                    this.gameState.timeSlowEffect = 0.5;
                }
                
                // ëª¨ë°”ì¼ í„°ì¹˜ ì»¨íŠ¸ë¡¤ ì²˜ë¦¬
                if (this.mobileMode && this.gameState.gameStatus === 'playing') {
                    // ë°œì‚¬ ë²„íŠ¼ í„°ì¹˜ ì²˜ë¦¬
                    if (this.touchControls.fireButton.pressed) {
                        this.shoot();
                        console.log('Fire button pressed'); // ë””ë²„ê¹…ìš©
                    }
                }
                
                // 1. ìƒíƒœ ì—…ë°ì´íŠ¸
                this.updateCharacter(this.gameState.player);
                // í”Œë ˆì´ì–´2 ì—…ë°ì´íŠ¸ (ë©€í‹°í”Œë ˆì´ ëª¨ë“œì¼ ë•Œë§Œ)
                if (this.gameState.player2 && this.gameState.multiplayerMode) {
                    this.updateCharacter(this.gameState.player2);
                    // í”Œë ˆì´ì–´2 ìë™ ë°œì‚¬ (í•˜ì´ë¸Œë¦¬ë“œ ëª¨ë“œì—ì„œë§Œ)
                    if (this.gameState.multiplayerMode === 'hybrid' && !this.gameState.player2Dead) {
                        const now = Date.now();
                        if (now - this.gameState.player2.lastShot > 300) { // 300ms ê°„ê²©ìœ¼ë¡œ ìë™ ë°œì‚¬
                            this.shootPlayer2();
                        }
                    }
                }
                this.gameState.enemies.forEach(e => this.updateCharacter(e));
                this.gameState.allies.forEach(a => this.updateCharacter(a));
                
                // ì˜¨ë¼ì¸ í˜‘ë™ ë™ê¸°í™” ì²˜ë¦¬ (ë°©ì¥ë§Œ)
                if (this.gameState.isHost) {
                    if (this.checkCollisions) this.checkCollisions();
                    if (this.processEffects) this.processEffects();
                }
                
                // 2. ì›¨ì´ë¸Œ ì™„ë£Œ ì²´í¬
                this.checkWaveComplete();
                // 3. ë Œë”ë§
                this.render();
                // 4. ë‹¤ìŒ í”„ë ˆì„ ì˜ˆì•½
                if (this.gameState.gameStatus === 'playing' || this.gameState.gameStatus === 'wave-complete') {
                    requestAnimationFrame(this.gameLoop);
                }
            }

            // 1. Add addScore method to GlassCombatArena
            addScore = (amount) => {
                this.gameState.score += amount;
                this.updateHUD();
                // í…ŒìŠ¤íŒ… ì¡´ì—ì„œëŠ” ë³´ìƒ ì„ íƒ ì•ˆí•¨
                if (this.gameMode === 'testzone') return;
                
                while (this.nextMilestoneIndex < this.scoreMilestones.length && this.gameState.score >= this.scoreMilestones[this.nextMilestoneIndex]) {
                    this.pauseGameForReward();
                    this.nextMilestoneIndex++;
                }
            };

            pauseGameForReward = () => {
                this.gameState.gameStatus = 'reward-selection';
                this.showRewardSelection('score');
            };

            updateShopList = () => {
                const shopList = document.getElementById('shopList');
                shopList.innerHTML = '';
                this.SHOP_ITEMS.forEach(item => {
                    // ê°€ê²© ê³„ì‚°: êµ¬ë§¤ íšŸìˆ˜ì— ë”°ë¼ ê°€ê²© ì¦ê°€ (20%ì”© ì¦ê°€)
                    const currentPrice = Math.floor(item.basePrice * (1 + item.purchaseCount * 0.2) * 2);
                    const affordable = this.gameState.score >= currentPrice;
                    const itemDiv = document.createElement('div');
                    itemDiv.style.display = 'flex';
                    itemDiv.style.justifyContent = 'space-between';
                    itemDiv.style.alignItems = 'center';
                    itemDiv.style.margin = '10px 0';
                    itemDiv.style.padding = '10px 0';
                    itemDiv.style.borderBottom = '1px solid rgba(255,255,255,0.15)';
                    itemDiv.style.color = '#fff';
                    const label = document.createElement('span');
                    label.textContent = `${item.text} (êµ¬ë§¤: ${item.purchaseCount}íšŒ)`;
                    const price = document.createElement('span');
                    price.textContent = `${currentPrice}ì `;
                    price.style.marginLeft = '16px';
                    price.style.color = affordable ? '#ffe066' : '#aaa';
                    price.style.fontWeight = 'normal';
                    const buyBtn = document.createElement('button');
                    buyBtn.textContent = affordable ? 'êµ¬ë§¤' : 'êµ¬ë§¤ë¶ˆê°€';
                    buyBtn.disabled = !affordable;
                    buyBtn.style.marginLeft = '18px';
                    buyBtn.style.background = affordable ? '#ffe066' : '#888';
                    buyBtn.style.color = '#222';
                    buyBtn.style.fontWeight = 'bold';
                    buyBtn.style.border = 'none';
                    buyBtn.style.borderRadius = '8px';
                    buyBtn.style.padding = '6px 18px';
                    buyBtn.style.cursor = affordable ? 'pointer' : 'not-allowed';
                    buyBtn.onclick = () => {
                        if (this.gameState.score >= currentPrice) {
                            this.gameState.score -= currentPrice;
                            item.purchaseCount++;
                            this.applyReward(item.type, item.value);
                            this.updateHUD();
                            this.updateShopList();
                        }
                    };
                    itemDiv.appendChild(label);
                    itemDiv.appendChild(price);
                    itemDiv.appendChild(buyBtn);
                    shopList.appendChild(itemDiv);
                });
            };

            // ë©”ì¸ ë©”ë‰´ë¡œ ëŒì•„ê°€ê¸°
            returnToMainMenu = () => {
                this.canvas.style.filter = 'blur(10px)';
                document.querySelector('.hud').style.display = 'none';
                document.getElementById('testZonePopup').style.display = 'none';
                document.getElementById('testZoneHUDButton').style.display = 'none';
                document.getElementById('introScreen').style.display = 'flex';
                this.gameState.gameStatus = 'start';
            }

            // ì  ë„ê° í‘œì‹œ
            showEnemyDex = () => {
                document.getElementById('enemyDexScreen').style.display = 'flex';
                this.updateEnemyDex();
            }

            // ì  ë„ê° ìˆ¨ê¹€
            hideEnemyDex = () => {
                document.getElementById('enemyDexScreen').style.display = 'none';
            }

            // ì  ë„ê° ì—…ë°ì´íŠ¸
            updateEnemyDex = () => {
                const enemyList = document.getElementById('enemyDexList');
                const enemyDetail = document.getElementById('enemyDexDetail');
                
                enemyList.innerHTML = '';
                enemyDetail.innerHTML = '';
                
                // ì  ëª©ë¡ ìƒì„±
                Object.entries(this.ENEMY_TYPES).forEach(([type, data]) => {
                    const enemyDiv = document.createElement('div');
                    enemyDiv.style.display = 'flex';
                    enemyDiv.style.alignItems = 'center';
                    enemyDiv.style.padding = '12px 16px';
                    enemyDiv.style.borderBottom = '1px solid rgba(255,255,255,0.1)';
                    enemyDiv.style.cursor = 'pointer';
                    enemyDiv.style.color = '#fff';
                    enemyDiv.style.fontSize = '14px';
                    enemyDiv.style.transition = 'background 0.2s';
                    
                    // ë³´ìŠ¤ì¸ì§€ ì¼ë°˜ ì ì¸ì§€ êµ¬ë¶„
                    const isBoss = type.startsWith('boss');
                    const category = isBoss ? 'ë³´ìŠ¤' : 'ì¼ë°˜';
                    const categoryColor = isBoss ? '#ff6b6b' : '#4ade80';
                    
                    enemyDiv.innerHTML = `
                        <div style="display:flex; align-items:center; gap:12px; width:100%;">
                            <div style="width:20px; height:20px; background:${data.color}; border-radius:50%;"></div>
                            <div style="flex:1;">
                                <div style="font-weight:bold;">${data.name}</div>
                                <div style="font-size:12px; color:${categoryColor};">${category}</div>
                            </div>
                        </div>
                    `;
                    
                    enemyDiv.onmouseover = () => {
                        enemyDiv.style.background = 'rgba(255,255,255,0.1)';
                    };
                    
                    enemyDiv.onmouseout = () => {
                        enemyDiv.style.background = 'transparent';
                    };
                    
                    enemyDiv.onclick = () => {
                        this.showEnemyDetail(type, data);
                    };
                    
                    enemyList.appendChild(enemyDiv);
                });
                
                // ì²« ë²ˆì§¸ ì  ì„ íƒ
                const firstEnemy = Object.entries(this.ENEMY_TYPES)[0];
                if (firstEnemy) {
                    this.showEnemyDetail(firstEnemy[0], firstEnemy[1]);
                }
            }

            // ì  ìƒì„¸ ì •ë³´ í‘œì‹œ
            showEnemyDetail = (type, data) => {
                const enemyDetail = document.getElementById('enemyDexDetail');
                
                const isBoss = type.startsWith('boss');
                const category = isBoss ? 'ë³´ìŠ¤' : 'ì¼ë°˜';
                const categoryColor = isBoss ? '#ff6b6b' : '#4ade80';
                
                enemyDetail.innerHTML = `
                    <div style="text-align:center; width:100%;">
                        <h2 style="color:#fff; margin-bottom:8px;">${data.name}</h2>
                        <div style="color:${categoryColor}; margin-bottom:20px; font-size:14px;">${category}</div>
                        
                        <div style="width:100px; height:100px; background:${data.color}; border-radius:20px; margin:0 auto 20px; display:flex; align-items:center; justify-content:center; font-size:32px; position:relative; box-shadow:0 4px 16px rgba(0,0,0,0.3);">
                            <div style="position:absolute; top:15px; left:50%; transform:translateX(-50%); font-size:16px;">:D</div>
                            ${this.getEnemyEmoji(type)}
                        </div>
                        
                        <div style="background:rgba(255,255,255,0.1); border-radius:8px; padding:16px; margin-bottom:16px;">
                            <h3 style="color:#fff; margin-bottom:12px; font-size:16px;">ê¸°ë³¸ ì •ë³´</h3>
                            <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px; color:#fff; font-size:14px;">
                                <div>ì²´ë ¥: ${data.health}</div>
                                <div>ì†ë„: ${data.speed}</div>
                                <div>ê³µê²©ë ¥: ${data.damage}</div>
                                <div>í¬ê¸°: ${data.size}</div>
                                <div>ë°œì‚¬ ê°„ê²©: ${data.shootInterval}ms</div>
                                <div>ì ìˆ˜: ${data.points}</div>
                            </div>
                        </div>
                        
                        <div style="background:rgba(255,255,255,0.1); border-radius:8px; padding:16px; margin-bottom:16px;">
                            <h3 style="color:#fff; margin-bottom:12px; font-size:16px;">ì„¤ëª…</h3>
                            <p style="color:#fff; font-size:14px; line-height:1.5;">${data.description || this.getEnemyDescription(type) || 'ì´ ì ì— ëŒ€í•œ ìƒì„¸í•œ ì„¤ëª…ì´ ì—†ìŠµë‹ˆë‹¤.'}</p>
                        </div>
                        
                        <div style="background:rgba(255,255,255,0.1); border-radius:8px; padding:16px; margin-bottom:16px;">
                            <h3 style="color:#fff; margin-bottom:12px; font-size:16px;">ì „íˆ¬ ì •ë³´</h3>
                            <div style="color:#fff; font-size:14px; line-height:1.6;">
                                <div style="margin-bottom:8px;"><strong>ë‚œì´ë„:</strong> ${data.dexInfo ? data.dexInfo.difficulty : this.getEnemyDifficulty(type, data)}</div>
                                <div style="margin-bottom:8px;"><strong>ëŠ¥ë ¥:</strong> ${data.dexInfo ? data.dexInfo.abilities.join(', ') : this.getEnemyAbilities(type, data)}</div>
                                <div style="margin-bottom:8px;"><strong>ì „ëµ:</strong> ${data.dexInfo ? data.dexInfo.strategy : this.getEnemyStrategy(type, data)}</div>
                                <div><strong>ì•½ì :</strong> ${data.dexInfo ? data.dexInfo.weakness : this.getEnemyWeakness(type, data)}</div>
                            </div>
                        </div>
                    </div>
                `;
            }

            // ì  ì„¤ëª… ë°˜í™˜
            getEnemyDescription = (type, data) => {
                const descriptions = {
                    'basic': 'ê°€ì¥ ê¸°ë³¸ì ì¸ ì . íŠ¹ë³„í•œ ëŠ¥ë ¥ì€ ì—†ì§€ë§Œ ê· í˜•ì¡íŒ ìŠ¤íƒ¯ì„ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤.',
                    'fast': 'ë¹ ë¥¸ ì†ë„ë¡œ ì›€ì§ì´ë©° ìì£¼ ë°œì‚¬í•˜ëŠ” ì . ì²´ë ¥ì€ ë‚®ì§€ë§Œ íšŒí”¼í•˜ê¸° ì–´ë ¤ìš¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
                    'tank': 'ë†’ì€ ì²´ë ¥ê³¼ ê³µê²©ë ¥ì„ ê°€ì§„ ì¤‘ì¥ê°‘ ì . ëŠë¦¬ì§€ë§Œ ê°•ë ¥í•œ ê³µê²©ì„ í•©ë‹ˆë‹¤.',
                    'sniper': 'ë†’ì€ ê³µê²©ë ¥ê³¼ ê¸´ ì‚¬ê±°ë¦¬ë¥¼ ê°€ì§„ ì €ê²© ì . ë°œì‚¬ ê°„ê²©ì´ ê¸¸ì§€ë§Œ í•œ ë²ˆ ë§ìœ¼ë©´ í° í”¼í•´ë¥¼ ì…ìŠµë‹ˆë‹¤.',
                    'bomber': 'ê°•ë ¥í•œ í­ë°œ ê³µê²©ì„ í•˜ëŠ” ì . ì²´ë ¥ì€ ë³´í†µì´ì§€ë§Œ ê³µê²©ë ¥ì´ ë†’ìŠµë‹ˆë‹¤.',
                    'guardian': 'ë§¤ìš° ë†’ì€ ì²´ë ¥ê³¼ ê°•ë ¥í•œ ê³µê²©ë ¥ì„ ê°€ì§„ ì •ì˜ˆ ì . ì²˜ì¹˜í•˜ê¸° ì–´ë µì§€ë§Œ ë†’ì€ ì ìˆ˜ë¥¼ ì œê³µí•©ë‹ˆë‹¤.',
                    'assassin': 'ë§¤ìš° ë¹ ë¥¸ ì†ë„ë¡œ ì›€ì§ì´ë©° ìì£¼ ê³µê²©í•˜ëŠ” ì . ì²´ë ¥ì€ ë‚®ì§€ë§Œ íšŒí”¼í•˜ê¸° ë§¤ìš° ì–´ë µìŠµë‹ˆë‹¤.',
                    'heavy': 'ë†’ì€ ì²´ë ¥ê³¼ ê°•ë ¥í•œ ê³µê²©ë ¥ì„ ê°€ì§„ ì¤‘ì¥ê°‘ ì . ë§¤ìš° ëŠë¦¬ì§€ë§Œ í•œ ë²ˆ ë§ìœ¼ë©´ í° í”¼í•´ë¥¼ ì…ìŠµë‹ˆë‹¤.',
                    'ghost': 'ìœ ë ¹ ëŠ¥ë ¥ì„ ê°€ì§„ ì . íˆ¬ëª…í•´ì§€ê±°ë‚˜ íŠ¹ìˆ˜í•œ ê³µê²©ì„ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
                    'medic': 'ë‹¤ë¥¸ ì ë“¤ì„ ì¹˜ë£Œí•˜ëŠ” ëŠ¥ë ¥ì„ ê°€ì§„ ì . ì§ì ‘ ê³µê²©ë ¥ì€ ì—†ì§€ë§Œ ë‹¤ë¥¸ ì ë“¤ì„ ê°•í™”ì‹œí‚µë‹ˆë‹¤.',
                    'summoner': 'ë‹¤ë¥¸ ì ë“¤ì„ ì†Œí™˜í•˜ëŠ” ëŠ¥ë ¥ì„ ê°€ì§„ ì . ì§ì ‘ ê³µê²©ë ¥ì€ ë‚®ì§€ë§Œ ì†Œí™˜ëœ ì ë“¤ì´ ìœ„í—˜í•©ë‹ˆë‹¤.',
                    'jumper': 'ì í”„ ëŠ¥ë ¥ì„ ê°€ì§„ ì . ê°‘ìê¸° ì í”„í•˜ì—¬ ì˜ˆìƒì¹˜ ëª»í•œ ìœ„ì¹˜ì—ì„œ ê³µê²©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
                    'shielded': 'ë°©íŒ¨ë¥¼ ê°€ì§„ ì . íŠ¹ì • ë°©í–¥ì—ì„œì˜ ê³µê²©ì„ ë§‰ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
                    'teleporter': 'ìˆœê°„ì´ë™ ëŠ¥ë ¥ì„ ê°€ì§„ ì . ê°‘ìê¸° ì‚¬ë¼ì¡Œë‹¤ê°€ ë‹¤ë¥¸ ê³³ì—ì„œ ë‚˜íƒ€ë‚  ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
                    'drone': 'ë§¤ìš° ë¹ ë¥¸ ì†ë„ë¡œ ì›€ì§ì´ëŠ” ë“œë¡ . ì²´ë ¥ì€ ë‚®ì§€ë§Œ íšŒí”¼í•˜ê¸° ë§¤ìš° ì–´ë µìŠµë‹ˆë‹¤.',
                    'spitter': 'ìŠ¬ë¼ì„ ëŠ¥ë ¥ì„ ê°€ì§„ ì . ëŠë ¤ì§€ëŠ” íš¨ê³¼ë¥¼ ê°€ì§„ ê³µê²©ì„ í•©ë‹ˆë‹¤.',
                    'berserker': 'ì²´ë ¥ì´ ë‚®ì•„ì§€ë©´ ê´‘ë¶„ ìƒíƒœê°€ ë˜ì–´ ì†ë„ì™€ ê³µê²©ë ¥ì´ ì¦ê°€í•˜ëŠ” ì .',
                    'mirror': 'í”Œë ˆì´ì–´ì˜ ì›€ì§ì„ì„ ë”°ë¼í•˜ëŠ” ë¯¸ëŸ¬ ì . ì˜ˆì¸¡í•˜ê¸° ì–´ë ¤ìš´ íŒ¨í„´ì„ ë³´ì…ë‹ˆë‹¤.',
                    'leech': 'í”Œë ˆì´ì–´ì—ê²Œ ë‹¿ìœ¼ë©´ ì²´ë ¥ì„ í¡ìˆ˜í•˜ëŠ” ì . ê·¼ì ‘ ê³µê²©ì— ì£¼ì˜í•´ì•¼ í•©ë‹ˆë‹¤.',
                    'mine': 'í”Œë ˆì´ì–´ê°€ ê°€ê¹Œì´ ì˜¤ë©´ í­ë°œí•˜ëŠ” ì§€ë¢° ì . ì ‘ê·¼í•˜ì§€ ë§ê³  ì›ê±°ë¦¬ì—ì„œ ì²˜ì¹˜í•˜ì„¸ìš”.',
                    'freezer': 'í”Œë ˆì´ì–´ë¥¼ ë§ì¶”ë©´ ë¹™ê²°ì‹œí‚¤ëŠ” ì . ë¹™ê²° ìƒíƒœì—ì„œëŠ” ì›€ì§ì¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.',
                    'reflector': 'í”Œë ˆì´ì–´ì˜ íƒ„í™˜ì„ ë°˜ì‚¬í•˜ëŠ” ì . ë°˜ì‚¬ëœ íƒ„í™˜ì— ì£¼ì˜í•˜ì„¸ìš”.',
                    'healer': 'ì£¼ë³€ì˜ ë‹¤ë¥¸ ì ë“¤ì„ ì¹˜ë£Œí•˜ëŠ” ì . ìš°ì„  ì²˜ì¹˜í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤.',
                    'portal': 'ìˆœê°„ì´ë™ ëŠ¥ë ¥ì„ ê°€ì§„ ì . ê°‘ìê¸° í”Œë ˆì´ì–´ ê·¼ì²˜ë¡œ ì´ë™í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
                    'exploder': 'ì‚¬ë§ ì‹œ í­ë°œí•˜ëŠ” ì . ì£½ì¼ ë•Œ ê±°ë¦¬ë¥¼ ë‘ê³  ì²˜ì¹˜í•˜ì„¸ìš”.',
                    'magnet': 'ì•„ì´í…œì„ ëŒì–´ë‹¹ê¸°ëŠ” ìì„ ëŠ¥ë ¥ì„ ê°€ì§„ ì . ì•„ì´í…œ ìˆ˜ì§‘ì— ë°©í•´ê°€ ë©ë‹ˆë‹¤.',
                    'curse': 'í”Œë ˆì´ì–´ì—ê²Œ ì €ì£¼ë¥¼ ê±°ëŠ” ì . ì €ì£¼ ìƒíƒœì—ì„œëŠ” ë‹¤ì–‘í•œ ë””ë²„í”„ë¥¼ ë°›ìŠµë‹ˆë‹¤.',
                    'floater': 'ê³µì¤‘ì„ ììœ ë¡­ê²Œ ì›€ì§ì´ëŠ” ì . ì§€ìƒ ì¥ì• ë¬¼ì˜ ì˜í–¥ì„ ë°›ì§€ ì•ŠìŠµë‹ˆë‹¤.',
                    'phaser': 'ì£¼ê¸°ì ìœ¼ë¡œ í˜ì´ì¦ˆ ìƒíƒœê°€ ë˜ì–´ ë¬´ì ì´ ë˜ëŠ” ì . íƒ€ì´ë°ì„ ë…¸ë ¤ ê³µê²©í•˜ì„¸ìš”.',
                    'juggernaut': 'ê³µê²©ë ¥ì€ ì•½í•˜ì§€ë§Œ ì—„ì²­ë‚œ ì²´ë ¥ì„ ìë‘í•˜ëŠ” ê±°ëŒ€ ì . ì˜¤ë«ë™ì•ˆ ì‹¸ì›Œì•¼ í•©ë‹ˆë‹¤.',
                    'skyblaster': 'í•˜ëŠ˜ì„ ë‚ ë©° í•œ ë²ˆì— ì—¬ëŸ¬ ë°œì˜ ì´ì•Œì„ í¼ëœ¨ë¦¬ëŠ” íƒ„ë§‰ ì . íšŒí”¼ê°€ ì–´ë µìŠµë‹ˆë‹¤.',
                    'boss_alpha': 'ë¯¸ë‹ˆì–¸ ì†Œí™˜, ì—°ì† ëŒì§„, ê´‘ì—­ ì¶©ê²©íŒŒ ëŠ¥ë ¥ì„ ê°€ì§„ ê°•ë ¥í•œ ë³´ìŠ¤.',
                    'boss_beta': 'ì‰´ë“œ, íƒ„ë§‰, ì²´ë ¥ íšŒë³µ ëŠ¥ë ¥ì„ ê°€ì§„ ë°©ì–´í˜• ë³´ìŠ¤.',
                    'boss_gamma': 'ìˆœê°„ì´ë™, ë ˆì´ì €, ì†ë„ ë²„í”„ ëŠ¥ë ¥ì„ ê°€ì§„ ê³µê²©í˜• ë³´ìŠ¤.',
                    'boss_delta': 'ë¸”ë™í™€, ê´‘ì—­ í­ë°œ, í”Œë ˆì´ì–´ ë‘”í™” ëŠ¥ë ¥ì„ ê°€ì§„ ë§ˆë²•í˜• ë³´ìŠ¤.',
                    'boss_epsilon': 'ë¶„ì‹ , íƒ„í™˜ ë°˜ì‚¬, ì²´ë ¥ í¡ìˆ˜ ëŠ¥ë ¥ì„ ê°€ì§„ êµí™œí•œ ë³´ìŠ¤.',
                    'boss_zeta': 'ì‹œê°„ ì™œê³¡, ì—°ë°œ ì‚¬ê²©, ëœë¤ ì´ë™ ëŠ¥ë ¥ì„ ê°€ì§„ ì‹œê°„ ì¡°ì‘ ë³´ìŠ¤.',
                    'boss_eta': 'ë ˆì´ì €, ì—°ì† ì í”„, ë°©ì–´ë ¥ ì¦ê°€ ëŠ¥ë ¥ì„ ê°€ì§„ ì „íˆ¬í˜• ë³´ìŠ¤.',
                    'boss_theta': 'ë°œì‚¬ì²´ ë°˜ì‚¬, ë„íƒ„, ìœ„ì¹˜ ì¶”ì  ëŠ¥ë ¥ì„ ê°€ì§„ ë°˜ì‚¬í˜• ë³´ìŠ¤.'
                };
                
                return descriptions[type] || data.description || 'ì´ ì ì— ëŒ€í•œ ìƒì„¸í•œ ì„¤ëª…ì´ ì—†ìŠµë‹ˆë‹¤.';
            }

            // ì  ë‚œì´ë„ ë°˜í™˜
            getEnemyDifficulty = (type, data) => {
                const difficulties = {
                    'shielded': 'â˜…â˜…â˜…â˜†â˜†',
                    'teleporter': 'â˜…â˜…â˜…â˜†â˜†',
                    'drone': 'â˜…â˜…â˜…â˜…â˜†',
                    'spitter': 'â˜…â˜…â˜†â˜†â˜†',
                    'berserker': 'â˜…â˜…â˜…â˜†â˜†',
                    'mirror': 'â˜…â˜…â˜†â˜†â˜†',
                    'leech': 'â˜…â˜…â˜†â˜†â˜†',
                    'mine': 'â˜…â˜…â˜†â˜†â˜†',
                    'freezer': 'â˜…â˜…â˜†â˜†â˜†',
                    'reflector': 'â˜…â˜…â˜…â˜†â˜†',
                    'healer': 'â˜…â˜…â˜†â˜†â˜†',
                    'portal': 'â˜…â˜…â˜…â˜†â˜†',
                    'exploder': 'â˜…â˜…â˜†â˜†â˜†',
                    'magnet': 'â˜…â˜…â˜†â˜†â˜†',
                    'curse': 'â˜…â˜…â˜†â˜†â˜†',
                    'floater': 'â˜…â˜…â˜†â˜†â˜†',
                    'phaser': 'â˜…â˜…â˜…â˜†â˜†',
                    'juggernaut': 'â˜…â˜…â˜…â˜†â˜†',
                    'skyblaster': 'â˜…â˜…â˜…â˜†â˜†',
                    'boss_alpha': 'â˜…â˜…â˜…â˜…â˜†',
                    'boss_beta': 'â˜…â˜…â˜…â˜…â˜†',
                    'boss_gamma': 'â˜…â˜…â˜…â˜…â˜†',
                    'boss_delta': 'â˜…â˜…â˜…â˜…â˜…',
                    'boss_epsilon': 'â˜…â˜…â˜…â˜…â˜†',
                    'boss_zeta': 'â˜…â˜…â˜…â˜…â˜†',
                    'boss_eta': 'â˜…â˜…â˜…â˜…â˜…',
                    'boss_theta': 'â˜…â˜…â˜…â˜…â˜†'
                };
                return difficulties[type] || 'â˜…â˜…â˜†â˜†â˜†';
            }

            // ì  ëŠ¥ë ¥ ë°˜í™˜
            getEnemyAbilities = (type, data) => {
                const abilities = {
                    'shielded': ['ë°©íŒ¨', 'ê³µê²© ë°©ì–´'],
                    'teleporter': ['ìˆœê°„ì´ë™', 'ì˜ˆì¸¡ ë¶ˆê°€ëŠ¥í•œ ì´ë™'],
                    'drone': ['ë§¤ìš° ë¹ ë¥¸ ì´ë™', 'ë¹ ë¥¸ ë°œì‚¬'],
                    'spitter': ['ëŠë ¤ì§€ëŠ” ê³µê²©', 'ë””ë²„í”„'],
                    'berserker': ['ê´‘ë¶„', 'ì†ë„/ê³µê²©ë ¥ ì¦ê°€'],
                    'mirror': ['í”Œë ˆì´ì–´ ëª¨ë°©', 'ì˜ˆì¸¡ ë¶ˆê°€ëŠ¥í•œ íŒ¨í„´'],
                    'leech': ['ì²´ë ¥ í¡ìˆ˜', 'ê·¼ì ‘ ê³µê²©'],
                    'mine': ['ê·¼ì ‘ í­ë°œ', 'ë†’ì€ ë°ë¯¸ì§€'],
                    'freezer': ['ë¹™ê²°', 'ì´ë™ ë¶ˆê°€'],
                    'reflector': ['íƒ„í™˜ ë°˜ì‚¬', 'ë°˜ê²©'],
                    'healer': ['ì  ì¹˜ë£Œ', 'ì§€ì†ì ì¸ ìœ„í˜‘'],
                    'portal': ['ìˆœê°„ì´ë™', 'ê·¼ì ‘ ê³µê²©'],
                    'exploder': ['ì‚¬ë§ í­ë°œ', 'ë²”ìœ„ ë°ë¯¸ì§€'],
                    'magnet': ['ì•„ì´í…œ í¡ìˆ˜', 'ìì„ íš¨ê³¼'],
                    'curse': ['ì €ì£¼', 'ë””ë²„í”„'],
                    'floater': ['ê³µì¤‘ ì´ë™', 'ììœ ë¡œìš´ ì›€ì§ì„'],
                    'phaser': ['í˜ì´ì¦ˆ', 'ì£¼ê¸°ì  ë¬´ì '],
                    'juggernaut': ['ë†’ì€ ì²´ë ¥', 'ì§€ì† ì „íˆ¬'],
                    'skyblaster': ['íƒ„ë§‰', 'ë‹¤ì¤‘ ë°œì‚¬'],
                    'boss_alpha': ['ë¯¸ë‹ˆì–¸ ì†Œí™˜', 'ì—°ì† ëŒì§„', 'ê´‘ì—­ ì¶©ê²©íŒŒ'],
                    'boss_beta': ['ì‰´ë“œ', 'íƒ„ë§‰', 'ì²´ë ¥ íšŒë³µ'],
                    'boss_gamma': ['ìˆœê°„ì´ë™', 'ë ˆì´ì €', 'ì†ë„ ë²„í”„'],
                    'boss_delta': ['ë¸”ë™í™€', 'ê´‘ì—­ í­ë°œ', 'í”Œë ˆì´ì–´ ë‘”í™”'],
                    'boss_epsilon': ['ë¶„ì‹ ', 'íƒ„í™˜ ë°˜ì‚¬', 'ì²´ë ¥ í¡ìˆ˜'],
                    'boss_zeta': ['ì‹œê°„ ì™œê³¡', 'ì—°ë°œ ì‚¬ê²©', 'ëœë¤ ì´ë™'],
                    'boss_eta': ['ë ˆì´ì €', 'ì—°ì† ì í”„', 'ë°©ì–´ë ¥ ì¦ê°€'],
                    'boss_theta': ['ë°œì‚¬ì²´ ë°˜ì‚¬', 'ë„íƒ„', 'ìœ„ì¹˜ ì¶”ì ']
                };
                return abilities[type] ? abilities[type].join(', ') : 'ê¸°ë³¸ ê³µê²©';
            }

            // ì  ì „ëµ ë°˜í™˜
            getEnemyStrategy = (type, data) => {
                const strategies = {
                    'shielded': 'ë°©íŒ¨ë¡œ íŠ¹ì • ë°©í–¥ì˜ ê³µê²©ì„ ë§‰ìŠµë‹ˆë‹¤. ë°©íŒ¨ê°€ ì—†ëŠ” ë°©í–¥ì—ì„œ ê³µê²©í•˜ì„¸ìš”.',
                    'teleporter': 'ìˆœê°„ì´ë™ìœ¼ë¡œ ì˜ˆìƒì¹˜ ëª»í•œ ìœ„ì¹˜ì—ì„œ ê³µê²©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì£¼ë³€ì„ í•­ìƒ ì£¼ì˜í•˜ì„¸ìš”.',
                    'drone': 'ì†ë„ê°€ ë§¤ìš° ë¹ ë¥´ê³  ë°œì‚¬ ê°„ê²©ì´ ì§§ì•„ ê°€ì¥ ìœ„í—˜í•œ ì  ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤. ìš°ì„  ì²˜ì¹˜í•˜ëŠ” ê²ƒì´ í•„ìˆ˜ì…ë‹ˆë‹¤.',
                    'spitter': 'ê³µê²©ì— ë§ìœ¼ë©´ ëŠë ¤ì§€ëŠ” íš¨ê³¼ë¥¼ ë°›ìŠµë‹ˆë‹¤. ìš°ì„  ì²˜ì¹˜í•˜ê±°ë‚˜ ê±°ë¦¬ë¥¼ ë‘ê³  ì‹¸ìš°ì„¸ìš”.',
                    'berserker': 'ì²´ë ¥ì´ 30% ì´í•˜ë¡œ ë–¨ì–´ì§€ë©´ ê´‘ë¶„ ìƒíƒœê°€ ë˜ì–´ ìœ„í—˜í•´ì§‘ë‹ˆë‹¤. ë¹ ë¥´ê²Œ ì²˜ì¹˜í•˜ì„¸ìš”.',
                    'mirror': 'í”Œë ˆì´ì–´ì˜ ì›€ì§ì„ì„ ë”°ë¼í•˜ë¯€ë¡œ ì˜ˆì¸¡í•˜ê¸° ì–´ë ¤ìš´ íŒ¨í„´ì„ ë³´ì…ë‹ˆë‹¤. íŒ¨í„´ì„ íŒŒì•…í•˜ì„¸ìš”.',
                    'leech': 'í”Œë ˆì´ì–´ì—ê²Œ ë‹¿ìœ¼ë©´ ì²´ë ¥ì„ í¡ìˆ˜í•©ë‹ˆë‹¤. ê·¼ì ‘ ê³µê²©ì— ì£¼ì˜í•˜ê³  ì›ê±°ë¦¬ì—ì„œ ì²˜ì¹˜í•˜ì„¸ìš”.',
                    'mine': 'í”Œë ˆì´ì–´ê°€ ê°€ê¹Œì´ ì˜¤ë©´ í­ë°œí•©ë‹ˆë‹¤. ì ‘ê·¼í•˜ì§€ ë§ê³  ì›ê±°ë¦¬ì—ì„œ ì²˜ì¹˜í•˜ì„¸ìš”.',
                    'freezer': 'í”Œë ˆì´ì–´ë¥¼ ë§ì¶”ë©´ ë¹™ê²°ì‹œí‚µë‹ˆë‹¤. ë¹™ê²° ìƒíƒœì—ì„œëŠ” ì›€ì§ì¼ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ ì£¼ì˜í•˜ì„¸ìš”.',
                    'reflector': 'í”Œë ˆì´ì–´ì˜ íƒ„í™˜ì„ ë°˜ì‚¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë°˜ì‚¬ëœ íƒ„í™˜ì— ì£¼ì˜í•˜ì„¸ìš”.',
                    'healer': 'ì£¼ë³€ì˜ ë‹¤ë¥¸ ì ë“¤ì„ ì¹˜ë£Œí•©ë‹ˆë‹¤. ìš°ì„  ì²˜ì¹˜í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤.',
                    'portal': 'ê°‘ìê¸° í”Œë ˆì´ì–´ ê·¼ì²˜ë¡œ ìˆœê°„ì´ë™í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì£¼ë³€ì„ í•­ìƒ ì£¼ì˜í•˜ì„¸ìš”.',
                    'exploder': 'ì‚¬ë§ ì‹œ í­ë°œí•©ë‹ˆë‹¤. ì£½ì¼ ë•Œ ê±°ë¦¬ë¥¼ ë‘ê³  ì²˜ì¹˜í•˜ì„¸ìš”.',
                    'magnet': 'ì•„ì´í…œì„ ëŒì–´ë‹¹ê²¨ ì•„ì´í…œ ìˆ˜ì§‘ì— ë°©í•´ê°€ ë©ë‹ˆë‹¤. ìš°ì„  ì²˜ì¹˜í•˜ì„¸ìš”.',
                    'curse': 'í”Œë ˆì´ì–´ì—ê²Œ ì €ì£¼ë¥¼ ê±¸ì–´ ë‹¤ì–‘í•œ ë””ë²„í”„ë¥¼ ì¤ë‹ˆë‹¤. ì €ì£¼ ìƒíƒœì— ì£¼ì˜í•˜ì„¸ìš”.',
                    'floater': 'ê³µì¤‘ì„ ììœ ë¡­ê²Œ ì›€ì§ì…ë‹ˆë‹¤. ì§€ìƒ ì¥ì• ë¬¼ì˜ ì˜í–¥ì„ ë°›ì§€ ì•ŠìŠµë‹ˆë‹¤.',
                    'phaser': 'ì£¼ê¸°ì ìœ¼ë¡œ í˜ì´ì¦ˆ ìƒíƒœê°€ ë˜ì–´ ë¬´ì ì´ ë©ë‹ˆë‹¤. íƒ€ì´ë°ì„ ë…¸ë ¤ ê³µê²©í•˜ì„¸ìš”.',
                    'juggernaut': 'ì²´ë ¥ì´ ë§¤ìš° ë†’ì•„ ì˜¤ë«ë™ì•ˆ ì‹¸ì›Œì•¼ í•©ë‹ˆë‹¤. ì§€ì†ì ì¸ ê³µê²©ì´ í•„ìš”í•©ë‹ˆë‹¤.',
                    'skyblaster': 'í•œ ë²ˆì— ì—¬ëŸ¬ ë°œì˜ ì´ì•Œì„ í¼ëœ¨ë ¤ íšŒí”¼ê°€ ì–´ë µìŠµë‹ˆë‹¤. íƒ„ë§‰ì— ì£¼ì˜í•˜ì„¸ìš”.',
                    'boss_alpha': 'ë¯¸ë‹ˆì–¸ì„ ì†Œí™˜í•˜ê³  ì—°ì† ëŒì§„ê³¼ ê´‘ì—­ ì¶©ê²©íŒŒë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. íŒ¨í„´ì„ íŒŒì•…í•˜ì„¸ìš”.',
                    'boss_beta': 'ì‰´ë“œë¡œ ë°©ì–´í•˜ê³  íƒ„ë§‰ì„ ë°œì‚¬í•˜ë©° ì²´ë ¥ì„ íšŒë³µí•©ë‹ˆë‹¤. ì‰´ë“œê°€ ì—†ì„ ë•Œ ê³µê²©í•˜ì„¸ìš”.',
                    'boss_gamma': 'ìˆœê°„ì´ë™ê³¼ ë ˆì´ì €, ì†ë„ ë²„í”„ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. ë ˆì´ì €ì— íŠ¹íˆ ì£¼ì˜í•˜ì„¸ìš”.',
                    'boss_delta': 'ë¸”ë™í™€ê³¼ ê´‘ì—­ í­ë°œ, í”Œë ˆì´ì–´ ë‘”í™”ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. ê°€ì¥ ìœ„í—˜í•œ ë³´ìŠ¤ ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤.',
                    'boss_epsilon': 'ë¶„ì‹ ì„ ìƒì„±í•˜ê³  íƒ„í™˜ì„ ë°˜ì‚¬í•˜ë©° ì²´ë ¥ì„ í¡ìˆ˜í•©ë‹ˆë‹¤. êµí™œí•œ ì „ëµì„ ì‚¬ìš©í•©ë‹ˆë‹¤.',
                    'boss_zeta': 'ì‹œê°„ì„ ì™œê³¡í•˜ê³  ì—°ë°œ ì‚¬ê²©ê³¼ ëœë¤ ì´ë™ì„ í•©ë‹ˆë‹¤. ì‹œê°„ ì™œê³¡ì— ì£¼ì˜í•˜ì„¸ìš”.',
                    'boss_eta': 'ë ˆì´ì €ì™€ ì—°ì† ì í”„, ë°©ì–´ë ¥ ì¦ê°€ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. ê°€ì¥ ê°•ë ¥í•œ ë³´ìŠ¤ ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤.',
                    'boss_theta': 'ë°œì‚¬ì²´ë¥¼ ë°˜ì‚¬í•˜ê³  ë„íƒ„ íƒ„í™˜ê³¼ ìœ„ì¹˜ ì¶”ì ì„ ì‚¬ìš©í•©ë‹ˆë‹¤. ë°˜ì‚¬ëœ ë°œì‚¬ì²´ì— ì£¼ì˜í•˜ì„¸ìš”.'
                };
                return strategies[type] || 'ê¸°ë³¸ì ì¸ ì „íˆ¬ íŒ¨í„´ì„ ë³´ì…ë‹ˆë‹¤.';
            }

            // ì  ì•½ì  ë°˜í™˜
            getEnemyWeakness = (type, data) => {
                const weaknesses = {
                    'shielded': 'ì†ë„ê°€ ë§¤ìš° ëŠë¦¬ê³  ë°©íŒ¨ê°€ ëª¨ë“  ë°©í–¥ì„ ë§‰ì§€ ëª»í•¨',
                    'teleporter': 'ì²´ë ¥ì´ ë‚®ê³  ìˆœê°„ì´ë™ í›„ ê³µê²©ê¹Œì§€ ì‹œê°„ì´ í•„ìš”',
                    'drone': 'ì²´ë ¥ì´ ë§¤ìš° ë‚®ì•„ í•œ ë²ˆì˜ ê³µê²©ìœ¼ë¡œ ì²˜ì¹˜ ê°€ëŠ¥',
                    'spitter': 'ì²´ë ¥ì´ ë³´í†µì´ê³  ê¸°ë³¸ ê³µê²©ë ¥ì´ ë‚®ìŒ',
                    'berserker': 'ê´‘ë¶„ ì „ì—ëŠ” ì¼ë°˜ì ì¸ ì ê³¼ ë¹„ìŠ·í•¨',
                    'mirror': 'ì²´ë ¥ì´ ë‚®ê³  ì˜ˆì¸¡ ê°€ëŠ¥í•œ íŒ¨í„´ì´ ìˆìŒ',
                    'leech': 'ì²´ë ¥ì´ ë‚®ê³  ê·¼ì ‘ ê³µê²©ë§Œ ê°€ëŠ¥',
                    'mine': 'ì²´ë ¥ì´ ë§¤ìš° ë‚®ê³  ì ‘ê·¼í•´ì•¼ë§Œ ìœ„í—˜í•¨',
                    'freezer': 'ì²´ë ¥ì´ ë‚®ê³  ê³µê²©ë ¥ì´ ë³´í†µì„',
                    'reflector': 'ì²´ë ¥ì´ ë³´í†µì´ê³  ë°˜ì‚¬ í™•ë¥ ì´ 30%ë¡œ ì œí•œì ',
                    'healer': 'ì§ì ‘ ê³µê²©ë ¥ì´ ì—†ê³  ì²´ë ¥ì´ ë³´í†µì„',
                    'portal': 'ì²´ë ¥ì´ ë‚®ê³  ìˆœê°„ì´ë™ í›„ ê³µê²©ê¹Œì§€ ì‹œê°„ì´ í•„ìš”',
                    'exploder': 'ì²´ë ¥ì´ ë‚®ê³  ì‚¬ë§ ì‹œì—ë§Œ ìœ„í—˜í•¨',
                    'magnet': 'ì²´ë ¥ì´ ë‚®ê³  ì§ì ‘ì ì¸ ê³µê²©ë ¥ì´ ì—†ìŒ',
                    'curse': 'ì²´ë ¥ì´ ë‚®ê³  ê³µê²©ë ¥ì´ ë‚®ìŒ',
                    'floater': 'ì²´ë ¥ì´ ë³´í†µì´ê³  íŠ¹ë³„í•œ ë°©ì–´ ëŠ¥ë ¥ì´ ì—†ìŒ',
                    'phaser': 'í˜ì´ì¦ˆ ìƒíƒœê°€ ì•„ë‹ ë•ŒëŠ” ì¼ë°˜ì ì¸ ì ê³¼ ë¹„ìŠ·í•¨',
                    'juggernaut': 'ê³µê²©ë ¥ì´ ë§¤ìš° ë‚®ê³  ì†ë„ê°€ ëŠë¦¼',
                    'skyblaster': 'ì²´ë ¥ì´ ë³´í†µì´ê³  íƒ„ë§‰ íŒ¨í„´ì´ ì˜ˆì¸¡ ê°€ëŠ¥í•¨',
                    'boss_alpha': 'ì†ë„ê°€ ëŠë¦¬ê³  íŒ¨í„´ì´ ì˜ˆì¸¡ ê°€ëŠ¥í•¨',
                    'boss_beta': 'ì‰´ë“œê°€ ì—†ì„ ë•ŒëŠ” ì¼ë°˜ì ì¸ ë³´ìŠ¤ì™€ ë¹„ìŠ·í•¨',
                    'boss_gamma': 'ì²´ë ¥ì´ ìƒëŒ€ì ìœ¼ë¡œ ë‚®ê³  ë ˆì´ì € ì‚¬ìš© ì‹œ ë¬´ë°©ë¹„',
                    'boss_delta': 'ìŠ¤í‚¬ ì‚¬ìš© í›„ ì¿¨ë‹¤ìš´ ì‹œê°„ì´ ìˆìŒ',
                    'boss_epsilon': 'ë¶„ì‹ ì€ ì²´ë ¥ì´ ë‚®ê³  ë°˜ì‚¬ ìƒíƒœê°€ ì•„ë‹ ë•ŒëŠ” ì¼ë°˜ì ',
                    'boss_zeta': 'ì‹œê°„ ì™œê³¡ ì‚¬ìš© í›„ ì¿¨ë‹¤ìš´ ì‹œê°„ì´ ìˆìŒ',
                    'boss_eta': 'ì†ë„ê°€ ëŠë¦¬ê³  ì í”„ í›„ ì°©ì§€ ì‹œ ë¬´ë°©ë¹„',
                    'boss_theta': 'ë°˜ì‚¬ ìƒíƒœê°€ ì•„ë‹ ë•ŒëŠ” ì¼ë°˜ì ì¸ ë³´ìŠ¤ì™€ ë¹„ìŠ·í•¨'
                };
                return weaknesses[type] || 'íŠ¹ë³„í•œ ì•½ì ì´ ì—†ìŠµë‹ˆë‹¤.';
            }

            // ì  ì´ëª¨ì§€ ë°˜í™˜
            getEnemyEmoji = (type) => {
                const emojiMap = {
                    'boss': 'ğŸ‘‘',
                    'boss_alpha': 'ğŸ¦',
                    'boss_beta': 'ğŸ›¡ï¸',
                    'boss_gamma': 'âš¡',
                    'boss_delta': 'ğŸŒ€',
                    'boss_epsilon': 'ğŸ”„',
                    'boss_zeta': 'â°',
                    'boss_eta': 'ğŸ’¥',
                    'boss_theta': 'ğŸ¯',
                    'basic': 'ğŸ‘¾',
                    'fast': 'ğŸƒ',
                    'tank': 'ğŸ›¡ï¸',
                    'sniper': 'ğŸ¯',
                    'bomber': 'ğŸ’£',
                    'guardian': 'ğŸ›¡ï¸',
                    'assassin': 'ğŸ—¡ï¸',
                    'heavy': 'âš”ï¸',
                    'ghost': 'ğŸ‘»',
                    'medic': 'ğŸ’Š',
                    'summoner': 'ğŸ”®',
                    'jumper': 'ğŸ¦˜',
                    'shielded': 'ğŸ›¡ï¸',
                    'teleporter': 'ğŸŒ€',
                    'drone': 'ğŸš',
                    'spitter': 'ğŸŸ¢',
                    'berserker': 'ğŸ˜¤',
                    'mirror': 'ğŸª',
                    'leech': 'ğŸ©¸',
                    'mine': 'ğŸ’£',
                    'freezer': 'â„ï¸',
                    'reflector': 'ğŸª©',
                    'healer': 'ğŸ’š',
                    'portal': 'ğŸšª',
                    'exploder': 'ğŸ’¥',
                    'magnet': 'ğŸ§²',
                    'curse': 'ğŸ‘¹',
                    'floater': 'ğŸˆ',
                    'phaser': 'âœ¨'
                };
                return emojiMap[type] || 'ğŸ‘¾';
            }

            // í…ŒìŠ¤íŠ¸ ì¡´ ì—…ë°ì´íŠ¸
            updateTestZone = () => {
                const enemySpawnList = document.getElementById('enemySpawnList');
                const bossSpawnList = document.getElementById('bossSpawnList');
                const abilityList = document.getElementById('abilityList');
                
                enemySpawnList.innerHTML = '';
                bossSpawnList.innerHTML = '';
                abilityList.innerHTML = '';
                
                // ì  ì†Œí™˜ ëª©ë¡ ìƒì„±
                Object.entries(this.ENEMY_TYPES).forEach(([type, data]) => {
                    if (!type.startsWith('boss')) {
                        const enemyDiv = document.createElement('div');
                        enemyDiv.style.display = 'flex';
                        enemyDiv.style.justifyContent = 'space-between';
                        enemyDiv.style.alignItems = 'center';
                        enemyDiv.style.margin = '8px 0';
                        enemyDiv.style.padding = '8px';
                        enemyDiv.style.background = 'rgba(255,255,255,0.1)';
                        enemyDiv.style.borderRadius = '6px';
                        enemyDiv.style.color = '#222';
                        
                        const label = document.createElement('span');
                        label.textContent = data.name;
                        label.style.fontSize = '14px';
                        
                        const spawnBtn = document.createElement('button');
                        spawnBtn.textContent = 'ì†Œí™˜';
                        spawnBtn.style.background = '#ff6b6b';
                        spawnBtn.style.color = '#fff';
                        spawnBtn.style.border = 'none';
                        spawnBtn.style.borderRadius = '4px';
                        spawnBtn.style.padding = '4px 12px';
                        spawnBtn.style.cursor = 'pointer';
                        spawnBtn.style.fontSize = '12px';
                        
                        spawnBtn.onclick = () => {
                            const enemy = this.createEnemy(type);
                            enemy.x = Math.random() * (this.canvas.width - 100) + 50;
                            enemy.y = Math.random() * (this.canvas.height - 200) + 50;
                            this.gameState.enemies.push(enemy);
                            this.showMessage(`${data.name} ì†Œí™˜!`, '', 1500);
                        };
                        
                        enemyDiv.appendChild(label);
                        enemyDiv.appendChild(spawnBtn);
                        enemySpawnList.appendChild(enemyDiv);
                    }
                });
                
                // ë³´ìŠ¤ ì†Œí™˜ ëª©ë¡ ìƒì„±
                Object.entries(this.ENEMY_TYPES).forEach(([type, data]) => {
                    if (type.startsWith('boss')) {
                        const bossDiv = document.createElement('div');
                        bossDiv.style.display = 'flex';
                        bossDiv.style.justifyContent = 'space-between';
                        bossDiv.style.alignItems = 'center';
                        bossDiv.style.margin = '8px 0';
                        bossDiv.style.padding = '8px';
                        bossDiv.style.background = 'rgba(255,255,255,0.1)';
                        bossDiv.style.borderRadius = '6px';
                        bossDiv.style.color = '#222';
                        
                        const label = document.createElement('span');
                        label.textContent = data.name;
                        label.style.fontSize = '14px';
                        label.style.fontWeight = 'bold';
                        
                        const spawnBtn = document.createElement('button');
                        spawnBtn.textContent = 'ì†Œí™˜';
                        spawnBtn.style.background = '#dc2626';
                        spawnBtn.style.color = '#fff';
                        spawnBtn.style.border = 'none';
                        spawnBtn.style.borderRadius = '4px';
                        spawnBtn.style.padding = '4px 12px';
                        spawnBtn.style.cursor = 'pointer';
                        spawnBtn.style.fontSize = '12px';
                        
                        spawnBtn.onclick = () => {
                            const boss = this.createBoss(type);
                            boss.x = this.canvas.width / 2;
                            boss.y = this.canvas.height / 2;
                            this.gameState.enemies.push(boss);
                            this.showMessage(`${data.name} ì†Œí™˜!`, 'ê°•ë ¥í•œ ë³´ìŠ¤ê°€ ë‚˜íƒ€ë‚¬ìŠµë‹ˆë‹¤!', 2000);
                        };
                        
                        bossDiv.appendChild(label);
                        bossDiv.appendChild(spawnBtn);
                        bossSpawnList.appendChild(bossDiv);
                    }
                });
                
                // ëŠ¥ë ¥ ë¶€ì—¬ ëª©ë¡ ìƒì„±
                const abilities = [
                    { name: 'ë¬´ì  (5ì´ˆ)', type: 'invincibility', value: 5000 },
                    { name: 'ì‰´ë“œ ê°•í™” (10ì´ˆ)', type: 'shield_boost', value: 10000 },
                    { name: 'ì‹œê°„ ì •ì§€ (3ì´ˆ)', type: 'time_stop', value: 3000 },
                    { name: 'ìì„ íš¨ê³¼ (8ì´ˆ)', type: 'magnet', value: 8000 },
                    { name: 'ì²´ë ¥ ì¬ìƒ (10ì´ˆ)', type: 'health_regen', value: 10000 },
                    { name: 'ì—°ë°œ ëª¨ë“œ (5ì´ˆ)', type: 'rapid', value: 5000 },
                    { name: 'ê´€í†µ ì‚¬ê²©', type: 'piercing_shot', value: 1 },
                    { name: 'í­ë°œ ì‚¬ê²©', type: 'explosive_shot', value: 1 },
                    { name: 'íšŒì „ ì¹¼ë‚ ', type: 'orbiting_knife', value: 1 },
                    { name: 'ë„íƒ„ ì‚¬ê²©', type: 'ricochet_shot', value: 1 },
                    { name: 'ìœ ë„ ì‚¬ê²©', type: 'homing_shot', value: 1 },
                    { name: 'ë¶„ì—´ ì‚¬ê²©', type: 'split_shot', value: 1 },
                    { name: 'ìƒëª…ë ¥ í¡ìˆ˜', type: 'life_steal', value: 0.05 },
                    { name: 'ì¹˜ëª…íƒ€ í™•ë¥ ', type: 'crit_chance', value: 0.05 },
                    { name: 'ì¬ì‚¬ìš© ëŒ€ê¸°ì‹œê°„ ê°ì†Œ', type: 'cooldown_reduction', value: 0.05 },
                    { name: 'ë°©ì–´ë ¥', type: 'armor', value: 5 },
                    { name: 'íƒ„ì•½ ì¬ìƒ (5ì´ˆ)', type: 'ammo_regen', value: 5000 },
                    { name: 'ë‹¤ì¤‘ ë°œì‚¬ +1', type: 'multishot', value: 1 },
                    { name: 'ê³µê²©ë ¥ +10', type: 'damage', value: 10 },
                    { name: 'ì†ë„ +1', type: 'speed', value: 1 },
                    { name: 'ì²´ë ¥ +50', type: 'health', value: 50 },
                    { name: 'ìµœëŒ€ ì²´ë ¥ +50', type: 'max_health', value: 50 },
                    { name: 'íƒ„ì•½ +10', type: 'ammo', value: 10 },
                    { name: 'ìµœëŒ€ íƒ„ì•½ +10', type: 'max_ammo', value: 10 }
                ];
                
                abilities.forEach(ability => {
                    const abilityDiv = document.createElement('div');
                    abilityDiv.style.display = 'flex';
                    abilityDiv.style.justifyContent = 'space-between';
                    abilityDiv.style.alignItems = 'center';
                    abilityDiv.style.margin = '8px 0';
                    abilityDiv.style.padding = '8px';
                    abilityDiv.style.background = 'rgba(255,255,255,0.1)';
                    abilityDiv.style.borderRadius = '6px';
                    abilityDiv.style.color = '#222';
                    
                    const label = document.createElement('span');
                    label.textContent = ability.name;
                    label.style.fontSize = '14px';
                    
                    const applyBtn = document.createElement('button');
                    applyBtn.textContent = 'ë¶€ì—¬';
                    applyBtn.style.background = '#6366f1';
                    applyBtn.style.color = '#fff';
                    applyBtn.style.border = 'none';
                    applyBtn.style.borderRadius = '4px';
                    applyBtn.style.padding = '4px 12px';
                    applyBtn.style.cursor = 'pointer';
                    applyBtn.style.fontSize = '12px';
                    
                    applyBtn.onclick = () => {
                        this.applyReward(ability.type, ability.value);
                        this.showMessage(`${ability.name} ë¶€ì—¬!`, '', 1500);
                    };
                    
                    abilityDiv.appendChild(label);
                    abilityDiv.appendChild(applyBtn);
                    abilityList.appendChild(abilityDiv);
                });
            };

            // í…ŒìŠ¤íŠ¸ ì¡´ HUD ë²„íŠ¼ ì¶”ê°€
            addTestZoneButtonToHUD = () => {
                const testZoneHUDButton = document.getElementById('testZoneHUDButton');
                testZoneHUDButton.style.display = 'inline-block';
                
                // í…ŒìŠ¤íŠ¸ ì¡´ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
                testZoneHUDButton.onclick = () => {
                    const testZonePopup = document.getElementById('testZonePopup');
                    if (testZonePopup.style.display === 'block') {
                        testZonePopup.style.display = 'none';
                    } else {
                        testZonePopup.style.display = 'block';
                        this.updateTestZone();
                    }
                };
            };

            // ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤ ì´ˆê¸°í™”
            initMobileControls = () => {
                const joystick = document.getElementById('joystickContainer');
                const joystickThumb = document.getElementById('joystickThumb');
                const aimJoystick = document.getElementById('aimJoystickContainer');
                const aimJoystickThumb = document.getElementById('aimJoystickThumb');
                const fireButton = document.getElementById('fireButton');
                const jumpButton = document.getElementById('jumpButton');
                const reloadButton = document.getElementById('reloadButton');

                if (!joystick || !aimJoystick || !fireButton || !jumpButton || !reloadButton) {
                    console.error('Mobile control elements not found');
                    return;
                }

                // ì¡°ì´ìŠ¤í‹± ì´ë²¤íŠ¸
                joystick.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const rect = joystick.getBoundingClientRect();
                    this.touchControls.joystick.centerX = rect.left + rect.width / 2;
                    this.touchControls.joystick.centerY = rect.top + rect.height / 2;
                    this.touchControls.joystick.active = true;
                    this.updateJoystick(touch.clientX, touch.clientY);
                });

                joystick.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (this.touchControls.joystick.active) {
                        const touch = e.touches[0];
                        this.updateJoystick(touch.clientX, touch.clientY);
                    }
                });

                joystick.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.touchControls.joystick.active = false;
                    this.touchControls.joystick.x = 0;
                    this.touchControls.joystick.y = 0;
                    if (joystickThumb) {  // joystickThumb ì‚¬ìš©
                        joystickThumb.style.left = '50%';
                        joystickThumb.style.top = '50%';
                    }
                });

                aimJoystick.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const rect = aimJoystick.getBoundingClientRect();
                    this.touchControls.aimJoystick = { centerX: rect.left + rect.width / 2, centerY: rect.top + rect.height / 2, active: true, x: 0, y: 0 };
                    this.updateAimJoystick(touch.clientX, touch.clientY);
                });
                aimJoystick.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (this.touchControls.aimJoystick && this.touchControls.aimJoystick.active) {
                        const touch = e.touches[0];
                        this.updateAimJoystick(touch.clientX, touch.clientY);
                    }
                });
                aimJoystick.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    if (this.touchControls.aimJoystick) {
                        this.touchControls.aimJoystick.active = false;
                        this.touchControls.aimJoystick.x = 0;
                        this.touchControls.aimJoystick.y = 0;
                        if (aimJoystickThumb) {
                            aimJoystickThumb.style.left = '50%';
                            aimJoystickThumb.style.top = '50%';
                        }
                    }
                });

                // ë°œì‚¬ ë²„íŠ¼ ì´ë²¤íŠ¸
                fireButton.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.touchControls.fireButton.pressed = true;
                });

                fireButton.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.touchControls.fireButton.pressed = false;
                });

                // ì í”„ ë²„íŠ¼ ì´ë²¤íŠ¸
                jumpButton.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.touchControls.jumpButton.pressed = true;
                });

                jumpButton.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.touchControls.jumpButton.pressed = false;
                });

                // ì¬ì¥ì „ ë²„íŠ¼ ì´ë²¤íŠ¸
                reloadButton.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.touchControls.reloadButton.pressed = true;
                    if (this.gameState.gameStatus === 'playing') {
                        this.reload();
                    }
                });

                reloadButton.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.touchControls.reloadButton.pressed = false;
                });

                // ì¡°ì¤€ ì˜ì—­ ì´ë²¤íŠ¸
            };

            // ì¡°ì´ìŠ¤í‹± ì—…ë°ì´íŠ¸
            updateJoystick = (touchX, touchY) => {
                const dx = touchX - this.touchControls.joystick.centerX;
                const dy = touchY - this.touchControls.joystick.centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const maxDistance = 50;

                if (distance > maxDistance) {
                    const angle = Math.atan2(dy, dx);
                    this.touchControls.joystick.x = Math.cos(angle) * maxDistance;
                    this.touchControls.joystick.y = Math.sin(angle) * maxDistance;
                } else {
                    this.touchControls.joystick.x = dx;
                    this.touchControls.joystick.y = dy;
                }

                // ì¡°ì´ìŠ¤í‹± ì¸ ì´ë™
                const joystickThumb = document.getElementById('joystickThumb');
                if (joystickThumb) {
                    const knobX = 50 + (this.touchControls.joystick.x / maxDistance) * 50;
                    const knobY = 50 + (this.touchControls.joystick.y / maxDistance) * 50;
                    joystickThumb.style.left = knobX + '%';
                    joystickThumb.style.top = knobY + '%';
                }

                // ë””ë²„ê¹…ìš© ì½˜ì†” ì¶œë ¥
                console.log('Joystick:', this.touchControls.joystick.x, this.touchControls.joystick.y);
            };

            updateAimJoystick = (touchX, touchY) => {
                const dx = touchX - this.touchControls.aimJoystick.centerX;
                const dy = touchY - this.touchControls.aimJoystick.centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const maxDistance = 50;
                if (distance > maxDistance) {
                    const angle = Math.atan2(dy, dx);
                    this.touchControls.aimJoystick.x = Math.cos(angle) * maxDistance;
                    this.touchControls.aimJoystick.y = Math.sin(angle) * maxDistance;
                } else {
                    this.touchControls.aimJoystick.x = dx;
                    this.touchControls.aimJoystick.y = dy;
                }
                const aimJoystickThumb = document.getElementById('aimJoystickThumb');
                if (aimJoystickThumb) {
                    const knobX = 50 + (this.touchControls.aimJoystick.x / maxDistance) * 50;
                    const knobY = 50 + (this.touchControls.aimJoystick.y / maxDistance) * 50;
                    aimJoystickThumb.style.left = knobX + '%';
                    aimJoystickThumb.style.top = knobY + '%';
                }
            };
            // ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤ ë¹„í™œì„±í™”
            disableMobileControls = () => {
                this.touchControls.joystick.active = false;
                this.touchControls.joystick.x = 0;
                this.touchControls.joystick.y = 0;
                this.touchControls.fireButton.pressed = false;
                this.touchControls.jumpButton.pressed = false;
                this.touchControls.reloadButton.pressed = false;

                const joystickThumb = document.getElementById('joystickThumb');
                if (joystickThumb) {
                    joystickThumb.style.left = '50%';
                    joystickThumb.style.top = '50%';
                }
            };
        }

        let bossRushMode = false;


        // === Add after GlassCombatArena class definition or at the end of the script ===
        window.onload = function() {
            const soloModeSelect = document.getElementById('soloModeSelect');
            const normalModeButton = document.getElementById('normalModeButton');
            const bossRushModeButton = document.getElementById('bossRushModeButton');
            const backToIntroFromSolo = document.getElementById('backToIntroFromSolo');
            const introScreen = document.getElementById('introScreen');

            // ë©€í‹°í”Œë ˆì´ ë²„íŠ¼ ë° íŒì—… ê´€ë ¨ ë³€ìˆ˜
            const multiButton = document.getElementById('multiButton');
            const multiJoinPopup = document.getElementById('multiJoinPopup');
            const multiJoinBtn = document.getElementById('multiJoinBtn');
            const multiJoinCancel = document.getElementById('multiJoinCancel');
            let myNick = "";
            let roomId = "";
            let myState = { x: 100, y: 100, health: 100 };
            let otherPlayers = {};

            var onlineBtn = document.getElementById('onlineMultiplayerButton');
                if (onlineBtn) {
                    onlineBtn.onclick = function() {
                        document.getElementById('onlineMultiplayerPopup').style.display = 'block';
                    };
                }
                var closeOnlineBtn = document.getElementById('closeOnlineMultiplayerPopup');
                if (closeOnlineBtn) {
                    closeOnlineBtn.onclick = function() {
                        document.getElementById('onlineMultiplayerPopup').style.display = 'none';
                    };
                }

            multiButton.onclick = function() {
                introScreen.style.display = 'none';
                multiJoinPopup.style.display = 'block';
                // ë©€í‹°í”Œë ˆì´ ëª¨ë“œ ì„ íƒ/ì„¤ì • UI ìˆ¨ê¹€
                document.getElementById('multiplayerModeSelect').style.display = 'none';
                document.getElementById('leaderSetup').style.display = 'none';
                document.getElementById('hybridSetup').style.display = 'none';
                };
                multiJoinCancel.onclick = function() {
                multiJoinPopup.style.display = 'none';
                introScreen.style.display = 'flex';
                };


            multiJoinBtn.onclick = function() {
                myNick = document.getElementById('multiNickname').value.trim();
                roomId = document.getElementById('multiRoomId').value.trim();
                if (!myNick || !roomId) return alert("ë‹‰ë„¤ì„ê³¼ ë°© ì½”ë“œë¥¼ ì…ë ¥í•˜ì„¸ìš”!");
                multiJoinPopup.style.display = 'none';

                // ë‚´ ìƒíƒœ DBì— ë“±ë¡
                db.ref(`rooms/${roomId}/players/${myNick}`).set(myState);

                // ìƒëŒ€ë°© ìƒíƒœ ì‹¤ì‹œê°„ ê°ì§€
                db.ref(`rooms/${roomId}/players`).on('value', (snap) => {
                    const players = snap.val() || {};
                    otherPlayers = {};
                    Object.keys(players).forEach(nick => {
                    if (nick !== myNick) {
                        otherPlayers[nick] = players[nick];
                    }
                    });
                    // === ì‹¤ì œ ê²Œì„ ì˜¤ë¸Œì íŠ¸ì— ë°˜ì˜ ===
                    // ìƒëŒ€ë°©ì´ ìˆìœ¼ë©´ player2ë¡œ, ì—†ìœ¼ë©´ player2 ìˆ¨ê¹€
                    const otherNicks = Object.keys(otherPlayers);
                    if (otherNicks.length > 0) {
                    const other = otherPlayers[otherNicks[0]];
                    if (!window.game.gameState.player2) {
                        // player2 ê°ì²´ ìƒì„± (ê²Œì„ êµ¬ì¡°ì— ë§ê²Œ)
                        window.game.gameState.player2 = {
                        x: other.x, y: other.y, width: 40, height: 40, health: other.health, maxHealth: 100, color: '#ef4444', type: 'player2',
                        ammo: 30, maxAmmo: 30, speed: 5, baseDamage: 10, multishot: 1
                        };
                        document.getElementById('player2HUD').style.display = 'flex';
                    } else {
                        window.game.gameState.player2.x = other.x;
                        window.game.gameState.player2.y = other.y;
                        window.game.gameState.player2.health = other.health;
                    }
                    } else {
                    window.game.gameState.player2 = null;
                    document.getElementById('player2HUD').style.display = 'none';
                    }
                });

                // ë‚´ ìƒíƒœë¥¼ ì£¼ê¸°ì ìœ¼ë¡œ DBì— ë°˜ì˜ (0.1ì´ˆë§ˆë‹¤)
                if (window.syncInterval) clearInterval(window.syncInterval);
                window.syncInterval = setInterval(() => {
                    if (window.game && window.game.gameState && window.game.gameState.player) {
                    myState.x = window.game.gameState.player.x;
                    myState.y = window.game.gameState.player.y;
                    myState.health = window.game.gameState.player.health;
                    db.ref(`rooms/${roomId}/players/${myNick}`).set(myState);
                    }
                }, 100);
                };
            // ë°© ë‚˜ê°€ê¸°(ìƒˆë¡œê³ ì¹¨/ë‹«ê¸° ì‹œ ë‚´ ë°ì´í„° ì‚­ì œ)
            window.addEventListener('beforeunload', function() {
                if (myNick && roomId) {
                    db.ref(`rooms/${roomId}/players/${myNick}`).remove();
                }
                });

            document.getElementById('soloButton').onclick = function() {
            introScreen.style.display = 'none';
            soloModeSelect.style.display = 'flex';
            };
            normalModeButton.onclick = function() {
            bossRushMode = false;
            soloModeSelect.style.display = 'none';
            if (window.game && typeof window.game.startGame === 'function') {
                window.game.startGame();
            }
            };
            bossRushModeButton.onclick = function() {
            bossRushMode = true;
            soloModeSelect.style.display = 'none';
            if (window.game && typeof window.game.startGame === 'function') {
                window.game.startGame();
            }
            };
            backToIntroFromSolo.onclick = function() {
            soloModeSelect.style.display = 'none';
            introScreen.style.display = 'flex';
            };


          document.getElementById('startScreen').style.display = 'none';
          document.getElementById('introScreen').style.display = 'flex';

          // Attach event listener to Solo Play button
          document.getElementById('soloButton').onclick = function() {
            document.getElementById('introScreen').style.display = 'none';
            document.getElementById('soloModeSelect').style.display = 'flex';
          };
          
          // ë©€í‹°í”Œë ˆì´ ë²„íŠ¼ í´ë¦­ ì‹œ ë©€í‹°í”Œë ˆì´ ëª¨ë“œ ì„ íƒ í™”ë©´ í‘œì‹œ
          document.getElementById('multiButton').onclick = function() {
            document.getElementById('introScreen').style.display = 'none';
            document.getElementById('multiplayerModeSelect').style.display = 'flex';
          };
          
          // ë¦¬ë” ì‹œìŠ¤í…œ ì„ íƒ
          document.getElementById('leaderSystemButton').onclick = function() {
            document.getElementById('multiplayerModeSelect').style.display = 'none';
            document.getElementById('leaderSetup').style.display = 'flex';
          };
          
          // í•˜ì´ë¸Œë¦¬ë“œ ì‹œìŠ¤í…œ ì„ íƒ
          document.getElementById('hybridSystemButton').onclick = function() {
            document.getElementById('multiplayerModeSelect').style.display = 'none';
            document.getElementById('hybridSetup').style.display = 'flex';
          };
          
          // ë¦¬ë” ì‹œìŠ¤í…œ ì„¤ì • ì™„ë£Œ
          document.getElementById('leaderStartButton').onclick = function() {
            const leaderColor = document.getElementById('leaderColor').value;
            const followerColor = document.getElementById('followerColor').value;
            const leaderName = document.getElementById('leaderName').value || 'ë¦¬ë”';
            const followerName = document.getElementById('followerName').value || 'ë”°ë¥´ëŠ”ì';
            
            document.getElementById('leaderSetup').style.display = 'none';
            if (window.game && typeof window.game.startMultiplayerGame === 'function') {
              window.game.startMultiplayerGame('leader', {
                leaderColor: leaderColor,
                followerColor: followerColor,
                leaderName: leaderName,
                followerName: followerName
              });
            }
          };
          
          // í•˜ì´ë¸Œë¦¬ë“œ ì‹œìŠ¤í…œ ì„¤ì • ì™„ë£Œ
          document.getElementById('hybridStartButton').onclick = function() {
            const player1Color = document.getElementById('player1Color').value;
            const player2Color = document.getElementById('player2Color').value;
            const player1Name = document.getElementById('player1Name').value || 'í”Œë ˆì´ì–´1';
            const player2Name = document.getElementById('player2Name').value || 'í”Œë ˆì´ì–´2';
            const hybridPlayer = document.getElementById('hybridPlayer').value; // 'player1' or 'player2'
            
            document.getElementById('hybridSetup').style.display = 'none';
            if (window.game && typeof window.game.startMultiplayerGame === 'function') {
              window.game.startMultiplayerGame('hybrid', {
                player1Color: player1Color,
                player2Color: player2Color,
                player1Name: player1Name,
                player2Name: player2Name,
                hybridPlayer: hybridPlayer
              });
            }
          };
          
          // ë’¤ë¡œê°€ê¸° ë²„íŠ¼ë“¤
          document.getElementById('backToIntro').onclick = function() {
            document.getElementById('multiplayerModeSelect').style.display = 'none';
            document.getElementById('introScreen').style.display = 'flex';
          };
          
          document.getElementById('backToModeSelect').onclick = function() {
            document.getElementById('leaderSetup').style.display = 'none';
            document.getElementById('hybridSetup').style.display = 'none';
            document.getElementById('multiplayerModeSelect').style.display = 'flex';
          };
          
          // í…ŒìŠ¤íŒ… ì¡´ ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
          document.getElementById('testZoneButton').onclick = function() {
            document.getElementById('introScreen').style.display = 'none';
            if (window.game && typeof window.game.startTestZone === 'function') {
              window.game.startTestZone();
            }
          };
          // ìƒì  í† ê¸€ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
          document.getElementById('shopButton').onclick = function() {
            const shopPopup = document.getElementById('shopPopup');
            if (shopPopup.style.display === 'block') {
              shopPopup.style.display = 'none';
            } else {
              shopPopup.style.display = 'block';
              window.game.updateShopList();
            }
          };
          document.getElementById('returnToMenuButton').onclick = function() {
            window.game.returnToMainMenu();
          };
          // í€˜ìŠ¤íŠ¸ ë²„íŠ¼ ì—´ê¸°
          document.getElementById('questButton').onclick = function() {
            document.getElementById('questPopup').style.display = 'block';
            document.getElementById('questList').innerHTML = '<div>ì˜ˆì‹œ í€˜ìŠ¤íŠ¸: 5ì›¨ì´ë¸Œ ëŒíŒŒ<br>ì˜ˆì‹œ í€˜ìŠ¤íŠ¸: 2000ì  ë‹¬ì„±<br>ì˜ˆì‹œ í€˜ìŠ¤íŠ¸: ë³´ìŠ¤ ì²˜ì¹˜</div>';
          };
          // í€˜ìŠ¤íŠ¸ íŒì—… ë‹«ê¸°
          document.getElementById('closeQuestButton').onclick = function() {
            document.getElementById('questPopup').style.display = 'none';
          };
        };

        // === GlassCombatArena í´ë˜ìŠ¤ ì •ì˜ ëë‚œ í›„ ===
        window.game = new GlassCombatArena();

        // ëª¨ë°”ì¼ ëª¨ë“œ ì²´í¬ë°•ìŠ¤ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
        const mobileModeCheckbox = document.getElementById('mobileModeCheckbox');
        if (mobileModeCheckbox) {
            mobileModeCheckbox.addEventListener('change', function() {
                if (window.game) {
                    window.game.mobileMode = this.checked;
                    const mobileControls = document.getElementById('mobileControls');
                    if (this.checked) {
                        mobileControls.style.display = 'block';
                        window.game.initMobileControls();
                    } else {
                        mobileControls.style.display = 'none';
                        window.game.disableMobileControls();
                    }
                }
            });
        }
        (function() {
            const db = firebase.database();
            
            // Firebase ì—°ê²° ìƒíƒœ í™•ì¸
            const connectedRef = db.ref(".info/connected");
            connectedRef.on("value", function(snap) {
                if (snap.val() === true) {
                    console.log("Firebaseì— ì—°ê²°ë˜ì—ˆìŠµë‹ˆë‹¤.");
                } else {
                    console.log("Firebase ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤.");
                }
            });
            const createRoomButton = document.getElementById('createRoomButton');
            const roomNameInput = document.getElementById('roomNameInput');
            const roomListDiv = document.getElementById('roomList');
            const enterRoomPopup = document.getElementById('enterRoomPopup');
            const playerNameInput = document.getElementById('playerNameInput');
            const enterRoomButton = document.getElementById('enterRoomButton');
            const cancelEnterRoomButton = document.getElementById('cancelEnterRoomButton');
            const roomLobbyPopup = document.getElementById('roomLobbyPopup');
            const lobbyRoomName = document.getElementById('lobbyRoomName');
            const lobbyPlayerList = document.getElementById('lobbyPlayerList');
            const readyButton = document.getElementById('readyButton');
            const leaveLobbyButton = document.getElementById('leaveLobbyButton');
            const lobbyStatusMsg = document.getElementById('lobbyStatusMsg');

            let myRoomKey = null;
            let myPlayerName = null;
            let selectedRoomKey = null;
            let lobbyUnsub = null;

            // --- ë°© ë§Œë“¤ê¸° ---
            if (createRoomButton) {
                createRoomButton.onclick = function() {
                    const name = roomNameInput.value.trim();
                    if (!name) return alert('ë°© ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”!');
                    // ì¤‘ë³µ ë°© ì´ë¦„ ë°©ì§€(ì˜µì…˜)
                    db.ref('rooms').orderByChild('name').equalTo(name).once('value', snap => {
                        if (snap.exists()) {
                            alert('ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ë°© ì´ë¦„ì…ë‹ˆë‹¤. ë‹¤ë¥¸ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”!');
                            return;
                        }
                        const newRoom = {
                            name: name,
                            createdAt: Date.now(),
                            status: 'waiting',
                            players: {}
                        };
                        const ref = db.ref('rooms').push(newRoom);
                        myRoomKey = ref.key;
                        roomNameInput.value = '';
                    });
                };
            }

            // --- ë°© ë¦¬ìŠ¤íŠ¸ ì‹¤ì‹œê°„ í‘œì‹œ ---
            db.ref('rooms').on('value', snap => {
                const rooms = snap.val() || {};
                let html = '';
                Object.entries(rooms).forEach(([key, room]) => {
                    html += `<div class="room-item" data-key="${key}" style="padding:7px 0; border-bottom:1px solid rgba(255,255,255,0.08); cursor:pointer;">`;
                    html += `<b>${room.name}</b> <span style='font-size:0.9em; opacity:0.7;'>(${room.status === 'waiting' ? 'ëŒ€ê¸°ì¤‘' : 'ì§„í–‰ì¤‘'})</span>`;
                    html += `</div>`;
                });
                roomListDiv.innerHTML = html || '<div style="opacity:0.7;">ìƒì„±ëœ ë°©ì´ ì—†ìŠµë‹ˆë‹¤.</div>';
            });

            // --- ë°© í´ë¦­ ì‹œ ì´ë¦„ ì…ë ¥ íŒì—… ---
            roomListDiv.onclick = function(e) {
                const item = e.target.closest('.room-item');
                if (!item) return;
                selectedRoomKey = item.getAttribute('data-key');
                enterRoomPopup.style.display = 'block';
                playerNameInput.value = '';
            };

            // --- ì…ì¥ ë²„íŠ¼ ---
            enterRoomButton.onclick = function() {
                const playerName = playerNameInput.value.trim();
                if (!playerName) return alert('ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”!');
                if (/[^a-zA-Z0-9ê°€-í£_]/.test(playerName)) return alert('ì´ë¦„ì— íŠ¹ìˆ˜ë¬¸ìë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤!');
                if (!selectedRoomKey) return alert('ë°©ì´ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                myPlayerName = playerName;
                myRoomKey = selectedRoomKey;
                db.ref(`rooms/${myRoomKey}/players/${myPlayerName}`).set({
                    ready: false,
                    joinedAt: Date.now()
                });
                enterRoomPopup.style.display = 'none';
                openLobby();
            };

            // --- ì·¨ì†Œ ë²„íŠ¼ ---
            cancelEnterRoomButton.onclick = function() {
                enterRoomPopup.style.display = 'none';
            };

            // --- ë¡œë¹„ ì—´ê¸° í•¨ìˆ˜ ---
            function openLobby() {
                roomLobbyPopup.style.display = 'block';
                lobbyRoomName.textContent = 'ë°© ì´ë¦„: ' + (roomListDiv.querySelector(`[data-key='${myRoomKey}'] b`)?.textContent || '');
                
                if (lobbyUnsub) lobbyUnsub.off();
                lobbyUnsub = db.ref(`rooms/${myRoomKey}/players`);
                lobbyUnsub.on('value', snap => {
                    const players = snap.val() || {};
                    let html = '';
                    let allReady = true;
                    let readyCount = 0;
                    
                    Object.entries(players).forEach(([name, info]) => {
                        const isReady = info.ready === true;
                        const isMe = name === myPlayerName;
                        html += `<div style="padding: 4px 0; ${isMe ? 'font-weight: bold; color: #60a5fa;' : ''}">`;
                        html += `${name} ${isReady ? 'âœ…' : 'âŒ'}`;
                        if (isMe) html += ' (ë‚˜)';
                        html += '</div>';
                        
                        if (!isReady) allReady = false;
                        else readyCount++;
                    });
                    
                    lobbyPlayerList.innerHTML = html || '<div style="opacity:0.7;">í”Œë ˆì´ì–´ ì—†ìŒ</div>';
                    
                    // ì¤€ë¹„ ìƒíƒœ ë©”ì‹œì§€ ì—…ë°ì´íŠ¸
                    const totalPlayers = Object.keys(players).length;
                    if (totalPlayers > 0) {
                        if (allReady && totalPlayers >= 1) {
                            lobbyStatusMsg.textContent = 'ëª¨ë‘ ì¤€ë¹„ ì™„ë£Œ! ê²Œì„ì´ ê³§ ì‹œì‘ë©ë‹ˆë‹¤...';
                            lobbyStatusMsg.style.color = '#10b981';
                            
                            setTimeout(() => {
                                roomLobbyPopup.style.display = 'none';
                                if (window.game && typeof window.game.startGame === 'function') {
                                    window.game.startGame();
                                    startMultiplayerSync(myRoomKey, myPlayerName);
                                }
                            }, 2000);
                        } else {
                            lobbyStatusMsg.textContent = `ì¤€ë¹„: ${readyCount}/${totalPlayers}ëª…`;
                            lobbyStatusMsg.style.color = '#f59e0b';
                        }
                    } else {
                        lobbyStatusMsg.textContent = '';
                    }
                });
                
                readyButton.disabled = false;
                readyButton.textContent = 'ì¤€ë¹„';
            }

            // --- ì¤€ë¹„ ë²„íŠ¼ ---
            readyButton.onclick = function() {
                if (!myRoomKey || !myPlayerName) return;
                db.ref(`rooms/${myRoomKey}/players/${myPlayerName}/ready`).set(true);
                this.disabled = true;
                this.textContent = 'ì¤€ë¹„ ì™„ë£Œ';
            };

            // --- ë‚˜ê°€ê¸° ë²„íŠ¼ ---
            leaveLobbyButton.onclick = function() {
                if (myRoomKey && myPlayerName) {
                    db.ref(`rooms/${myRoomKey}/players/${myPlayerName}`).remove();
                }
                roomLobbyPopup.style.display = 'none';
                myRoomKey = null;
                myPlayerName = null;
                if (lobbyUnsub) lobbyUnsub.off();
            };

            // --- ìƒˆë¡œê³ ì¹¨/ë‹«ê¸° ì‹œ ë°©ì—ì„œ ë‚˜ê°€ê¸° ---
            window.addEventListener('beforeunload', function() {
                if (myRoomKey && myPlayerName) {
                    db.ref(`rooms/${myRoomKey}/players/${myPlayerName}`).remove();
                    
                    // ë°©ì— í”Œë ˆì´ì–´ê°€ ì—†ìœ¼ë©´ ë°© ì‚­ì œ
                    db.ref(`rooms/${myRoomKey}/players`).once('value', snap => {
                        const players = snap.val();
                        if (!players || Object.keys(players).length === 0) {
                            db.ref(`rooms/${myRoomKey}`).remove();
                        }
                    });
                }
            });
            
            // í˜ì´ì§€ ìˆ¨ê¹€/ë³´ì„ ì‹œì—ë„ ì²˜ë¦¬
            document.addEventListener('visibilitychange', function() {
                if (document.hidden && myRoomKey && myPlayerName) {
                    db.ref(`rooms/${myRoomKey}/players/${myPlayerName}`).remove();
                }
            });

            // === ì˜¨ë¼ì¸ í˜‘ë™ ë™ê¸°í™” í•¨ìˆ˜ ===
            function startMultiplayerSync(roomId, playerName) {
                if (window._multiplayerSyncStarted) return;
                window._multiplayerSyncStarted = true;
                
                console.log(`ì˜¨ë¼ì¸ í˜‘ë™ ë™ê¸°í™” ì‹œì‘: ${roomId}, ${playerName}`);
                
                // ë°©ì¥ ê²°ì • (ì²« ë²ˆì§¸ í”Œë ˆì´ì–´ê°€ ë°©ì¥)
                let isHost = false;
                db.ref(`rooms/${roomId}/players`).once('value', snap => {
                    const players = snap.val() || {};
                    const playerNames = Object.keys(players).sort();
                    isHost = playerNames[0] === playerName;
                    console.log(`ë°©ì¥ ì—¬ë¶€: ${isHost}`);
                    
                    // ê²Œì„ ìƒíƒœì— ë°©ì¥ ì •ë³´ ì €ì¥
                    if (window.game) {
                        window.game.gameState.isHost = isHost;
                        window.game.gameState.roomId = roomId;
                        window.game.gameState.myName = playerName;
                    }
                    
                    // 1. ê²ŒìŠ¤íŠ¸ ì…ë ¥ ì „ì†¡ (ê²ŒìŠ¤íŠ¸ë§Œ)
                    if (!isHost) {
                        setInterval(() => {
                            if (window.game && window.game.keys) {
                                const input = {
                                    keys: { ...window.game.keys },
                                    mouse: { ...window.game.mouse },
                                    shoot: window.game._shootPressed || false,
                                    timestamp: Date.now()
                                };
                                db.ref(`rooms/${roomId}/inputs/${playerName}`).set(input);
                            }
                        }, 33); // 30fps
                    }
                    
                    // 2. ë°©ì¥ ì…ë ¥ ìˆ˜ì‹  ë° ì²˜ë¦¬ (ë°©ì¥ë§Œ)
                    if (isHost) {
                        setInterval(() => {
                            db.ref(`rooms/${roomId}/inputs`).once('value', snap => {
                                const inputs = snap.val() || {};
                                Object.entries(inputs).forEach(([name, input]) => {
                                    if (window.game && input) {
                                        applyInputToPlayer(name, input);
                                    }
                                });
                            });
                        }, 16); // 60fps
                        
                        // 3. ë°©ì¥ì´ ì²˜ë¦¬í•œ ê²°ê³¼ ë™ê¸°í™”
                        setInterval(() => {
                            if (window.game) {
                                // í”Œë ˆì´ì–´ ìƒíƒœ ë™ê¸°í™”
                                db.ref(`rooms/${roomId}/players`).set(window.game.gameState.players);
                                // ì  ìƒíƒœ ë™ê¸°í™”
                                db.ref(`rooms/${roomId}/enemies`).set(window.game.gameState.enemies);
                                // ê²Œì„ ìƒíƒœ ë™ê¸°í™”
                                db.ref(`rooms/${roomId}/gameState`).set({
                                    score: window.game.gameState.score,
                                    level: window.game.gameState.level,
                                    gameTime: window.game.gameState.gameTime
                                });
                                // ì•„ì´í…œ ìƒíƒœ ë™ê¸°í™”
                                if (window.game.gameState.items) {
                                    db.ref(`rooms/${roomId}/items`).set(window.game.gameState.items);
                                }
                                // íŠ¹ìˆ˜íš¨ê³¼ ë™ê¸°í™”
                                if (window.game.gameState.effects) {
                                    db.ref(`rooms/${roomId}/effects`).set(window.game.gameState.effects);
                                }
                            }
                        }, 100);
                    }
                    
                    // 4. ëª¨ë“  í”Œë ˆì´ì–´ê°€ ìƒíƒœ ìˆ˜ì‹ 
                    db.ref(`rooms/${roomId}/players`).on('value', snap => {
                        const players = snap.val() || {};
                        if (window.game) {
                            window.game.gameState.players = players;
                        }
                    });
                    
                    db.ref(`rooms/${roomId}/enemies`).on('value', snap => {
                        const enemies = snap.val() || {};
                        if (window.game) {
                            window.game.gameState.enemies = enemies;
                        }
                    });
                    
                    db.ref(`rooms/${roomId}/gameState`).on('value', snap => {
                        const gameState = snap.val() || {};
                        if (window.game) {
                            window.game.gameState.score = gameState.score || 0;
                            window.game.gameState.level = gameState.level || 1;
                            window.game.gameState.gameTime = gameState.gameTime || 0;
                        }
                    });
                    
                    db.ref(`rooms/${roomId}/items`).on('value', snap => {
                        const items = snap.val() || {};
                        if (window.game) {
                            window.game.gameState.items = items;
                        }
                    });
                    
                    db.ref(`rooms/${roomId}/effects`).on('value', snap => {
                        const effects = snap.val() || [];
                        if (window.game) {
                            window.game.gameState.effects = effects;
                        }
                    });
                });
                
                let lastSyncTime = Date.now();
                db.ref(`rooms/${roomId}/players`).on('value', snap => {
                    lastSyncTime = Date.now();
                    const players = snap.val() || {};
                    if (window.game) {
                        window.game.gameState.players = players;
                    }
                    // ë°©ì¥ êµì²´ ê°ì§€
                    const playerNames = Object.keys(players).sort();
                    const newHost = playerNames[0];
                    const wasHost = window.game.gameState.isHost;
                    window.game.gameState.isHost = (newHost === playerName);
                    if (!wasHost && window.game.gameState.isHost) {
                        location.reload(); // ë‚´ê°€ ìƒˆ ë°©ì¥ì´ ë˜ë©´ ìƒˆë¡œê³ ì¹¨
                    }
                });
                setInterval(() => {
                    if (!window.game.gameState.isHost && Date.now() - lastSyncTime > 2000) {
                        window.game.showMessage('ì„œë²„ì™€ ì—°ê²°ì´ ëŠê²¼ìŠµë‹ˆë‹¤. ì¬ì ‘ì† í•´ì£¼ì„¸ìš”.', '', 999999);
                    }
                }, 1000);
            }
            
            // === ì…ë ¥ ì ìš© í•¨ìˆ˜ ===
            function applyInputToPlayer(playerName, input) {
                if (!window.game) return;
                
                // í”Œë ˆì´ì–´ ì°¾ê¸° ë˜ëŠ” ìƒì„±
                let player = window.game.gameState.players[playerName];
                if (!player) {
                    player = {
                        x: Math.random() * 800 + 100,
                        y: Math.random() * 600 + 100,
                        health: 100,
                        maxHealth: 100,
                        score: 0,
                        level: 1
                    };
                    window.game.gameState.players[playerName] = player;
                }
                
                // í‚¤ ì…ë ¥ì— ë”°ë¥¸ ì´ë™
                if (input.keys) {
                    const speed = 5;
                    if (input.keys.w || input.keys.ArrowUp) player.y -= speed;
                    if (input.keys.s || input.keys.ArrowDown) player.y += speed;
                    if (input.keys.a || input.keys.ArrowLeft) player.x -= speed;
                    if (input.keys.d || input.keys.ArrowRight) player.x += speed;
                    
                    // ê²½ê³„ ì²´í¬
                    player.x = Math.max(50, Math.min(750, player.x));
                    player.y = Math.max(50, Math.min(550, player.y));
                }
                
                // ë§ˆìš°ìŠ¤ ì¡°ì¤€
                if (input.mouse) {
                    player.aimX = input.mouse.x;
                    player.aimY = input.mouse.y;
                }
                
                // ë°œì‚¬ ì²˜ë¦¬
                if (input.shoot && !player.lastShootTime) {
                    player.lastShootTime = Date.now();
                    if (window.game.shootBullet) {
                        window.game.shootBullet(playerName, player.x, player.y, player.aimX, player.aimY);
                    }
                } else if (!input.shoot) {
                    player.lastShootTime = null;
                }
                
                // í”Œë ˆì´ì–´ ìƒíƒœ ì—…ë°ì´íŠ¸
                window.game.gameState.players[playerName] = player;
            }
            
            // === í”Œë ˆì´ì–´ë³„ ë°œì‚¬ í•¨ìˆ˜ ===
            if (window.game && !window.game.shootBullet) {
                window.game.shootBullet = function(playerName, x, y, aimX, aimY) {
                    const angle = Math.atan2(aimY - y, aimX - x);
                    const bullet = {
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * 10,
                        vy: Math.sin(angle) * 10,
                        player: playerName,
                        damage: 25,
                        life: 100
                    };
                    
                    if (!this.gameState.bullets) this.gameState.bullets = [];
                    this.gameState.bullets.push(bullet);
                    
                    // ë°œì‚¬ íš¨ê³¼ìŒ
                    if (this.sounds && this.sounds.shoot) {
                        this.sounds.shoot.currentTime = 0;
                        this.sounds.shoot.play();
                    }
                };
            }
            
            // === ì•„ì´í…œ íšë“ ë™ê¸°í™” í•¨ìˆ˜ ===
            if (window.game && !window.game.collectItem) {
                window.game.collectItem = function(playerName, itemId) {
                    if (!this.gameState.isHost) return; // ë°©ì¥ë§Œ ì²˜ë¦¬
                    
                    const item = this.gameState.items[itemId];
                    if (!item) return;
                    
                    const player = this.gameState.players[playerName];
                    if (!player) return;
                    
                    // ì•„ì´í…œ íš¨ê³¼ ì ìš©
                    switch(item.type) {
                        case 'health':
                            player.health = Math.min(player.maxHealth, player.health + 50);
                            break;
                        case 'speed':
                            player.speedBoost = (player.speedBoost || 0) + 1;
                            setTimeout(() => player.speedBoost = Math.max(0, (player.speedBoost || 0) - 1), 10000);
                            break;
                        case 'damage':
                            player.damageBoost = (player.damageBoost || 0) + 1;
                            setTimeout(() => player.damageBoost = Math.max(0, (player.damageBoost || 0) - 1), 10000);
                            break;
                    }
                    
                    // ì•„ì´í…œ ì œê±°
                    delete this.gameState.items[itemId];
                    
                    // ì ìˆ˜ ì¶”ê°€
                    this.gameState.score += 100;
                    
                    // íŠ¹ìˆ˜íš¨ê³¼ ì¶”ê°€
                    if (!this.gameState.effects) this.gameState.effects = [];
                    this.gameState.effects.push({
                        type: 'itemCollect',
                        x: item.x,
                        y: item.y,
                        player: playerName,
                        timestamp: Date.now()
                    });
                    
                    console.log(`${playerName}ì´ ì•„ì´í…œì„ íšë“í–ˆìŠµë‹ˆë‹¤: ${item.type}`);
                };
            }
            
            // === ì  ì²˜ì¹˜ ë™ê¸°í™” í•¨ìˆ˜ ===
            if (window.game && !window.game.killEnemy) {
                window.game.killEnemy = function(enemyId, killerName) {
                    if (!this.gameState.isHost) return; // ë°©ì¥ë§Œ ì²˜ë¦¬
                    
                    const enemy = this.gameState.enemies[enemyId];
                    if (!enemy) return;
                    
                    // ì  ì œê±°
                    delete this.gameState.enemies[enemyId];
                    
                    // ì ìˆ˜ ì¶”ê°€ (ì²˜ì¹˜í•œ í”Œë ˆì´ì–´ì—ê²Œ)
                    if (killerName && this.gameState.players[killerName]) {
                        this.gameState.players[killerName].score += enemy.score || 100;
                    }
                    this.gameState.score += enemy.score || 100;
                    
                    // íŠ¹ìˆ˜íš¨ê³¼ ì¶”ê°€
                    if (!this.gameState.effects) this.gameState.effects = [];
                    this.gameState.effects.push({
                        type: 'enemyDeath',
                        x: enemy.x,
                        y: enemy.y,
                        killer: killerName,
                        timestamp: Date.now()
                    });
                    
                    // ì•„ì´í…œ ë“œë¡­ (20% í™•ë¥ )
                    if (Math.random() < 0.2) {
                        const itemTypes = ['health', 'speed', 'damage'];
                        const randomType = itemTypes[Math.floor(Math.random() * itemTypes.length)];
                        const itemId = 'item_' + Date.now() + '_' + Math.random();
                        
                        if (!this.gameState.items) this.gameState.items = {};
                        this.gameState.items[itemId] = {
                            x: enemy.x,
                            y: enemy.y,
                            type: randomType,
                            timestamp: Date.now()
                        };
                    }
                    
                    console.log(`${killerName}ì´ ì ì„ ì²˜ì¹˜í–ˆìŠµë‹ˆë‹¤!`);
                };
            }
            
            // === íŠ¹ìˆ˜íš¨ê³¼ ì²˜ë¦¬ í•¨ìˆ˜ ===
            if (window.game && !window.game.processEffects) {
                window.game.processEffects = function() {
                    if (!this.gameState.effects) return;
                    
                    const now = Date.now();
                    this.gameState.effects = this.gameState.effects.filter(effect => {
                        // 3ì´ˆ í›„ íš¨ê³¼ ì œê±°
                        return now - effect.timestamp < 3000;
                    });
                };
            }
            
            // === ì¶©ëŒ ê°ì§€ ë™ê¸°í™” í•¨ìˆ˜ ===
            if (window.game && !window.game.checkCollisions) {
                window.game.checkCollisions = function() {
                    if (!this.gameState.isHost) return; // ë°©ì¥ë§Œ ì²˜ë¦¬
                    
                    // ì´ì•Œ-ì  ì¶©ëŒ ê°ì§€
                    if (this.gameState.bullets && this.gameState.enemies) {
                        this.gameState.bullets.forEach((bullet, bulletIndex) => {
                            Object.entries(this.gameState.enemies).forEach(([enemyId, enemy]) => {
                                const distance = Math.sqrt(
                                    Math.pow(bullet.x - enemy.x, 2) + 
                                    Math.pow(bullet.y - enemy.y, 2)
                                );
                                
                                if (distance < 30) { // ì¶©ëŒ ë°œìƒ
                                    // ì  ì²´ë ¥ ê°ì†Œ
                                    enemy.health = (enemy.health || 100) - bullet.damage;
                                    
                                    // ì´ì•Œ ì œê±°
                                    this.gameState.bullets.splice(bulletIndex, 1);
                                    
                                    // ì ì´ ì£½ì—ˆëŠ”ì§€ í™•ì¸
                                    if (enemy.health <= 0) {
                                        this.killEnemy(enemyId, bullet.player);
                                    }
                                    
                                    // íŠ¹ìˆ˜íš¨ê³¼ ì¶”ê°€
                                    if (!this.gameState.effects) this.gameState.effects = [];
                                    this.gameState.effects.push({
                                        type: 'bulletHit',
                                        x: bullet.x,
                                        y: bullet.y,
                                        timestamp: Date.now()
                                    });
                                }
                            });
                        });
                    }
                    
                    // í”Œë ˆì´ì–´-ì•„ì´í…œ ì¶©ëŒ ê°ì§€
                    if (this.gameState.players && this.gameState.items) {
                        Object.entries(this.gameState.players).forEach(([playerName, player]) => {
                            Object.entries(this.gameState.items).forEach(([itemId, item]) => {
                                const distance = Math.sqrt(
                                    Math.pow(player.x - item.x, 2) + 
                                    Math.pow(player.y - item.y, 2)
                                );
                                
                                if (distance < 40) { // ì•„ì´í…œ íšë“
                                    this.collectItem(playerName, itemId);
                                }
                            });
                        });
                    }
                };
            }
            
            // === ì˜¨ë¼ì¸ í”Œë ˆì´ì–´ ë Œë”ë§ í•¨ìˆ˜ ===
            if (window.game && !window.game.renderOnlinePlayers) {
                window.game.renderOnlinePlayers = function(ctx) {
                    if (!this.gameState.players) return;
                    
                    Object.entries(this.gameState.players).forEach(([playerName, player]) => {
                        // ë‚´ ìºë¦­í„°ëŠ” ê±´ë„ˆë›°ê¸° (ì´ë¯¸ ê·¸ë ¤ì§)
                        if (playerName === this.gameState.myName) return;
                        
                        // í”Œë ˆì´ì–´ ê·¸ë¦¬ê¸°
                        ctx.save();
                        
                        // í”Œë ˆì´ì–´ ìƒ‰ìƒ (ë‹¤ë¥¸ í”Œë ˆì´ì–´ëŠ” íŒŒë€ìƒ‰)
                        ctx.fillStyle = '#60a5fa';
                        ctx.strokeStyle = '#1e40af';
                        
                        // í”Œë ˆì´ì–´ ëª¸ì²´
                        ctx.beginPath();
                        ctx.arc(player.x, player.y, 20, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        // í”Œë ˆì´ì–´ ì´ë¦„
                        ctx.fillStyle = '#ffffff';
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(playerName, player.x, player.y - 35);
                        
                        // ì²´ë ¥ë°”
                        const healthBarWidth = 40;
                        const healthBarHeight = 4;
                        const healthPercent = player.health / player.maxHealth;
                        
                        ctx.fillStyle = '#dc2626';
                        ctx.fillRect(player.x - healthBarWidth/2, player.y - 30, healthBarWidth, healthBarHeight);
                        
                        ctx.fillStyle = '#16a34a';
                        ctx.fillRect(player.x - healthBarWidth/2, player.y - 30, healthBarWidth * healthPercent, healthBarHeight);
                        
                        // ì¡°ì¤€ì„  (ë§ˆìš°ìŠ¤ ë°©í–¥)
                        if (player.aimX && player.aimY) {
                            ctx.strokeStyle = '#60a5fa';
                            ctx.lineWidth = 1;
                            ctx.setLineDash([5, 5]);
                            ctx.beginPath();
                            ctx.moveTo(player.x, player.y);
                            ctx.lineTo(player.aimX, player.aimY);
                            ctx.stroke();
                            ctx.setLineDash([]);
                        }
                        
                        ctx.restore();
                    });
                };
            }
            
            // === ì˜¨ë¼ì¸ ì•„ì´í…œ ë Œë”ë§ í•¨ìˆ˜ ===
            if (window.game && !window.game.renderOnlineItems) {
                window.game.renderOnlineItems = function(ctx) {
                    if (!this.gameState.items) return;
                    
                    Object.entries(this.gameState.items).forEach(([itemId, item]) => {
                        ctx.save();
                        
                        // ì•„ì´í…œ íƒ€ì…ì— ë”°ë¥¸ ìƒ‰ìƒ
                        switch(item.type) {
                            case 'health':
                                ctx.fillStyle = '#16a34a';
                                break;
                            case 'speed':
                                ctx.fillStyle = '#f59e0b';
                                break;
                            case 'damage':
                                ctx.fillStyle = '#dc2626';
                                break;
                            default:
                                ctx.fillStyle = '#ffffff';
                        }
                        
                        // ì•„ì´í…œ ê·¸ë¦¬ê¸°
                        ctx.beginPath();
                        ctx.arc(item.x, item.y, 8, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // ì•„ì´í…œ í…Œë‘ë¦¬
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        
                        ctx.restore();
                    });
                };
            }
            
            // === ì˜¨ë¼ì¸ íŠ¹ìˆ˜íš¨ê³¼ ë Œë”ë§ í•¨ìˆ˜ ===
            if (window.game && !window.game.renderOnlineEffects) {
                window.game.renderOnlineEffects = function(ctx) {
                    if (!this.gameState.effects) return;
                    
                    this.gameState.effects.forEach(effect => {
                        ctx.save();
                        
                        switch(effect.type) {
                            case 'itemCollect':
                                // ì•„ì´í…œ íšë“ íš¨ê³¼
                                ctx.fillStyle = '#fbbf24';
                                ctx.font = '16px Arial';
                                ctx.textAlign = 'center';
                                ctx.fillText('+100', effect.x, effect.y - 20);
                                break;
                                
                            case 'enemyDeath':
                                // ì  ì²˜ì¹˜ íš¨ê³¼
                                ctx.fillStyle = '#dc2626';
                                ctx.font = '14px Arial';
                                ctx.textAlign = 'center';
                                ctx.fillText('KILL!', effect.x, effect.y - 15);
                                break;
                                
                            case 'bulletHit':
                                // ì´ì•Œ ëª…ì¤‘ íš¨ê³¼
                                ctx.fillStyle = '#fbbf24';
                                ctx.beginPath();
                                ctx.arc(effect.x, effect.y, 3, 0, Math.PI * 2);
                                ctx.fill();
                                break;
                        }
                        
                        ctx.restore();
                    });
                };
            }
        })();


        // === ì±„íŒ… ê¸°ëŠ¥ ===
        (function() {
            // roomId, myPlayerNameì€ ì´ë¯¸ í• ë‹¹ë˜ì–´ ìˆë‹¤ê³  ê°€ì •
            let chatRoomId = typeof myRoomKey !== 'undefined' ? myRoomKey : null;
            let chatPlayerName = typeof myPlayerName !== 'undefined' ? myPlayerName : null;
            
            // ì†”ë¡œ í”Œë ˆì´ìš© ì±„íŒ… ì„¤ì •
            if (!chatRoomId) {
                chatRoomId = 'solo_chat';
                chatPlayerName = 'Player';
            }

            // ì±„íŒ… UI ìš”ì†Œ
            const chatBox = document.getElementById('chatBox');
            const chatMessages = document.getElementById('chatMessages');
            const chatInput = document.getElementById('chatInput');
            const chatNickname = document.getElementById('chatNickname');
            const chatSendBtn = document.getElementById('chatSendBtn');

            // ë‹‰ë„¤ì„ ì´ˆê¸°ê°’ ì„¤ì •
            chatNickname.value = chatPlayerName || 'Player';

            // ì±„íŒ… ë©”ì‹œì§€ ì¶œë ¥ í•¨ìˆ˜
            function addChatMessage(name, msg, isMe) {
                const div = document.createElement('div');
                div.style.marginBottom = '2px';
                div.innerHTML = `<b style="color:${isMe ? '#60a5fa' : '#fff'}">${name}</b>: ${msg}`;
                chatMessages.appendChild(div);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }

            // ì±„íŒ… ì „ì†¡
            function sendChat() {
                const msg = chatInput.value.trim();
                const nickname = chatNickname.value.trim() || 'Player';
                if (!msg) return;
                
                if (chatRoomId === 'solo_chat') {
                    // ì†”ë¡œ í”Œë ˆì´: ë¡œì»¬ ì±„íŒ…
                    addChatMessage(nickname, msg, true);
                } else {
                    // ì˜¨ë¼ì¸ í”Œë ˆì´: Firebase ì±„íŒ…
                    firebase.database().ref(`rooms/${chatRoomId}/chat`).push({
                        name: nickname,
                        msg: msg,
                        ts: Date.now()
                    });
                }
                chatInput.value = '';
            }

            // ì±„íŒ… ì „ì†¡ ë²„íŠ¼/ì—”í„°í‚¤ ì´ë²¤íŠ¸
            chatSendBtn.onclick = sendChat;
            chatInput.onkeydown = function(e) {
                if (e.key === 'Enter') sendChat();
            };
            chatNickname.onkeydown = function(e) {
                if (e.key === 'Enter') {
                    chatInput.focus();
                }
            };

            // ì±„íŒ… ìˆ˜ì‹ 
            function listenChat() {
                if (!chatRoomId) return;
                
                if (chatRoomId === 'solo_chat') {
                    // ì†”ë¡œ í”Œë ˆì´: ì±„íŒ… ìˆ˜ì‹  ë¶ˆí•„ìš”
                    return;
                }
                
                firebase.database().ref(`rooms/${chatRoomId}/chat`).limitToLast(50).on('child_added', snap => {
                    const { name, msg } = snap.val();
                    addChatMessage(name, msg, name === chatPlayerName);
                });
            }

            // ë°© ì…ì¥/ìƒì„± ì‹œ ì±„íŒ… ë¦¬ìŠ¤ë„ˆ ì—°ê²°
            setInterval(() => {
                if (typeof myRoomKey !== 'undefined' && myRoomKey && chatRoomId !== myRoomKey) {
                    chatRoomId = myRoomKey;
                    chatPlayerName = myPlayerName;
                    chatNickname.value = chatPlayerName || 'Player';
                    chatMessages.innerHTML = '';
                    listenChat();
                }
            }, 1000);
        })();
    </script>
</body>
</html>
