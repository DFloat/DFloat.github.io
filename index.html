<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ê¸€ë˜ìŠ¤ ì»´ë±ƒ ì•„ë ˆë‚˜</title>
    <meta name="description" content="2D ë¸Œë¼ìš°ì € ê¸°ë°˜ ì „íˆ¬ ê²Œì„ - ì¤‘ë ¥ ë¬¼ë¦¬í•™, ê¸€ë˜ìŠ¤ëª¨í”¼ì¦˜ UI, ë´‡ ì „íˆ¬ ì‹œìŠ¤í…œ">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* ì „ì—­ CSS ì¬ì„¤ì • */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* body ìŠ¤íƒ€ì¼: í°íŠ¸, ë°°ê²½, ì˜¤ë²„í”Œë¡œìš° ìˆ¨ê¹€, ì „ì²´ í™”ë©´ */
        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* ê²Œì„ ìº”ë²„ìŠ¤ ìŠ¤íƒ€ì¼: ì ˆëŒ€ ìœ„ì¹˜, ì»¤ì„œ, ë°°ê²½, ë¸”ëŸ¬ ì „í™˜ íš¨ê³¼ */
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); /* ìº”ë²„ìŠ¤ ë°°ê²½ë„ ë™ì¼í•˜ê²Œ ì„¤ì • */
            filter: blur(10px); /* ì´ˆê¸° ë¸”ëŸ¬ íš¨ê³¼ */
            transition: filter 0.5s ease; /* ë¸”ëŸ¬ ì „í™˜ ì• ë‹ˆë©”ì´ì…˜ */
            display: block; /* í•­ìƒ ë³´ì´ë„ë¡ ì„¤ì • */
        }
        
        /* ê¸€ë˜ìŠ¤ ì¹´ë“œ ìŠ¤íƒ€ì¼: ë°°ê²½ íë¦¼, í…Œë‘ë¦¬, ê·¸ë¦¼ì */
        .glass-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            color: #fff;
        }
        
        /* HUD (Head-Up Display) ìŠ¤íƒ€ì¼: ì™¼ìª½ ìƒë‹¨ ê³ ì •, flexboxë¡œ ë‚´ë¶€ ìš”ì†Œ ì •ë ¬ */
        .hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            pointer-events: none;
            z-index: 10;
            display: none;
            flex-direction: row;
            gap: 18px;
            justify-content: center;
            align-items: flex-start;
            padding: 12px 0 0 0;
        }
        
        /* HUD ë‚´ë¶€ ì•„ì´í…œ ìŠ¤íƒ€ì¼: ìƒí˜¸ì‘ìš© ê°€ëŠ¥ */
        .hud-item {
            pointer-events: auto;
            margin: 0 4px;
            min-width: 170px;
            max-width: 260px;
        }
        
        /* ì²´ë ¥/íƒ„ì•½ ë°” ìŠ¤íƒ€ì¼ */
        .health-bar, .ammo-bar {
            width: 150px;
            height: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            overflow: hidden;
            margin: 8px 0;
        }
        
        /* ì²´ë ¥ ë°” ì±„ìš°ê¸° ìŠ¤íƒ€ì¼: ê·¸ë¼ë°ì´ì…˜, ë„ˆë¹„ ì „í™˜ íš¨ê³¼ */
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ef4444, #f87171);
            transition: width 0.3s ease;
        }
        
        /* íƒ„ì•½ ë°” ì±„ìš°ê¸° ìŠ¤íƒ€ì¼: ê·¸ë¼ë°ì´ì…˜, ë„ˆë¹„ ì „í™˜ íš¨ê³¼ */
        .ammo-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #60a5fa);
            transition: width 0.3s ease;
        }
        
        /* ìŠ¤íƒ¯ í…ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ */
        .stats {
            color: white;
            font-size: 14px;
            font-weight: 500;
        }
        
        /* ì ìˆ˜ í…ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ */
        .score {
            color: white;
            font-size: 20px;
            font-weight: bold;
            text-align: center;
        }
        
        /* ì›¨ì´ë¸Œ í…ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ */
        .wave {
            color: white;
            font-size: 16px;
            font-weight: 600;
            text-align: center;
            margin-top: 8px;
        }
        
        /* ì¡°ì‘ë²• í…ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ */
        .controls {
            color: white;
            font-size: 12px;
        }
        
        /* ì¡°ì‘ í‚¤ í‘œì‹œ ìŠ¤íƒ€ì¼ */
        .control-key {
            background: rgba(255, 255, 255, 0.1);
            padding: 4px 8px;
            border-radius: 4px;
            margin: 2px;
            display: inline-block;
        }
        
        /* ê²Œì„ ë©”ì‹œì§€ ì»¨í…Œì´ë„ˆ ìŠ¤íƒ€ì¼ */
        .message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
        }
        
        /* ê²Œì„ ë©”ì‹œì§€ ì£¼ í…ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ */
        .message-text {
            color: white;
            font-size: 32px;
            font-weight: bold;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        /* ê²Œì„ ë©”ì‹œì§€ ë³´ì¡° í…ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ */
        .message-sub {
            color: rgba(255, 255, 255, 0.8);
            font-size: 18px;
            text-align: center;
            margin-top: 8px;
        }
        
        /* ê¹œë¹¡ì„ ì• ë‹ˆë©”ì´ì…˜ */
        .animate-pulse {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* ë¯¸ë‹ˆë§µ ìŠ¤íƒ€ì¼ */
        .minimap {
            width: 120px;
            height: 120px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            position: relative;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        /* ë¯¸ë‹ˆë§µ í”Œë ˆì´ì–´ ë„íŠ¸ ìŠ¤íƒ€ì¼ */
        .minimap-player {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #3b82f6;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        /* ë¯¸ë‹ˆë§µ ì  ë„íŠ¸ ìŠ¤íƒ€ì¼ */
        .minimap-enemy {
            position: absolute;
            width: 3px;
            height: 3px;
            background: #ef4444;
            border-radius: 50%;
        }
        
        /* ë¯¸ë‹ˆë§µ ì•„ì´í…œ ë„íŠ¸ ìŠ¤íƒ€ì¼ */
        .minimap-item {
            position: absolute;
            width: 2px;
            height: 2px;
            background: #fbbf24;
            border-radius: 50%;
        }

        /* ì‹œì‘ í™”ë©´ ìŠ¤íƒ€ì¼ */
        #startScreen {
            position: absolute; /* ìº”ë²„ìŠ¤ ìœ„ì— ì˜¤ë²„ë ˆì´ */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 101; /* HUDë³´ë‹¤ ë†’ê²Œ ì„¤ì • */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
            padding: 40px;
        }

        #startScreen h1 {
            font-size: 4em;
            margin-bottom: 20px;
            text-shadow: 0 0 15px rgba(255,255,255,0.5);
        }

        #startScreen p {
            font-size: 1.2em;
            margin-bottom: 30px;
            opacity: 0.8;
        }

        #startButton {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            padding: 15px 30px;
            font-size: 1.5em;
            font-weight: 600;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        #startButton:hover {
            background: rgba(255, 255, 255, 0.3);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
            transform: translateY(-2px);
        }

        #startButton:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        /* ë³´ìƒ ì„ íƒ í™”ë©´ ìŠ¤íƒ€ì¼ */
        #rewardSelectionScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200; /* ê°€ì¥ ìœ„ì— í‘œì‹œ */
            display: none; /* ì´ˆê¸°ì—ëŠ” ìˆ¨ê¹€ */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
            padding: 30px;
        }

        #rewardSelectionScreen h2 {
            font-size: 2.5em;
            margin-bottom: 25px;
            text-shadow: 0 0 10px rgba(255,255,255,0.4);
        }

        .reward-options {
            display: flex;
            gap: 20px;
            flex-wrap: wrap; /* ì‘ì€ í™”ë©´ì—ì„œ ì¤„ë°”ê¿ˆ */
            justify-content: center;
        }

        .reward-button {
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.25);
            border-radius: 12px;
            padding: 20px 25px;
            font-size: 1.2em;
            font-weight: bold;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(8px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
            min-width: 180px;
        }

        .reward-button:hover {
            background: rgba(255, 255, 255, 0.25);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.25);
            transform: translateY(-3px);
        }

        .reward-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        #shopPopup h2 {
            color: #fff;
            font-weight: bold;
        }

        #shopList {
            color: #fff;
            font-weight: normal;
        }

        /* --- 2. ìƒì  UI/ë¡œì§: ì ìˆ˜ë¡œ íŒ¨ì‹œë¸Œ ì—…ê·¸ë ˆì´ë“œ êµ¬ë§¤ --- */
        /* 1) ìƒì ì— í‘œì‹œí•  ì•„ì´í…œ ëª©ë¡ ë° ê°€ê²© ì„¤ì • (ë³´ìƒ ëª©ë¡ê³¼ ë™ì¼, ê°€ê²©ì€ ì˜ˆì‹œ) */

        /* 2) ìƒì  UIì— ì•„ì´í…œ í‘œì‹œ ë° êµ¬ë§¤ ë¡œì§ êµ¬í˜„ */

        /* 3) ìƒì  ë²„íŠ¼ í´ë¦­ ì‹œ updateShopList í˜¸ì¶œ */
        document.getElementById('shopButton').onclick = () => {
            document.getElementById('shopPopup').style.display = 'block';
            this.updateShopList();
        };
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <!-- HUD ìš”ì†Œë“¤ -->
    <div class="hud">
        <div class="glass-card hud-item" style="display:flex; flex-direction:row; align-items:center; gap:22px; min-width:unset; max-width:unset;">
            <div style="display:flex; align-items:center; gap:10px;">
                <div style="display:flex; align-items:center; gap:6px;">
                    <div style="width:8px; height:8px; background:#ef4444; border-radius:50%; animation:pulse 2s infinite;"></div>
                    <span>ì²´ë ¥</span>
                    <div class="health-bar" style="width:70px; margin:0 4px;"><div class="health-fill" id="healthFill" style="width:100%;"></div></div>
                    <span id="healthText">100/100</span>
                </div>
                <div style="display:flex; align-items:center; gap:6px; margin-left:16px;">
                    <div style="width:8px; height:8px; background:#3b82f6; border-radius:50%; animation:pulse 2s infinite;"></div>
                    <span>íƒ„ì•½</span>
                    <div class="ammo-bar" style="width:70px; margin:0 4px;"><div class="ammo-fill" id="ammoFill" style="width:100%;"></div></div>
                    <span id="ammoText">60/60</span>
                </div>
                <div style="display:flex; align-items:center; gap:6px; margin-left:16px;">
                    <div style="width:8px; height:8px; background:#8b5cf6; border-radius:50%;"></div>
                    <span>ì†ë„</span>
                    <span id="speedText">5</span>
                </div>
                <div style="display:flex; align-items:center; gap:6px; margin-left:16px;">
                    <div style="width:8px; height:8px; background:#dc2626; border-radius:50%;"></div>
                    <span>ê³µê²©ë ¥</span>
                    <span id="damageText">20</span>
                </div>
                <div style="display:flex; align-items:center; gap:6px; margin-left:16px;">
                    <div style="width:8px; height:8px; background:#7c3aed; border-radius:50%;"></div>
                    <span>ë‹¤ì¤‘ ë°œì‚¬</span>
                    <span id="multishotText">1</span>
                </div>
                <div style="display:flex; align-items:center; gap:6px; margin-left:16px;">
                    <span style="color:white; font-weight:600;">í™œì„± íš¨ê³¼</span>
                    <div id="activeEffects" style="font-size:12px; display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
                        <div id="invincibilityEffect"></div>
                        <div id="shieldBoostEffect"></div>
                        <div id="timeSlowEffect"></div>
                        <div id="magnetEffect"></div>
                        <div id="healthRegenEffect"></div>
                        <div id="rapidFireEffect"></div>
                        <div id="piercingShotEffect"></div>
                        <div id="explosiveShotEffect"></div>
                        <div id="orbitingKnivesEffect"></div>
                        <div id="ricochetShotEffect"></div>
                        <div id="homingShotEffect"></div>
                        <div id="splitShotEffect"></div>
                        <div id="ammoRegenEffect"></div>
                        <div id="timeStopEffect"></div>
                        <div id="dashEffect"></div>
                        <div id="lifeStealEffect"></div>
                        <div id="critChanceEffect"></div>
                        <div id="cooldownReductionEffect"></div>
                        <div id="armorEffect"></div>
                    </div>
                </div>
                <!-- ì ìˆ˜/ì›¨ì´ë¸Œ/ì  ìˆ˜ í‘œì‹œ (ì˜¤ë¥¸ìª½ ëì— ê°€ë¡œë¡œ) -->
                <span id="scoreText" style="margin-left:22px; color:#fff; font-size:1.1em; font-weight:600;"></span>
                <span id="waveText" style="margin-left:14px; color:#fff; font-size:1.1em; font-weight:600;"></span>
                <span id="enemyCount" style="margin-left:14px; color:#fff; font-size:1.1em; font-weight:600;"></span>
                <!-- 1. HUDì— XPì™€ ìƒì  ë²„íŠ¼ ì¶”ê°€ -->
                <span id="xpText" style="margin-left:18px; color:#ffe066; font-size:1.1em; font-weight:600;"></span>
                <button id="shopButton" style="margin-left:12px; font-size:1em; border-radius:6px; border:none; background:#ffe066; color:#222; padding:4px 16px; cursor:pointer;">ìƒì </button>
            </div>
        </div>
    </div>
    <!-- ë‚˜ë¨¸ì§€ HUD(ì›¨ì´ë¸Œ, ì¡°ì‘ë²•, ë¯¸ë‹ˆë§µ ë“±)ëŠ” ì•„ë˜/ì˜¤ë¥¸ìª½ ë“± ë³„ë„ ë°°ì¹˜ í•„ìš”ì‹œ ì¶”ê°€ -->
    
    <!-- ê²Œì„ ë©”ì‹œì§€ -->
    <div class="message" id="gameMessage" style="display: none;">
        <div class="glass-card">
            <div class="message-text" id="messageText"></div>
            <div class="message-sub" id="messageSubText"></div>
            <button id="restartButton" style="display:none; margin-top:18px; font-size:1.2em; padding:10px 30px; border-radius:8px; background:#6366f1; color:white; border:none; cursor:pointer;">ì¬ì‹œì‘</button>
        </div>
    </div>

    <!-- ì‹œì‘ í™”ë©´ -->
    <div id="startScreen" class="glass-card">
        <h1>ê¸€ë˜ìŠ¤ ì»´ë±ƒ ì•„ë ˆë‚˜</h1>
        <p>2D ë¸Œë¼ìš°ì € ê¸°ë°˜ ì „íˆ¬ ê²Œì„ - ì¤‘ë ¥ ë¬¼ë¦¬í•™, ê¸€ë˜ìŠ¤ëª¨í”¼ì¦˜ UI, ë´‡ ì „íˆ¬ ì‹œìŠ¤í…œ</p>
        <button id="startButton">ì‹œì‘í•˜ê¸°</button>
        <button id="enemyDexButton">ì  ë„ê°</button>
    </div>

    <!-- ë³´ìƒ ì„ íƒ í™”ë©´ -->
    <div id="rewardSelectionScreen" class="glass-card">
        <h2 id="rewardSelectionTitle">ë³´ìƒ ì„ íƒ</h2>
        <div class="reward-options" id="rewardOptions">
            <!-- ë³´ìƒ ë²„íŠ¼ë“¤ì´ ì—¬ê¸°ì— ë™ì ìœ¼ë¡œ ì¶”ê°€ë©ë‹ˆë‹¤. -->
        </div>
    </div>

    <!-- ì  ë„ê° í™”ë©´ -->
    <div id="enemyDexScreen" class="glass-card" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); z-index:300; min-width:520px; min-height:340px; max-width:90vw; max-height:80vh; flex-direction:row; align-items:stretch; padding:0; overflow:hidden;">
        <!-- ì¢Œì¸¡ ë¦¬ìŠ¤íŠ¸ -->
        <div id="enemyDexList" style="width:180px; background:rgba(0,0,0,0.18); border-right:1px solid rgba(255,255,255,0.12); overflow-y:auto; max-height:80vh; min-height:340px; display:flex; flex-direction:column;"></div>
        <!-- ìš°ì¸¡ ìƒì„¸ -->
        <div id="enemyDexDetail" style="flex:1; display:flex; flex-direction:column; align-items:center; justify-content:center; min-width:240px; padding:32px 16px 16px 16px;"></div>
        <button id="closeEnemyDexButton" style="position:absolute; top:12px; right:16px;">ë‹«ê¸°</button>
    </div>

    <!-- í€˜ìŠ¤íŠ¸ ë²„íŠ¼ ë° í€˜ìŠ¤íŠ¸ íŒì—… -->
    <button id="questButton" style="position:absolute; top:24px; left:220px; z-index:20; background:rgba(255,255,255,0.18); color:white; border:none; border-radius:8px; padding:8px 18px; font-size:15px; cursor:pointer;">í€˜ìŠ¤íŠ¸</button>
    <div id="questPopup" class="glass-card" style="display:none; position:absolute; top:60px; left:220px; z-index:30; min-width:260px; min-height:180px;">
        <h3 style="color:white; margin-bottom:12px;">í€˜ìŠ¤íŠ¸</h3>
        <div id="questList" style="color:white; font-size:15px;"></div>
        <button id="closeQuestButton" style="margin-top:18px;">ë‹«ê¸°</button>
    </div>

    <!-- ì¸íŠ¸ë¡œ í™”ë©´: ì†”ë¡œ/í•¨ê»˜ í”Œë ˆì´ ì„ íƒ -->
    <div id="introScreen" class="glass-card" style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); z-index:200; display:flex; flex-direction:column; align-items:center; justify-content:center; min-width:340px; min-height:220px;">
        <h1 style="font-size:2.5em; margin-bottom:18px;">ê¸€ë˜ìŠ¤ ì»´ë±ƒ ì•„ë ˆë‚˜</h1>
        <button id="soloButton" style="margin:10px 0; padding:14px 36px; font-size:1.2em; border-radius:10px; border:none; background:#6366f1; color:white; cursor:pointer;">ì†”ë¡œ í”Œë ˆì´</button>
        <button id="multiButton" style="margin:10px 0; padding:14px 36px; font-size:1.2em; border-radius:10px; border:none; background:#22c55e; color:white; cursor:pointer;">í•¨ê»˜ í”Œë ˆì´</button>
        <div id="multiInfo" style="display:none; color:#fff; margin-top:18px; font-size:1.1em;">í•¨ê»˜ í”Œë ˆì´(ì˜¨ë¼ì¸)ëŠ” ì¶”í›„ ì§€ì› ì˜ˆì •ì…ë‹ˆë‹¤.</div>
    </div>

    <!-- ë­í‚¹ í™”ë©´ -->
    <div id="rankingScreen" class="glass-card" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); z-index:250; min-width:340px; min-height:320px;">
        <h2 style="color:white; margin-bottom:12px;">ë­í‚¹</h2>
        <div id="rankingList" style="color:white; font-size:15px; min-height:180px;"></div>
        <button id="closeRankingButton" style="margin-top:18px;">ë‹«ê¸°</button>
    </div>

    <!-- ë¯¸ë‹ˆë§µ (HUD ì•„ë˜ ì˜¤ë¥¸ìª½ ë“± ì›í•˜ëŠ” ìœ„ì¹˜ë¡œ ì¡°ì • ê°€ëŠ¥) -->
    <div class="minimap" id="minimap" style="position:fixed; top:60px; right:32px; z-index:15;">
        <div class="minimap-player" id="minimapPlayer"></div>
    </div>

    <!-- 2. ìƒì  íŒì—… UI ì¶”ê°€ (body í•˜ë‹¨) -->
    <div id="shopPopup" class="glass-card" style="display:none; position:fixed; top:80px; left:50%; transform:translateX(-50%); z-index:200; min-width:340px; min-height:220px;">
        <h2 style="color:#222; margin-bottom:12px;">ìƒì  (XPë¡œ ì—…ê·¸ë ˆì´ë“œ)</h2>
        <div id="shopList" style="color:#222; font-size:15px; min-height:120px;"></div>
        <button id="closeShopButton" style="margin-top:18px;">ë‹«ê¸°</button>
    </div>

    <script>
        // GlassCombatArena ê²Œì„ í´ë˜ìŠ¤ ì •ì˜
        class GlassCombatArena {
            constructor() {
                // ìº”ë²„ìŠ¤ ë° 2D ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™”
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.resizeCanvas(); // ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì •
                
                // ê²Œì„ ìƒíƒœ ì´ˆê¸°í™”
                this.gameState = {
                    player: { // í”Œë ˆì´ì–´ ê°ì²´
                        x: this.canvas.width / 2, // ì´ˆê¸° X ìœ„ì¹˜ (ìº”ë²„ìŠ¤ ì¤‘ì•™)
                        y: this.canvas.height / 2, // ì´ˆê¸° Y ìœ„ì¹˜ (ìº”ë²„ìŠ¤ ì¤‘ì•™)
                        width: 40, // ë„ˆë¹„
                        height: 40, // ë†’ì´
                        vx: 0, // Xì¶• ì†ë„
                        vy: 0, // Yì¶• ì†ë„
                        health: 150, // í˜„ì¬ ì²´ë ¥ (150 -> 200ìœ¼ë¡œ ë³€ê²½)
                        maxHealth: 150, // ìµœëŒ€ ì²´ë ¥ (150 -> 200ìœ¼ë¡œ ë³€ê²½)
                        ammo: 30, // í˜„ì¬ íƒ„ì•½ (30ë°œë¡œ ê³ ì •)
                        maxAmmo: 30, // ìµœëŒ€ íƒ„ì•½ (30ë°œë¡œ ê³ ì •)
                        speed: 5, // ì´ë™ ì†ë„
                        jumpPower: 15, // ì í”„ë ¥
                        onGround: false, // ì§€ë©´ ì ‘ì´‰ ì—¬ë¶€
                        facing: 0, // ë°”ë¼ë³´ëŠ” ë°©í–¥ (ë¼ë””ì•ˆ)
                        expression: ':D', // í‘œì •
                        color: '#6366f1', // ìƒ‰ìƒ
                        baseDamage: 10, // ê¸°ë³¸ ê³µê²©ë ¥ (20 -> 25ë¡œ ìƒí–¥)
                        multishot: 1, // ë‹¤ì¤‘ ë°œì‚¬ íšŸìˆ˜
                        rapidFireTime: 0, // ì—°ë°œ ëª¨ë“œ ì¢…ë£Œ ì‹œê°„
                        damageReductionFactor: 1, // í”¼í•´ ê°ì†Œìœ¨ (1 = 100% í”¼í•´, 0.5 = 50% í”¼í•´)
                        shieldBoostEndTime: 0, // ì‰´ë“œ ê°•í™” ì¢…ë£Œ ì‹œê°„
                        healthRegenEndTime: 0, // ì²´ë ¥ ì¬ìƒ ì¢…ë£Œ ì‹œê°„
                        lastRegenTick: 0, // ë§ˆì§€ë§‰ ì²´ë ¥ ì¬ìƒ í‹± ì‹œê°„
                        magnetEndTime: 0, // ìì„ íš¨ê³¼ ì¢…ë£Œ ì‹œê°„
                        magnetRadius: 200, // ìì„ íš¨ê³¼ ë²”ìœ„
                        lastHitById: null, // ë§ˆì§€ë§‰ìœ¼ë¡œ í”Œë ˆì´ì–´ì—ê²Œ í”¼í•´ë¥¼ ì¤€ ì—”í‹°í‹°ì˜ ID
                        type: 'player', // í”Œë ˆì´ì–´ íƒ€ì… ì¶”ê°€
                        orbitingKnives: [], // íšŒì „ ì¹¼ë‚  ë°°ì—´ ì¶”ê°€
                        piercingShot: 0, // ê´€í†µ ì‚¬ê²© ë ˆë²¨ (0: ì—†ìŒ, 1+: ê´€í†µ íšŸìˆ˜)
                        explosiveShot: 0, // í­ë°œ ì‚¬ê²© ë ˆë²¨ (0: ì—†ìŒ, 1+: ë ˆë²¨)
                        ricochetLevel: 0, // ë„íƒ„ ì‚¬ê²© ë ˆë²¨
                        homingLevel: 0, // ìœ ë„ ì‚¬ê²© ë ˆë²¨
                        splitLevel: 0, // ë¶„ì—´ ì‚¬ê²© ë ˆë²¨
                        lifeStealPercent: 0, // ìƒëª…ë ¥ í¡ìˆ˜ìœ¨
                        critChance: 0, // ì¹˜ëª…íƒ€ í™•ë¥ 
                        critMultiplier: 1.5, // ì¹˜ëª…íƒ€ ë°°ìœ¨
                        cooldownReduction: 0, // ì¬ì‚¬ìš© ëŒ€ê¸°ì‹œê°„ ê°ì†Œìœ¨
                        armor: 0, // ë°©ì–´ë ¥ (ê³ ì • í”¼í•´ ê°ì†Œ)
                        timeStopEndTime: 0, // ì‹œê°„ ì •ì§€ ì¢…ë£Œ ì‹œê°„
                        ammoRegenEndTime: 0, // íƒ„ì•½ ì¬ìƒ ì¢…ë£Œ ì‹œê°„
                        lastAmmoRegenTick: 0, // ë§ˆì§€ë§‰ íƒ„ì•½ ì¬ìƒ í‹±
                        ammoRegenAmount: 0, // íƒ„ì•½ ì¬ìƒëŸ‰
                        dashCooldown: 0, // ë§ˆì§€ë§‰ ëŒ€ì‹œ ì‹œê°
                        dashEndTime: 0, // ëŒ€ì‹œ ì¢…ë£Œ ì‹œê°
                        isDashing: false, // ëŒ€ì‹œ ì¤‘ ì—¬ë¶€
                        reloadTime: 1500, // ê¸°ë³¸ ì¬ì¥ì „ ì‹œê°„(ms)
                        isReloading: false,
                        machineGunMode: false, // ê¸°ê´€ë‹¨ì´ íŒ¨ì‹œë¸Œ
                        machineGunPenalty: false, // ê¸°ê´€ë‹¨ì´ íŒ¨ë„í‹°
                        reloadPenalty: 0, // íŒ¨ì‹œë¸Œë¡œ ì¸í•œ ì¶”ê°€ ì¬ì¥ì „ ì‹œê°„(ms)
                        gunRecoil: 0,
                        gunRecoilTarget: 0,
                    },
                    enemies: [], // ì  ë°°ì—´
                    projectiles: [], // ë°œì‚¬ì²´ ë°°ì—´
                    items: [], // ì•„ì´í…œ ë°°ì—´
                    particles: [], // íŒŒí‹°í´ ë°°ì—´
                    floatingTexts: [], // ë– ë‹¤ë‹ˆëŠ” í…ìŠ¤íŠ¸ ë°°ì—´ (ì²´ë ¥ ë³€í™” ë“±)
                    allies: [], // ì•„êµ° ë°°ì—´ ì¶”ê°€
                    score: 0, // í˜„ì¬ ì ìˆ˜
                    wave: 1, // í˜„ì¬ ì›¨ì´ë¸Œ
                    gameStatus: 'start', // ê²Œì„ ìƒíƒœ ('start', 'playing', 'wave-complete', 'game-over', 'reward-selection')
                    message: '', // í˜„ì¬ í‘œì‹œë˜ëŠ” ë©”ì‹œì§€ í…ìŠ¤íŠ¸
                    messageTimer: 0, // ë©”ì‹œì§€ íƒ€ì´ë¨¸
                    playerSlowedEndTime: 0, // í”Œë ˆì´ì–´ ë‘”í™” íš¨ê³¼ ì¢…ë£Œ ì‹œê°„
                    timeSlowEndTime: 0, // ì‹œê°„ ë‘”í™” íš¨ê³¼ ì¢…ë£Œ ì‹œê°„ (ì  ëŠë ¤ì§)
                    timeSlowEffect: 1 // ì‹œê°„ ë‘”í™” íš¨ê³¼ (1 = ì •ìƒ ì†ë„, 0 = ì •ì§€)
                };
                
                // ì…ë ¥ ìƒíƒœ ì´ˆê¸°í™”
                this.keys = {}; // ëˆŒë¦° í‚¤ ìƒíƒœ ì €ì¥ ê°ì²´
                this.mouse = { x: 0, y: 0 }; // ë§ˆìš°ìŠ¤ í˜„ì¬ ìœ„ì¹˜
                
                // ê²Œì„ ìƒìˆ˜ ì •ì˜ (ë‚œì´ë„ ë° ê²Œì„ í”Œë ˆì´ ì¡°ì •)
                this.GRAVITY = 0.8; // ì¤‘ë ¥ ê°€ì†ë„
                this.FRICTION = 0.85; // ë§ˆì°° ê³„ìˆ˜
                this.GROUND_Y = 50; // ì§€ë©´ì˜ Y ì¢Œí‘œ (ìº”ë²„ìŠ¤ í•˜ë‹¨ìœ¼ë¡œë¶€í„°ì˜ ê±°ë¦¬)
                // ì‚¬ìš©ì ìš”ì²­ì— ë”°ë¼ í‘œì • ë°°ì—´ì— ': @' ì¶”ê°€
                this.EXPRESSIONS = [':D', ':>', ':<', ':O', ':/', ':#', 'XD', 'X>', ':V', ':@']; // ìºë¦­í„° í‘œì • ë°°ì—´
                
                // ì•„ì´í…œ íƒ€ì… ì •ì˜ (ìƒˆë¡œìš´ ì•„ì´í…œ ì¶”ê°€)
                this.ITEM_TYPES = [
                    { type: 'health', effect: 50, color: '#22c55e', emoji: 'â¤ï¸' }, // ì²´ë ¥ íšŒë³µ
                    { type: 'ammo', effect: 30, color: '#f59e0b', emoji: 'ğŸ”‹' }, // íƒ„ì•½ íšŒë³µ
                    { type: 'speed', effect: 2, color: '#8b5cf6', emoji: 'ğŸš€' }, // ì´ë™ ì†ë„ ì¦ê°€
                    { type: 'shield', effect: 50, color: '#3b82f6', emoji: 'ğŸ›¡ï¸' }, // ìµœëŒ€ ì²´ë ¥ ì¦ê°€
                    { type: 'damage', effect: 10, color: '#dc2626', emoji: 'âš”ï¸' }, // ê³µê²©ë ¥ ì¦ê°€
                    { type: 'multishot', effect: 3, color: '#7c3aed', emoji: 'ğŸ’¥' }, // ë‹¤ì¤‘ ë°œì‚¬
                    { type: 'megahealth', effect: 100, color: '#059669', emoji: 'ğŸ’š' }, // ëŒ€ëŸ‰ ì²´ë ¥ íšŒë³µ
                    { type: 'rapid', effect: 5, color: '#ea580c', emoji: 'âš¡' }, // ì—°ë°œ ëª¨ë“œ
                    { type: 'invincibility', effect: 5000, color: '#ffd700', emoji: 'âœ¨' }, // ë¬´ì  (5ì´ˆ)
                    { type: 'grenade', effect: 1, color: '#6b7280', emoji: 'ğŸ’£' }, // ìˆ˜ë¥˜íƒ„
                    { type: 'shield_boost', effect: 0.5, duration: 10000, color: '#87ceeb', emoji: 'ğŸ”µ' }, // ì‰´ë“œ ê°•í™” (10ì´ˆ, 50% í”¼í•´ ê°ì†Œ)
                    { type: 'time_slow', effect: 0.5, duration: 5000, color: '#800080', emoji: 'â³' }, // ì‹œê°„ ë‘”í™” (5ì´ˆ, 50% ëŠë ¤ì§)
                    { type: 'magnet', effect: 200, duration: 8000, color: '#8b4513', emoji: '  ' }, // ìì„ (8ì´ˆ, 200px ë²”ìœ„)
                    { type: 'health_regen', effect: 5, duration: 10000, tickInterval: 500, color: '#32cd32', emoji: 'âš•ï¸' }, // ì²´ë ¥ ì¬ìƒ (10ì´ˆ, 0.5ì´ˆë§ˆë‹¤ 5íšŒë³µ)
                    { type: 'ally_summon', effect: 1, color: '#90ee90', emoji: 'ğŸ¤–' }, // ì•„êµ° ì†Œí™˜ ì•„ì´í…œ
                    { type: 'orbiting_knife', effect: 1, color: '#c0c0c0', emoji: 'ğŸ”ª' }, // íšŒì „ ì¹¼ë‚  ì•„ì´í…œ
                    { type: 'piercing_shot', effect: 1, color: '#800080', emoji: 'âœ¨' }, // ê´€í†µ ì‚¬ê²© ì•„ì´í…œ
                    { type: 'explosive_shot', effect: 1, color: '#ff4500', emoji: 'ğŸ’¥' }, // í­ë°œ ì‚¬ê²© ì•„ì´í…œ
                    { type: 'ricochet_shot', effect: 1, color: '#00ced1', emoji: 'â†©ï¸' }, // ë„íƒ„ ì‚¬ê²©
                    { type: 'homing_shot', effect: 1, color: '#ff1493', emoji: 'ğŸ§­' }, // ìœ ë„ ì‚¬ê²©
                    { type: 'split_shot', effect: 1, color: '#9932cc', emoji: 'â•' }, // ë¶„ì—´ ì‚¬ê²©
                    { type: 'time_stop', effect: 3000, color: '#4b0082', emoji: 'ğŸ›‘' }, // ì‹œê°„ ì •ì§€ (3ì´ˆ)
                    { type: 'ammo_regen', effect: 10, duration: 5000, tickInterval: 200, color: '#ffd700', emoji: 'ğŸŸ¡' } // íƒ„ì•½ ì¬ìƒ (5ì´ˆ, 0.2ì´ˆë§ˆë‹¤ 10íšŒë³µ)
                ];
                
                // ì  íƒ€ì… ì •ì˜ (ìƒˆë¡œìš´ ì  ì¶”ê°€ë¨)
                this.ENEMY_TYPES = {
                    boss: {
                        name: 'ê¸€ë˜ìŠ¤ ë³´ìŠ¤',
                        health: 800,
                        speed: 2.5,
                        damage: 40,
                        color: '#ff007f',
                        size: 90,
                        shootInterval: 900,
                        points: 3000,
                        missileCooldown: 3000, lastMissile: 0, // ë¯¸ì‚¬ì¼ ë‚œì‚¬
                        teleportCooldown: 6000, lastTeleport: 0, // ìˆœê°„ì´ë™
                        explosionCooldown: 7000, lastExplosion: 0, // ê´‘ì—­ í­ë°œ
                        summonCooldown: 9000, lastSummon: 0, // ì†Œí™˜
                        shieldCooldown: 12000, lastShield: 0, shieldDuration: 3000, isInvincible: false, invincibleEndTime: 0, // ì‰´ë“œ
                        blackholeCooldown: 15000, lastBlackhole: 0, // ë¸”ë™í™€
                        description: 'ëª¨ë“  ë³´ìŠ¤ ëŠ¥ë ¥ì„ ê°€ì§„ ê¶ê·¹ì˜ ë³´ìŠ¤. ì›¨ì´ë¸Œê°€ ì˜¤ë¥¼ìˆ˜ë¡ ë”ìš± ê°•í•´ì§„ë‹¤.'
                    },
                    basic: {
                        name: 'ê¸°ë³¸ ì ', health: 40, speed: 2, damage: 15, color: '#ef4444', size: 35, shootInterval: 2000, points: 100
                    },
                    fast: {
                        name: 'ë¹ ë¥¸ ì ', health: 25, speed: 4, damage: 12, color: '#f97316', size: 30, shootInterval: 1500, points: 150
                    },
                    tank: {
                        name: 'íƒ±í¬ ì ', health: 80, speed: 1, damage: 25, color: '#7c3aed', size: 45, shootInterval: 3000, points: 250
                    },
                    sniper: {
                        name: 'ì €ê²©ìˆ˜', health: 30, speed: 1.5, damage: 30, color: '#06b6d4', size: 32, shootInterval: 4000, points: 200
                    },
                    bomber: {
                        name: 'í­ê²©ë³‘', health: 45, speed: 1.5, damage: 30, color: '#b91c1c', size: 38, shootInterval: 3000, points: 220
                    },
                    guardian: {
                        name: 'ìˆ˜í˜¸ì', health: 200, speed: 1.2, damage: 45, color: '#1e40af', size: 55, shootInterval: 1800, points: 400
                    },
                    assassin: {
                        name: 'ì•”ì‚´ì', health: 35, speed: 5, damage: 20, color: '#6b21a8', size: 28, shootInterval: 1200, points: 180
                    },
                    heavy: {
                        name: 'ì¤‘ì¥ë³‘', health: 100, speed: 0.8, damage: 40, color: '#92400e', size: 50, shootInterval: 2500, points: 300
                    },
                    ghost: {
                        name: 'ìœ ë ¹', health: 20, speed: 6, damage: 10, color: '#a8a29e', size: 25, shootInterval: 2500, points: 200, isInvincible: false, invincibilityDuration: 1000 // ìœ ë ¹ ì „ìš© ì†ì„±
                    },
                    medic: {
                        name: 'ì¹˜ìœ ì‚¬', health: 50, speed: 1.5, damage: 0, color: '#10b981', size: 30, shootInterval: 5000, points: 300, healAmount: 20, healRadius: 150 // ì¹˜ìœ ì‚¬ ì „ìš© ì†ì„±
                    },
                    summoner: {
                        name: 'ì†Œí™˜ì‚¬', health: 70, speed: 1, damage: 5, color: '#9333ea', size: 40, shootInterval: 8000, points: 400, summonCount: 1, summonType: 'basic' // ì†Œí™˜ì‚¬ ì „ìš© ì†ì„±
                    },
                    jumper: {
                        name: 'ì í¼', health: 30, speed: 3, damage: 18, color: '#facc15', size: 35, shootInterval: 2000, points: 120, jumpCooldown: 2000, lastJump: 0 // ì í¼ ì „ìš© ì†ì„±
                    },
                    shielded: {
                        name: 'ë°©íŒ¨ë³‘', health: 120, speed: 0.7, damage: 20, color: '#6b7280', size: 45, shootInterval: 2800, points: 280, shieldAngle: Math.PI / 3 // ë°©íŒ¨ë³‘ ì „ìš© ì†ì„±
                    },
                    teleporter: {
                        name: 'ìˆœê°„ì´ë™ë³‘', health: 35, speed: 1, damage: 25, color: '#a78bfa', size: 30, shootInterval: 3500, points: 220, teleportCooldown: 4000, lastTeleport: 0 // ìˆœê°„ì´ë™ë³‘ ì „ìš© ì†ì„±
                    },
                    drone: {
                        name: 'ë“œë¡ ', health: 20, speed: 7, damage: 10, color: '#94a3b8', size: 20, shootInterval: 1000, points: 80, flies: true // ë“œë¡  ì „ìš© ì†ì„±
                    },
                    spitter: {
                        name: 'ì¹¨ë±‰ëŠ”ë³‘', health: 50, speed: 1.3, damage: 15, color: '#16a34a', size: 35, shootInterval: 2500, points: 180, slowEffect: 0.5, slowDuration: 3000 // ì¹¨ë±‰ëŠ”ë³‘ ì „ìš© ì†ì„±
                    },
                    berserker: {
                        name: 'ê´‘ì „ì‚¬', health: 60, speed: 3, damage: 20, color: '#be123c', size: 38, shootInterval: 1800, points: 250, rageThreshold: 0.3, rageSpeedBoost: 1.5, rageDamageBoost: 1.5, isRaging: false // ê´‘ì „ì‚¬ ì „ìš© ì†ì„±
                    },
                    // ìƒˆë¡œìš´ ë³´ìŠ¤ íƒ€ì…
                    boss_alpha: {
                        name: 'ì•ŒíŒŒ ë³´ìŠ¤', health: 200, speed: 2, damage: 25, color: '#ff007f', size: 65, shootInterval: 1800, points: 700,
                        summonCooldown: 10000, lastSummon: 0, summonCount: 2, summonType: 'basic',
                        // ìŠ¤í‚¬1: ë¯¸ë‹ˆì–¸ ì†Œí™˜
                        dashCooldown: 7000, lastDash: 0, dashCount: 3, dashDuration: 300, isDashing: false,
                        // ìŠ¤í‚¬2: ì—°ì† ëŒì§„
                        shockwaveCooldown: 12000, lastShockwave: 0,
                        description: 'ë¯¸ë‹ˆì–¸ ì†Œí™˜, ì—°ì† ëŒì§„, ê´‘ì—­ ì¶©ê²©íŒŒ'
                    },
                    boss_beta: {
                        name: 'ë² íƒ€ ë³´ìŠ¤', health: 300, speed: 1.5, damage: 20, color: '#00ffff', size: 70, shootInterval: 2500, points: 800,
                        // ìŠ¤í‚¬1: ì‰´ë“œ(ë¬´ì )
                        shieldCooldown: 10000, lastShield: 0, shieldDuration: 3000, isInvincible: false, invincibleEndTime: 0,
                        // ìŠ¤í‚¬2: íƒ„ë§‰ ë°œì‚¬
                        barrageCooldown: 8000, lastBarrage: 0,
                        // ìŠ¤í‚¬3: ì²´ë ¥ íšŒë³µ
                        healCooldown: 14000, lastHeal: 0, healAmount: 60,
                        description: 'ì‰´ë“œ, íƒ„ë§‰, ì²´ë ¥ íšŒë³µ'
                    },
                    boss_gamma: {
                        name: 'ê°ë§ˆ ë³´ìŠ¤', health: 180, speed: 3.5, damage: 35, color: '#ff8c00', size: 60, shootInterval: 1000, points: 900,
                        // ìŠ¤í‚¬1: ìˆœê°„ì´ë™
                        teleportCooldown: 6000, lastTeleport: 0, teleportRange: 200,
                        // ìŠ¤í‚¬2: ë ˆì´ì €
                        laserCooldown: 9000, lastLaser: 0, laserDuration: 1200,
                        // ìŠ¤í‚¬3: ì†ë„ ë²„í”„
                        speedBuffCooldown: 12000, lastSpeedBuff: 0, speedBuffDuration: 3000, isSpeedBuffed: false,
                        description: 'ìˆœê°„ì´ë™, ë ˆì´ì €, ì†ë„ ë²„í”„'
                    },
                    boss_delta: {
                        name: 'ë¸íƒ€ ë³´ìŠ¤', health: 350, speed: 1.7, damage: 30, color: '#22223b', size: 80, shootInterval: 2000, points: 1200,
                        // ìŠ¤í‚¬1: ë¸”ë™í™€
                        blackholeCooldown: 9000, lastBlackhole: 0, blackholeRadius: 180,
                        // ìŠ¤í‚¬2: ê´‘ì—­ í­ë°œ
                        explosionCooldown: 11000, lastExplosion: 0,
                        // ìŠ¤í‚¬3: í”Œë ˆì´ì–´ ë‘”í™”
                        slowCooldown: 13000, lastSlow: 0, slowDuration: 3000,
                        description: 'ë¸”ë™í™€, ê´‘ì—­ í­ë°œ, í”Œë ˆì´ì–´ ë‘”í™”'
                    },
                    boss_epsilon: {
                        name: 'ì—¡ì‹¤ë¡  ë³´ìŠ¤', health: 320, speed: 2.2, damage: 22, color: '#fbbf24', size: 75, shootInterval: 1800, points: 1100,
                        // ìŠ¤í‚¬1: ë¶„ì‹  ìƒì„±
                        cloneCooldown: 10000, lastClone: 0, clones: 2, hasCloned: false,
                        // ìŠ¤í‚¬2: íƒ„í™˜ ë°˜ì‚¬
                        reflectCooldown: 9000, lastReflect: 0, reflectDuration: 2000, isReflecting: false,
                        // ìŠ¤í‚¬3: ì²´ë ¥ í¡ìˆ˜
                        drainCooldown: 12000, lastDrain: 0, drainAmount: 40,
                        description: 'ë¶„ì‹ , íƒ„í™˜ ë°˜ì‚¬, ì²´ë ¥ í¡ìˆ˜'
                    },
                    boss_zeta: {
                        name: 'ì œíƒ€ ë³´ìŠ¤', health: 300, speed: 2.5, damage: 28, color: '#06d6a0', size: 78, shootInterval: 1700, points: 1300,
                        // ìŠ¤í‚¬1: ì‹œê°„ ì™œê³¡(ìŠ¬ë¡œìš°)
                        timeWarpCooldown: 8000, lastTimeWarp: 0, timeWarpDuration: 2500, isTimeWarp: false,
                        // ìŠ¤í‚¬2: ì—°ë°œ ì‚¬ê²©
                        rapidFireCooldown: 9000, lastRapidFire: 0, rapidFireDuration: 2000, isRapidFire: false,
                        // ìŠ¤í‚¬3: ëœë¤ ìœ„ì¹˜ ì´ë™
                        randomMoveCooldown: 11000, lastRandomMove: 0,
                        description: 'ì‹œê°„ ì™œê³¡, ì—°ë°œ ì‚¬ê²©, ëœë¤ ì´ë™'
                    },
                    boss_eta: {
                        name: 'ì—íƒ€ ë³´ìŠ¤', health: 400, speed: 1.3, damage: 40, color: '#ff006e', size: 90, shootInterval: 3000, points: 1500,
                        // ìŠ¤í‚¬1: ë ˆì´ì €
                        laserCooldown: 7000, lastLaser: 0, laserDuration: 1200,
                        // ìŠ¤í‚¬2: ì—°ì† ì í”„
                        jumpCooldown: 9000, lastJump: 0, jumpCount: 3, jumpPower: 30,
                        // ìŠ¤í‚¬3: ë°©ì–´ë ¥ ì¦ê°€
                        armorBuffCooldown: 12000, lastArmorBuff: 0, armorBuffDuration: 4000, isArmorBuffed: false,
                        description: 'ë ˆì´ì €, ì—°ì† ì í”„, ë°©ì–´ë ¥ ì¦ê°€'
                    },
                    boss_theta: {
                        name: 'ì„íƒ€ ë³´ìŠ¤', health: 370, speed: 1.8, damage: 26, color: '#3a86ff', size: 85, shootInterval: 2100, points: 1250,
                        // ìŠ¤í‚¬1: ë°œì‚¬ì²´ ë°˜ì‚¬
                        reflectAllCooldown: 10000, lastReflectAll: 0, reflectAllDuration: 2000, isReflecting: false,
                        // ìŠ¤í‚¬2: ë„íƒ„ íƒ„í™˜
                        ricochetCooldown: 9000, lastRicochet: 0, ricochetCount: 5,
                        // ìŠ¤í‚¬3: í”Œë ˆì´ì–´ ìœ„ì¹˜ ì¶”ì 
                        trackCooldown: 11000, lastTrack: 0, trackDuration: 2000, isTracking: false,
                        description: 'ë°œì‚¬ì²´ ë°˜ì‚¬, ë„íƒ„, ìœ„ì¹˜ ì¶”ì '
                    },
                    // === ì‹ ê·œ ì  10ì¢… ===
                    mirror: {
                        name: 'ë¯¸ëŸ¬ ì ', health: 35, speed: 2.5, damage: 15, color: '#b6e0fe', size: 32, shootInterval: 1800, points: 180, mirrorPlayer: true // í”Œë ˆì´ì–´ ì›€ì§ì„ ë”°ë¼í•¨
                    },
                    leech: {
                        name: 'í¡í˜ˆ ì ', health: 30, speed: 2, damage: 10, color: '#a21caf', size: 30, shootInterval: 2000, points: 160, leechAmount: 10 // ë‹¿ìœ¼ë©´ ì²´ë ¥ í¡ìˆ˜
                    },
                    mine: {
                        name: 'ì§€ë¢° ì ', health: 20, speed: 1, damage: 40, color: '#fbbf24', size: 28, shootInterval: 99999, points: 120, explodesOnNear: true, explodeRadius: 60 // ê·¼ì ‘ í­ë°œ
                    },
                    freezer: {
                        name: 'ë¹™ê²° ì ', health: 28, speed: 1.7, damage: 12, color: '#38bdf8', size: 30, shootInterval: 2200, points: 150, freezeOnHit: true, freezeDuration: 2000 // ë§ìœ¼ë©´ ë¹™ê²°
                    },
                    reflector: {
                        name: 'ë°˜ì‚¬ ì ', health: 40, speed: 1.5, damage: 15, color: '#f472b6', size: 34, shootInterval: 2500, points: 200, reflectChance: 0.3 // 30% í™•ë¥ ë¡œ íƒ„í™˜ ë°˜ì‚¬
                    },
                    healer: {
                        name: 'íëŸ¬ ì ', health: 32, speed: 1.2, damage: 0, color: '#bef264', size: 32, shootInterval: 4000, points: 180, healAmount: 15, healRadius: 120, healsOthers: true // ì£¼ë³€ ì  íšŒë³µ
                    },
                    portal: {
                        name: 'í¬íƒˆ ì ', health: 30, speed: 2.2, damage: 13, color: '#818cf8', size: 30, shootInterval: 2000, points: 170, teleportsNearPlayer: true, teleportCooldown: 3000, lastTeleport: 0 // ìˆœê°„ì´ë™
                    },
                    exploder: {
                        name: 'í­ë°œ ì ', health: 25, speed: 2, damage: 18, color: '#f87171', size: 28, shootInterval: 99999, points: 140, explodesOnDeath: true, explodeRadius: 70 // ì£½ìœ¼ë©´ í­ë°œ
                    },
                    magnet: {
                        name: 'ìì„ ì ', health: 30, speed: 1.8, damage: 10, color: '#fde047', size: 30, shootInterval: 2000, points: 160, pullsItems: true, magnetRadius: 180 // ì•„ì´í…œ ëŒì–´ë‹¹ê¹€
                    },
                    curse: {
                        name: 'ì €ì£¼ ì ', health: 28, speed: 1.6, damage: 10, color: '#a3a3a3', size: 30, shootInterval: 2200, points: 170, cursesPlayer: true, curseDuration: 2500 // ë§ì¶”ë©´ ë””ë²„í”„
                    },
                    // === ì‹ ê·œ ë³´ìŠ¤ 5ì¢… ===
                    boss_delta: {
                        name: 'ë¸íƒ€ ë³´ìŠ¤', health: 350, speed: 1.7, damage: 30, color: '#22223b', size: 80, shootInterval: 2000, points: 1200, blackholeCooldown: 9000, lastBlackhole: 0, blackholeRadius: 180 // ë¸”ë™í™€ ìƒì„±
                    },
                    boss_epsilon: {
                        name: 'ì—¡ì‹¤ë¡  ë³´ìŠ¤', health: 320, speed: 2.2, damage: 22, color: '#fbbf24', size: 75, shootInterval: 1800, points: 1100, cloneThreshold: 0.5, clones: 3, hasCloned: false // ë¶„ì‹  ìƒì„±
                    },
                    boss_zeta: {
                        name: 'ì œíƒ€ ë³´ìŠ¤', health: 300, speed: 2.5, damage: 28, color: '#06d6a0', size: 78, shootInterval: 1700, points: 1300, timeWarpCooldown: 8000, lastTimeWarp: 0 // ì‹œê°„ ì™œê³¡
                    },
                    boss_eta: {
                        name: 'ì—íƒ€ ë³´ìŠ¤', health: 400, speed: 1.3, damage: 40, color: '#ff006e', size: 90, shootInterval: 3000, points: 1500, laserCooldown: 7000, lastLaser: 0, laserDuration: 1200 // ë ˆì´ì € ë°œì‚¬
                    },
                    boss_theta: {
                        name: 'ì„íƒ€ ë³´ìŠ¤', health: 370, speed: 1.8, damage: 26, color: '#3a86ff', size: 85, shootInterval: 2100, points: 1250, reflectAllCooldown: 10000, lastReflectAll: 0, reflectAllDuration: 2000 // ë°œì‚¬ì²´ ë°˜ì‚¬
                    },
                    // === ìƒˆë¡œìš´ ì  3ì¢… ì¶”ê°€ ===
                    juggernaut: {
                        name: 'ì €ê±°ë„ˆíŠ¸', health: 800, speed: 1.2, damage: 8, color: '#444444', size: 60, shootInterval: 3000, points: 600, description: 'ê³µê²©ë ¥ì€ ì•½í•˜ì§€ë§Œ ì—„ì²­ë‚œ ì²´ë ¥ì„ ìë‘í•˜ëŠ” ê±°ëŒ€ ì .'
                    },
                    // ê³µì¤‘ë¶€ì–‘ ì 
                    floater: {
                        name: 'í”Œë¡œí„°', health: 60, speed: 2.5, damage: 18, color: '#00e6e6', size: 32, shootInterval: 1800, points: 220, flies: true, description: 'ì§€ìƒ ì¥ì• ë¬¼ ë¬´ì‹œ, ê³µì¤‘ì—ì„œ ë¶€ìœ í•˜ë©° ì´ë™í•˜ëŠ” ì .'
                    },
                    // íŠ¹ì´íŒ¨í„´ ì (ì£¼ê¸°ì  ë¬´ì )
                    phaser: {
                        name: 'í˜ì´ì €', health: 70, speed: 2, damage: 22, color: '#ff00cc', size: 34, shootInterval: 2000, points: 300, isInvincible: false, phaseInterval: 2000, lastPhase: 0, description: 'ì£¼ê¸°ì ìœ¼ë¡œ ì ì‹œ ë¬´ì ì´ ë˜ëŠ” íŠ¹ìˆ˜ ì .'
                    },
                    // ì°¸ì‹ í•œ í•˜ëŠ˜ ëª¹ (íƒ„ë§‰)
                    skyblaster: {
                        name: 'ìŠ¤ì¹´ì´ë¸”ë˜ìŠ¤í„°',
                        health: 90,
                        speed: 3.2,
                        damage: 14,
                        color: '#00bfff',
                        size: 36,
                        shootInterval: 1400,
                        points: 350,
                        flies: true,
                        multishot: 6, // í•œ ë²ˆì— 6ë°œ í¼ëœ¨ë¦¼
                        spread: Math.PI / 2, // 90ë„ ë²”ìœ„ë¡œ í¼ì§
                        description: 'í•˜ëŠ˜ì„ ë‚ ë©° í•œ ë²ˆì— ì—¬ëŸ¬ ë°œì˜ ì´ì•Œì„ í¼ëœ¨ë¦¬ëŠ” ì°¸ì‹ í•œ íƒ„ë§‰ ëª¹.'
                    },
                    melee: {
                        name: 'ê·¼ì ‘ ê³µê²©',
                        health: 0,
                        speed: 0,
                        damage: 0,
                        color: '#f59e42',
                        size: 0,
                        shootInterval: 0,
                        points: 0,
                        description: 'ê·¼ì ‘ ê³µê²© ë¬´ê¸°'
                    }
                };

                // ë³´ìƒ ì˜µì…˜ ì •ì˜
                this.REWARD_OPTIONS = [
                    { text: '+100 ìµœëŒ€ ì²´ë ¥', type: 'maxHealth', value: 100 },
                    { text: '+50 í˜„ì¬ ì²´ë ¥', type: 'currentHealth', value: 50 },
                    { text: '+5 ê³µê²©ë ¥', type: 'damage', value: 5 },
                    { text: '+1 ì´ë™ ì†ë„', type: 'speed', value: 1 },
                    { text: '+1 ë‹¤ì¤‘ ë°œì‚¬', type: 'multishot', value: 1 },
                    { text: 'íšŒì „ ì¹¼ë‚ ', type: 'orbiting_knife', value: 1 }, // ë³´ìƒìœ¼ë¡œ íšŒì „ ì¹¼ë‚  ì¶”ê°€
                    { text: 'ê´€í†µ ì‚¬ê²©', type: 'piercing_shot', value: 1 }, // ë³´ìƒìœ¼ë¡œ ê´€í†µ ì‚¬ê²© ì¶”ê°€
                    { text: 'í­ë°œ ì‚¬ê²©', type: 'explosive_shot', value: 1 }, // ë³´ìƒìœ¼ë¡œ í­ë°œ ì‚¬ê²© ì¶”ê°€
                    { text: 'ë„íƒ„ ì‚¬ê²©', type: 'ricochet_shot', value: 1 }, // ë³´ìƒìœ¼ë¡œ ë„íƒ„ ì‚¬ê²© ì¶”ê°€
                    { text: 'ìœ ë„ ì‚¬ê²©', type: 'homing_shot', value: 1 }, // ë³´ìƒìœ¼ë¡œ ìœ ë„ ì‚¬ê²© ì¶”ê°€
                    { text: 'ë¶„ì—´ ì‚¬ê²©', type: 'split_shot', value: 1 }, // ë³´ìƒìœ¼ë¡œ ë¶„ì—´ ì‚¬ê²© ì¶”ê°€
                    { text: 'ìƒëª…ë ¥ í¡ìˆ˜', type: 'life_steal', value: 0.02 }, // ìƒëª…ë ¥ í¡ìˆ˜ ì¶”ê°€ (2%)
                    { text: 'ì¹˜ëª…íƒ€ í™•ë¥ ', type: 'crit_chance', value: 0.05 }, // ì¹˜ëª…íƒ€ í™•ë¥  ì¶”ê°€ (5%)
                    { text: 'ì¬ì‚¬ìš© ëŒ€ê¸°ì‹œê°„ ê°ì†Œ', type: 'cooldown_reduction', value: 0.05 }, // ì¬ì‚¬ìš© ëŒ€ê¸°ì‹œê°„ ê°ì†Œ (5%)
                    { text: 'ë°©ì–´ë ¥', type: 'armor', value: 5 }, // ë°©ì–´ë ¥ ì¶”ê°€ (5)
                    { text: 'ì‹œê°„ ì •ì§€', type: 'time_stop', value: 3000 }, // ì‹œê°„ ì •ì§€ ì•„ì´í…œ
                    { text: 'íƒ„ì•½ ì¬ìƒ', type: 'ammo_regen', value: 10 } // íƒ„ì•½ ì¬ìƒ ì•„ì´í…œ
                ];
                
                // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
                this.setupEventListeners();
                this.xp = 0;

                // GlassCombatArena ìƒì„±ì ë‚´ë¶€ì— ì¶”ê°€
                this.upgrades = { gun: 0, melee: 0, health: 0, speed: 0, cooldown: 0 };
                this.scoreMilestones = [1000, 2000, 3000, 5000, 8000, 12000, 18000, 25000, 35000, 50000];
                this.nextMilestoneIndex = 0;

                // 1. SHOP_ITEMSë¥¼ JSì— ëª…í™•íˆ ì •ì˜ (GlassCombatArena í´ë˜ìŠ¤ ë‚´ constructorì— ì¶”ê°€)
                this.SHOP_ITEMS = [
                    { text: '+100 ìµœëŒ€ ì²´ë ¥', type: 'maxHealth', value: 100, price: 1000 },
                    { text: '+50 í˜„ì¬ ì²´ë ¥', type: 'currentHealth', value: 50, price: 700 },
                    { text: '+5 ê³µê²©ë ¥', type: 'damage', value: 5, price: 1200 },
                    { text: '+1 ì´ë™ ì†ë„', type: 'speed', value: 1, price: 900 },
                    { text: '+1 ë‹¤ì¤‘ ë°œì‚¬', type: 'multishot', value: 1, price: 1500 },
                    { text: 'íšŒì „ ì¹¼ë‚ ', type: 'orbiting_knife', value: 1, price: 2000 },
                    { text: 'ê´€í†µ ì‚¬ê²©', type: 'piercing_shot', value: 1, price: 1800 },
                    { text: 'í­ë°œ ì‚¬ê²©', type: 'explosive_shot', value: 1, price: 1800 },
                    { text: 'ë„íƒ„ ì‚¬ê²©', type: 'ricochet_shot', value: 1, price: 1800 },
                    { text: 'ìœ ë„ ì‚¬ê²©', type: 'homing_shot', value: 1, price: 1800 },
                    { text: 'ë¶„ì—´ ì‚¬ê²©', type: 'split_shot', value: 1, price: 1800 },
                    { text: 'í¡í˜ˆ', type: 'life_steal', value: 0.05, price: 2200 },
                    { text: 'ì¹˜ëª…íƒ€ í™•ë¥ ', type: 'crit_chance', value: 0.05, price: 2000 },
                    { text: 'ì¬ì‚¬ìš© ëŒ€ê¸°ì‹œê°„ ê°ì†Œ', type: 'cooldown_reduction', value: 0.05, price: 2000 },
                    { text: 'ë°©ì–´ë ¥', type: 'armor', value: 5, price: 2000 },
                    { text: 'íƒ„ì•½ ìë™ íšŒë³µ', type: 'ammo_regen', value: 1, price: 1800 }
                ];


            }
            
            // ìº”ë²„ìŠ¤ í¬ê¸°ë¥¼ ì°½ í¬ê¸°ì— ë§ê²Œ ì¡°ì •
            resizeCanvas = () => {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }
            
            // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì • (í‚¤ë³´ë“œ, ë§ˆìš°ìŠ¤, ì°½ í¬ê¸° ì¡°ì •)
            setupEventListeners = () => {
                // í‚¤ë³´ë“œ ì…ë ¥ ì²˜ë¦¬
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    if (e.key === ' ') e.preventDefault(); // ìŠ¤í˜ì´ìŠ¤ë°” ê¸°ë³¸ ë™ì‘ ë°©ì§€ (ìŠ¤í¬ë¡¤)
                    if (e.key.toLowerCase() === 'e') this.tryDash();
                    if (e.key === '1') this.currentWeapon = 'gun';
                    if (e.key === '2') this.currentWeapon = 'melee';
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });
                
                // ë§ˆìš°ìŠ¤ ì…ë ¥ ì²˜ë¦¬
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouse.x = e.clientX - rect.left;
                    this.mouse.y = e.clientY - rect.top;
                });
                
                this.canvas.addEventListener('click', (e) => {
                    if (this.gameState.gameStatus === 'playing') {
                        this.shoot(); // ê²Œì„ í”Œë ˆì´ ì¤‘ì¼ ë•Œë§Œ ë°œì‚¬
                    } else if (e.button === 0 && this.gameState.gameStatus === 'start') {
                        // ì‹œì‘ í™”ë©´ì—ì„œ í´ë¦­ ì‹œ ì‹œì‘ ë²„íŠ¼ í´ë¦­ê³¼ ë™ì¼í•˜ê²Œ ì²˜ë¦¬ (ì„ íƒ ì‚¬í•­)
                        // document.getElementById('startButton').click();
                    } else if (e.button === 0 && this.gameState.gameStatus === 'game-over') {
                        // ê²Œì„ ì˜¤ë²„ í™”ë©´ì—ì„œ í´ë¦­ ì‹œ ì¬ì‹œì‘ (ì„ íƒ ì‚¬í•­)
                        // this.resetGame();
                    }
                });
                
                // ì°½ í¬ê¸° ì¡°ì • ì‹œ ìº”ë²„ìŠ¤ í¬ê¸° ì¬ì¡°ì •
                window.addEventListener('resize', this.resizeCanvas);

                // ì‹œì‘ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
                document.getElementById('startButton').addEventListener('click', this.startGame);
            }

            // ì‹œì‘ í™”ë©´ í‘œì‹œ (ìº”ë²„ìŠ¤ ë¸”ëŸ¬ ì²˜ë¦¬)
            showStartScreen = () => {
                this.canvas.style.filter = 'blur(10px)'; // ìº”ë²„ìŠ¤ ë¸”ëŸ¬ ì²˜ë¦¬
                this.canvas.style.display = 'block'; // ìº”ë²„ìŠ¤ ë³´ì´ê²Œ
                document.querySelector('.hud').style.display = 'none'; // HUD ìˆ¨ê¹€
                document.getElementById('startScreen').style.display = 'flex'; // ì‹œì‘ í™”ë©´ í‘œì‹œ
                document.getElementById('rewardSelectionScreen').style.display = 'none'; // ë³´ìƒ í™”ë©´ ìˆ¨ê¹€
            }

            // ê²Œì„ ì‹œì‘
            startGame = () => {
                this.canvas.style.filter = 'blur(0px)'; // ìº”ë²„ìŠ¤ ë¸”ëŸ¬ ì œê±°
                document.getElementById('startScreen').style.display = 'none'; // ì‹œì‘ í™”ë©´ ìˆ¨ê¹€
                document.querySelector('.hud').style.display = 'flex'; // HUD í‘œì‹œ (flexë¡œ ë³€ê²½)
                document.getElementById('rewardSelectionScreen').style.display = 'none'; // ë³´ìƒ í™”ë©´ ìˆ¨ê¹€

                // ê²Œì„ ìƒíƒœ ì´ˆê¸°í™” (resetGameê³¼ ìœ ì‚¬)
                this.gameState = {
                    player: {
                        x: this.canvas.width / 2, y: this.canvas.height / 2,
                        width: 40, height: 40,
                        vx: 0, vy: 0,
                        health: 150, maxHealth: 150, // ê¸°ë³¸ê°’ 100ìœ¼ë¡œ ë³€ê²½
                        ammo: 30, maxAmmo: 30, // ê¸°ë³¸ê°’ 100ìœ¼ë¡œ ë³€ê²½
                        speed: 5, jumpPower: 15,
                        onGround: false, facing: 0,
                        expression: this.getRandomExpression(),
                        color: '#6366f1',
                        baseDamage: 10, // ê¸°ë³¸ê°’ 10ìœ¼ë¡œ ë³€ê²½
                        multishot: 1,
                        rapidFireTime: 0,
                        damageReductionFactor: 1,
                        shieldBoostEndTime: 0,
                        healthRegenEndTime: 0,
                        lastRegenTick: 0,
                        magnetEndTime: 0,
                        magnetRadius: 200,
                        lastHitById: null, // ì´ˆê¸°í™”
                        type: 'player', // í”Œë ˆì´ì–´ íƒ€ì…
                        orbitingKnives: [], // íšŒì „ ì¹¼ë‚  ì´ˆê¸°í™”
                        piercingShot: 0, // ê´€í†µ ì‚¬ê²© ì´ˆê¸°í™”
                        explosiveShot: 0, // í­ë°œ ì‚¬ê²© ì´ˆê¸°í™”
                        ricochetLevel: 0, // ë„íƒ„ ì‚¬ê²© ì´ˆê¸°í™”
                        homingLevel: 0, // ìœ ë„ ì‚¬ê²© ì´ˆê¸°í™”
                        splitLevel: 0, // ë¶„ì—´ ì‚¬ê²© ì´ˆê¸°í™”
                        lifeStealPercent: 0, // ìƒëª…ë ¥ í¡ìˆ˜ ì´ˆê¸°í™”
                        critChance: 0, // ì¹˜ëª…íƒ€ í™•ë¥  ì´ˆê¸°í™”
                        critMultiplier: 1.5, // ì¹˜ëª…íƒ€ ë°°ìœ¨ ì´ˆê¸°í™”
                        cooldownReduction: 0, // ì¬ì‚¬ìš© ëŒ€ê¸°ì‹œê°„ ê°ì†Œ ì´ˆê¸°í™”
                        armor: 0, // ë°©ì–´ë ¥ ì´ˆê¸°í™”
                        timeStopEndTime: 0, // ì‹œê°„ ì •ì§€ ì´ˆê¸°í™”
                        ammoRegenEndTime: 0, // íƒ„ì•½ ì¬ìƒ ì´ˆê¸°í™”
                        lastAmmoRegenTick: 0, // ë§ˆì§€ë§‰ íƒ„ì•½ ì¬ìƒ í‹± ì´ˆê¸°í™”
                        ammoRegenAmount: 0, // íƒ„ì•½ ì¬ìƒëŸ‰ ì´ˆê¸°í™”
                        dashCooldown: 0, // ë§ˆì§€ë§‰ ëŒ€ì‹œ ì‹œê°
                        dashEndTime: 0, // ëŒ€ì‹œ ì¢…ë£Œ ì‹œê°
                        isDashing: false, // ëŒ€ì‹œ ì¤‘ ì—¬ë¶€
                        reloadTime: 1500, // ê¸°ë³¸ ì¬ì¥ì „ ì‹œê°„(ms)
                        isReloading: false,
                        machineGunMode: false, // ê¸°ê´€ë‹¨ì´ íŒ¨ì‹œë¸Œ
                        machineGunPenalty: false, // ê¸°ê´€ë‹¨ì´ íŒ¨ë„í‹°
                        reloadPenalty: 0, // íŒ¨ì‹œë¸Œë¡œ ì¸í•œ ì¶”ê°€ ì¬ì¥ì „ ì‹œê°„(ms)
                        gunRecoil: 0,
                        gunRecoilTarget: 0,
                    },
                    enemies: [],
                    projectiles: [],
                    items: [],
                    particles: [],
                    floatingTexts: [],
                    allies: [], // ì•„êµ° ë°°ì—´ ì´ˆê¸°í™”
                    score: 0,
                    wave: 1,
                    gameStatus: 'playing',
                    message: '',
                    messageTimer: 0,
                    playerSlowedEndTime: 0,
                    timeSlowEndTime: 0,
                    timeSlowEffect: 1
                };
                
                this.spawnInitialWave(); // ì´ˆê¸° ì›¨ì´ë¸Œ ìƒì„±
                this.gameLoop(); // ê²Œì„ ë£¨í”„ ì‹œì‘
                this.updateHUD(); // HUD ì´ˆê¸° ì—…ë°ì´íŠ¸
                this.hideMessage(); // ë©”ì‹œì§€ ìˆ¨ê¸°ê¸°

                // === startGame í•¨ìˆ˜ ë‚´ë¶€ì— ì¶”ê°€ ===
                this.currentWeapon = 'gun'; // ê²Œì„ ì‹œì‘ ì‹œ ë¬´ê¸° ì´ˆê¸°í™”
                this.upgrades = { gun: 0, melee: 0, health: 0, speed: 0, cooldown: 0 };
            }
            
            // ë¬´ì‘ìœ„ í‘œì • ë°˜í™˜
            getRandomExpression = () => {
                if (this.EXPRESSIONS && this.EXPRESSIONS.length > 0) {
                    return this.EXPRESSIONS[Math.floor(Math.random() * this.EXPRESSIONS.length)];
                }
                return ':)'; // í‘œì • ë°°ì—´ì´ ë¹„ì–´ìˆëŠ” ê²½ìš°ë¥¼ ìœ„í•œ ê¸°ë³¸ í‘œì •
            }
            
            // í˜„ì¬ ì›¨ì´ë¸Œì— ë”°ë¼ ì  íƒ€ì… ê²°ì • (ìƒˆë¡œìš´ ì  ë“±ì¥ ë¡œì§ ì¶”ê°€)
            getEnemyTypeForWave = (wave) => {
                const bossTypes = [
                    'boss_alpha','boss_beta','boss_gamma','boss_delta','boss_epsilon','boss_zeta','boss_eta','boss_theta'
                ];
                if (wave % 10 === 0) {
                    return bossTypes[Math.floor(Math.random() * bossTypes.length)];
                }
                // ì¼ë°˜ ì›¨ì´ë¸Œ ì  ìƒì„± ë¡œì§
                if (wave <= 2) {
                    return 'basic';
                } else if (wave <= 5) {
                    const rand = Math.random();
                    if (rand < 0.4) return 'basic';
                    else if (rand < 0.7) return 'fast';
                    else return 'jumper';
                } else if (wave <= 8) {
                    const rand = Math.random();
                    if (rand < 0.2) return 'basic';
                    else if (rand < 0.35) return 'fast';
                    else if (rand < 0.5) return 'tank';
                    else if (rand < 0.65) return 'assassin';
                    else if (rand < 0.75) return 'jumper';
                    else if (rand < 0.85) return 'teleporter';
                    else return 'drone';
                } else if (wave <= 12) {
                    const rand = Math.random();
                    if (rand < 0.1) return 'basic';
                    else if (rand < 0.18) return 'fast';
                    else if (rand < 0.26) return 'tank';
                    else if (rand < 0.34) return 'sniper';
                    else if (rand < 0.42) return 'assassin';
                    else if (rand < 0.50) return 'heavy';
                    else if (rand < 0.58) return 'bomber';
                    else if (rand < 0.66) return 'jumper';
                    else if (rand < 0.74) return 'teleporter';
                    else if (rand < 0.82) return 'drone';
                    else if (rand < 0.90) return 'spitter';
                    else return 'berserker';
                } else if (wave <= 15) {
                    const rand = Math.random();
                    if (rand < 0.05) return 'basic';
                    else if (rand < 0.10) return 'fast';
                    else if (rand < 0.15) return 'tank';
                    else if (rand < 0.20) return 'sniper';
                    else if (rand < 0.25) return 'assassin';
                    else if (rand < 0.30) return 'heavy';
                    else if (rand < 0.35) return 'bomber';
                    else if (rand < 0.40) return 'guardian';
                    else if (rand < 0.45) return 'ghost';
                    else if (rand < 0.50) return 'medic';
                    else if (rand < 0.55) return 'summoner';
                    else if (rand < 0.60) return 'jumper';
                    else if (rand < 0.65) return 'shielded';
                    else if (rand < 0.70) return 'teleporter';
                    else if (rand < 0.75) return 'drone';
                    else if (rand < 0.80) return 'spitter';
                    else if (rand < 0.85) return 'berserker';
                    else if (rand < 0.88) return 'mirror';
                    else if (rand < 0.90) return 'leech';
                    else if (rand < 0.92) return 'mine';
                    else if (rand < 0.94) return 'freezer';
                    else if (rand < 0.96) return 'reflector';
                    else if (rand < 0.98) return 'healer';
                    else if (rand < 0.99) return 'portal';
                    else return 'exploder';
                } else {
                    // 15ì›¨ì´ë¸Œ ì´ìƒ: ì‹ ê·œ ì  í™•ë¥  ëŒ€í­ ì¦ê°€
                    const rand = Math.random();
                    if (rand < 0.03) return 'basic';
                    else if (rand < 0.06) return 'fast';
                    else if (rand < 0.09) return 'tank';
                    else if (rand < 0.12) return 'sniper';
                    else if (rand < 0.15) return 'assassin';
                    else if (rand < 0.18) return 'heavy';
                    else if (rand < 0.21) return 'bomber';
                    else if (rand < 0.24) return 'guardian';
                    else if (rand < 0.27) return 'ghost';
                    else if (rand < 0.30) return 'medic';
                    else if (rand < 0.33) return 'summoner';
                    else if (rand < 0.36) return 'jumper';
                    else if (rand < 0.39) return 'shielded';
                    else if (rand < 0.42) return 'teleporter';
                    else if (rand < 0.45) return 'drone';
                    else if (rand < 0.48) return 'spitter';
                    else if (rand < 0.51) return 'berserker';
                    else if (rand < 0.58) return 'mirror';
                    else if (rand < 0.63) return 'leech';
                    else if (rand < 0.68) return 'mine';
                    else if (rand < 0.73) return 'freezer';
                    else if (rand < 0.78) return 'reflector';
                    else if (rand < 0.83) return 'healer';
                    else if (rand < 0.88) return 'portal';
                    else if (rand < 0.93) return 'exploder';
                    else if (rand < 0.96) return 'magnet';
                    else return 'curse';
                }
            }
            
            // ìƒˆë¡œìš´ ì  ê°ì²´ ìƒì„±
            createEnemy = (enemyType = null) => {
                const side = Math.random() < 0.5 ? 'left' : 'right';
                const x = side === 'left' ? -50 : this.canvas.width + 50;
                const y = Math.random() * (this.canvas.height - 200);
                let type;
                if (this.gameState.wave % 10 === 0) {
                    type = 'boss';
                } else {
                    type = enemyType || this.getEnemyTypeForWave(this.gameState.wave);
                }
                let enemyData = { ...this.ENEMY_TYPES[type] };
                // ìŠ¤ì¼€ì¼ë§: ì›¨ì´ë¸Œê°€ ì˜¤ë¥¼ìˆ˜ë¡ ì²´ë ¥/ê³µê²©ë ¥/ì†ë„ ì¦ê°€ (ë³´ìŠ¤ëŠ” ë” ê°•í•˜ê²Œ)
                if (type === 'boss') {
                    const scale = 1 + (this.gameState.wave / 12); // 20% ì™„í™”
                    enemyData.health = Math.floor(enemyData.health * scale * 0.8);
                    enemyData.maxHealth = enemyData.health;
                    enemyData.speed = enemyData.speed * (1 + (this.gameState.wave / 36)); // 20% ì™„í™”
                    enemyData.damage = Math.floor(enemyData.damage * scale * 0.8);
                    enemyData.points = Math.floor(enemyData.points * scale);
                    // ìŠ¤í‚¬ ì¿¨íƒ€ì„ ì´ˆê¸°í™”
                    enemyData.lastMissile = 0;
                    enemyData.lastTeleport = 0;
                    enemyData.lastExplosion = 0;
                    enemyData.lastSummon = 0;
                    enemyData.lastShield = 0;
                    enemyData.lastBlackhole = 0;
                    enemyData.isInvincible = false;
                    enemyData.invincibleEndTime = 0;
                    this.showMessage('ë³´ìŠ¤ê°€ ë“±ì¥í–ˆìŠµë‹ˆë‹¤!', enemyData.name, 2000);
                } else {
                    const scale = 1 + (this.gameState.wave - 1) * 0.12; // 20% ì™„í™”
                    enemyData.health = Math.floor(enemyData.health * scale * 0.8);
                    enemyData.maxHealth = enemyData.health;
                    enemyData.speed = enemyData.speed * (1 + (this.gameState.wave - 1) * 0.04); // 20% ì™„í™”
                    enemyData.damage = Math.floor(enemyData.damage * scale * 0.8);
                    enemyData.points = Math.floor(enemyData.points * scale);
                }
                // ì‹ ê·œ ì /ë³´ìŠ¤ ë“±ì¥ ë©”ì‹œì§€
                const newTypes = [
                    'mirror','leech','mine','freezer','reflector','healer','portal','exploder','magnet','curse',
                    'boss_delta','boss_epsilon','boss_zeta','boss_eta','boss_theta'
                ];
                if (newTypes.includes(type)) {
                    this.showMessage(`${this.ENEMY_TYPES[type].name} ë“±ì¥!`, 'ìƒˆë¡œìš´ ìœ„í˜‘ì´ ë‚˜íƒ€ë‚¬ìŠµë‹ˆë‹¤!', 3000);
                }

                // ì  ê°ì²´ ë°˜í™˜
                return {
                    id: Date.now() + Math.random(), // ê³ ìœ  ID
                    type: type, // ì  íƒ€ì…
                    x: x, y: y, // ìœ„ì¹˜
                    width: enemyData.size, height: enemyData.size, // í¬ê¸°
                    vx: 0, vy: 0, // ì†ë„
                    health: enemyData.health, maxHealth: enemyData.health, // ì²´ë ¥ (maxHealthë„ ë™ì¼í•˜ê²Œ ì„¤ì •)
                    ammo: 20, maxAmmo: 20, // íƒ„ì•½ (ì ì€ ê³ ì •ê°’)
                    speed: enemyData.speed, // ì´ë™ ì†ë„
                    damage: enemyData.damage, // ê³µê²©ë ¥
                    jumpPower: 10, // ì í”„ë ¥ (ì ì€ ê³ ì •ê°’)
                    onGround: false, // ì§€ë©´ ì ‘ì´‰ ì—¬ë¶€
                    facing: 0, // ë°”ë¼ë³´ëŠ” ë°©í–¥
                    expression: this.getRandomExpression(), // í‘œì •
                    color: enemyData.color, // ìƒ‰ìƒ
                    lastShot: 0, // ë§ˆì§€ë§‰ ë°œì‚¬ ì‹œê°„
                    shootInterval: enemyData.shootInterval, // ë°œì‚¬ ê°„ê²©
                    points: enemyData.points, // ì²˜ì¹˜ ì‹œ íšë“ ì ìˆ˜
                    // ìƒˆë¡œìš´ ì  ì „ìš© ì†ì„± ì´ˆê¸°í™”
                    isInvincible: enemyData.isInvincible || false,
                    invincibilityDuration: enemyData.invincibilityDuration || 0,
                    invincibleEndTime: 0,
                    healAmount: enemyData.healAmount || 0,
                    healRadius: enemyData.healRadius || 0,
                    summonCooldown: enemyData.summonCooldown || 0, // ì•ŒíŒŒ ë³´ìŠ¤
                    lastSummon: enemyData.lastSummon || 0, // ì•ŒíŒŒ ë³´ìŠ¤
                    summonCount: enemyData.summonCount || 0, // ì•ŒíŒŒ ë³´ìŠ¤
                    summonType: enemyData.summonType || 'basic', // ì•ŒíŒŒ ë³´ìŠ¤
                    shieldCooldown: enemyData.shieldCooldown || 0, // ë² íƒ€ ë³´ìŠ¤
                    lastShield: enemyData.lastShield || 0, // ë² íƒ€ ë³´ìŠ¤
                    shieldDuration: enemyData.shieldDuration || 0, // ë² íƒ€ ë³´ìŠ¤
                    burstProjectiles: enemyData.burstProjectiles || 0, // ë² íƒ€ ë³´ìŠ¤
                    burstDamage: enemyData.burstDamage || 0, // ë² íƒ€ ë³´ìŠ¤
                    teleportStrikeCooldown: enemyData.teleportStrikeCooldown || 0, // ê°ë§ˆ ë³´ìŠ¤
                    lastTeleportStrike: enemyData.lastTeleportStrike || 0, // ê°ë§ˆ ë³´ìŠ¤
                    teleportRange: enemyData.teleportRange || 0, // ê°ë§ˆ ë³´ìŠ¤
                    jumpCooldown: enemyData.jumpCooldown || 0,
                    lastJump: enemyData.lastJump || 0,
                    flies: enemyData.flies || false, // ë“œë¡ 
                    slowEffect: enemyData.slowEffect || 0, // ì¹¨ë±‰ëŠ”ë³‘
                    slowDuration: enemyData.slowDuration || 0,
                    rageThreshold: enemyData.rageThreshold || 0, // ê´‘ì „ì‚¬
                    rageSpeedBoost: enemyData.rageSpeedBoost || 1,
                    rageDamageBoost: enemyData.rageDamageBoost || 1,
                    isRaging: false // ê´‘ì „ì‚¬ ìƒíƒœ
                };
            }

            // ì•„êµ° ë“œë¡  ìƒì„±
            spawnAlly = (x, y) => {
                this.gameState.allies.push({
                    id: Date.now() + Math.random(),
                    type: 'ally',
                    x: x, y: y,
                    width: 25, height: 25,
                    vx: 0, vy: 0,
                    health: 70, maxHealth: 70,
                    speed: 5,
                    damage: 10, // 25 -> 10
                    color: '#90ee90',
                    lastShot: 0,
                    shootInterval: 600,
                    onGround: false,
                    facing: 0,
                    expression: this.getRandomExpression(),
                    flies: true
                });
            }
            
            // ì•„ì´í…œ ê°ì²´ ìƒì„±
            createItem = (x, y) => {
                const itemType = this.ITEM_TYPES[Math.floor(Math.random() * this.ITEM_TYPES.length)]; // ë¬´ì‘ìœ„ ì•„ì´í…œ íƒ€ì… ì„ íƒ
                return {
                    id: Date.now() + Math.random(), // ê³ ìœ  ID
                    x: x, y: y, // ìœ„ì¹˜
                    width: 20, height: 20, // í¬ê¸°
                    vx: (Math.random() - 0.5) * 4, // ìˆ˜í‰ ì´ˆê¸° ì†ë„ (ë¬´ì‘ìœ„)
                    vy: -Math.random() * 8 - 5, // ìœ„ë¡œ íŠ€ì–´ë‚˜ì˜¤ëŠ” ì´ˆê¸° ì†ë„ (ë¬´ì‘ìœ„)
                    onGround: false, // ì§€ë©´ ì ‘ì´‰ ì—¬ë¶€
                    type: itemType.type, // ì•„ì´í…œ íƒ€ì…
                    effect: itemType.effect, // ì•„ì´í…œ íš¨ê³¼ëŸ‰
                    color: itemType.color, // ì•„ì´í…œ ìƒ‰ìƒ
                    emoji: itemType.emoji, // ì•„ì´í…œ ì´ëª¨ì§€
                    bobOffset: Math.random() * Math.PI * 2, // ë– ë‹¤ë‹ˆëŠ” ì• ë‹ˆë©”ì´ì…˜ ì˜¤í”„ì…‹
                    collected: false, // ìˆ˜ì§‘ ì—¬ë¶€
                    duration: itemType.duration || 0, // ì•„ì´í…œ ì§€ì† ì‹œê°„ (ìƒˆë¡œìš´ ì•„ì´í…œìš©)
                    tickInterval: itemType.tickInterval || 0 // ì²´ë ¥ ì¬ìƒ ë“± ì£¼ê¸°ì  íš¨ê³¼ìš©
                };
            }
            
            // í”Œë ˆì´ì–´ ë°œì‚¬ ë¡œì§
            shoot = () => {
                const player = this.gameState.player;
                if (player.isReloading) return;
                if (this.currentWeapon === 'gun') {
                    if (player.ammo <= 0) {
                        this.reload();
                        return;
                    }
                    const now = Date.now();
                    let shootInterval = 200;
                    if (player.machineGunMode) shootInterval = 60;
                    if (player.rapidFireTime && now < player.rapidFireTime) shootInterval = 100;
                    shootInterval *= (1 - player.cooldownReduction);
                    if (player.lastShot && now - player.lastShot < shootInterval) return;
                    const startX = player.x + player.width / 2;
                    const startY = player.y + player.height / 2;
                    const angle = Math.atan2(this.mouse.y - startY, this.mouse.x - startX);
                    let speed = player.machineGunMode ? 16 : 12;
                    let damage = player.baseDamage;
                    let isCritical = false;
                    if (Math.random() < player.critChance) {
                        damage *= player.critMultiplier;
                        isCritical = true;
                    }
                    if (player.machineGunMode) damage *= 0.5;
                    if (player.machineGunPenalty) damage *= 0.5;
                    if (player.homingLevel >= 3 && player.homingPenalty) damage *= 0.95;
                    const multishot = player.multishot;
                    const actualMultishot = Math.min(multishot, 4);
                    for (let i = 0; i < actualMultishot; i++) {
                        const spreadAngle = angle + (i - (actualMultishot - 1) / 2) * 0.2;
                        let baseLife = 120;
                        let ricochetBonus = player.ricochetLevel ? player.ricochetLevel * 30 : 0;
                        let projectileLife = baseLife + ricochetBonus;
                        this.gameState.projectiles.push({
                            id: Date.now() + Math.random() + i,
                            x: startX, y: startY,
                            vx: Math.cos(spreadAngle) * speed,
                            vy: Math.sin(spreadAngle) * speed,
                            radius: player.machineGunMode ? 2 : 3,
                            damage: damage,
                            life: projectileLife,
                            color: player.machineGunMode ? '#aaa' : (player.rapidFireTime && now < player.rapidFireTime ? '#ff6b00' : '#fbbf24'),
                            ownerId: 'player',
                            pierceCount: player.piercingShot,
                            explosiveRadius: player.explosiveShot > 0 ? (80 + player.explosiveShot * 20) : 0,
                            bounceCount: player.ricochetLevel,
                            isHoming: player.homingLevel > 0,
                            homingStrength: player.homingLevel > 0 ? (0.05 + player.homingLevel * 0.01) : 0,
                            splitCount: player.splitLevel,
                            isCritical: isCritical,
                            hitEnemies: []
                        });
                    }
                    // ê¸°ê´€ë‹¨ì´ íŒ¨ë„í‹°: 4ë°œë‹¹ íƒ„ì•½ 1 ì†Œëª¨
                    if (player.machineGunMode) {
                        player.ammo -= 0.25;
                        if (player.ammo < 0) player.ammo = 0;
                    } else {
                        player.ammo--;
                    }
                    player.lastShot = now;
                    this.updateHUD();
                } else if (this.currentWeapon === 'melee') {
                    const range = 70;
                    const damage = player.baseDamage * 4;
                    let hit = false;
                    this.gameState.enemies.forEach(enemy => {
                        const dx = (enemy.x + enemy.width/2) - (player.x + player.width/2);
                        const dy = (enemy.y + enemy.height/2) - (player.y + player.height/2);
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < range) {
                            enemy.health = Math.max(0, enemy.health - damage);
                            this.createFloatingText(enemy.x + enemy.width/2, enemy.y, `-${damage}`, 'orange');
                            this.createHitParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                            if (enemy.health <= 0) {
                                this.addScore(enemy.points || 100);
                                if (Math.random() < 0.4) this.gameState.items.push(this.createItem(enemy.x, enemy.y));
                                this.gameState.enemies = this.gameState.enemies.filter(e => e !== enemy);
                            }
                            hit = true;
                        }
                    });
                    if (hit) this.showMessage('ì¹¼ ê³µê²©!', '', 600);
                }
            }

            reload = () => {
                const player = this.gameState.player;
                if (player.isReloading) return;
                player.isReloading = true;
                player.gunRecoilTarget = 18;
                let reloadTime = player.reloadTime + player.reloadPenalty;
                this.showMessage('ì¬ì¥ì „ ì¤‘...', '', reloadTime);
                setTimeout(() => {
                    player.ammo = 100;
                    player.isReloading = false;
                    player.gunRecoilTarget = 0;
                    this.updateHUD();
                }, reloadTime);
            }
            
            // ìˆ˜ë¥˜íƒ„ íˆ¬ì²™ ë¡œì§
            throwGrenade = () => {
                const player = this.gameState.player;
                const now = Date.now();
                // ìˆ˜ë¥˜íƒ„ ì¿¨íƒ€ì„ (ì˜ˆì‹œ: 2ì´ˆ)
                if (player.lastGrenade && now - player.lastGrenade < 2000) return;

                const startX = player.x + player.width / 2;
                const startY = player.y + player.height / 2;
                const angle = Math.atan2(this.mouse.y - startY, this.mouse.x - startX);
                const speed = 10; // ìˆ˜ë¥˜íƒ„ íˆ¬ì²™ ì†ë„
                const grenadeLife = 60; // ìˆ˜ë¥˜íƒ„ ìˆ˜ëª… (í”„ë ˆì„)
                const explosionDelay = 40; // í­ë°œê¹Œì§€ì˜ ë”œë ˆì´ (í”„ë ˆì„)

                this.gameState.projectiles.push({
                    id: Date.now() + Math.random(),
                    x: startX, y: startY,
                    vx: (Math.cos(angle) * speed) * this.gameState.timeSlowEffect, // ì‹œê°„ ë‘”í™” ì˜í–¥ ë°›ìŒ
                    vy: (Math.sin(angle) * speed) * this.gameState.timeSlowEffect, // ì‹œê°„ ë‘”í™” ì˜í–¥ ë°›ìŒ
                    radius: 8, // ìˆ˜ë¥˜íƒ„ í¬ê¸°
                    damage: 0, // ì§ì ‘ ë°ë¯¸ì§€ ì—†ìŒ (í­ë°œ ë°ë¯¸ì§€)
                    life: grenadeLife,
                    color: '#6b7280',
                    ownerId: 'player',
                    isGrenade: true, // ìˆ˜ë¥˜íƒ„ì„ì„ ë‚˜íƒ€ë‚´ëŠ” í”Œë˜ê·¸
                    explosionRadius: 150, // í­ë°œ ë²”ìœ„
                    explosionDamage: 70, // í­ë°œ ë°ë¯¸ì§€
                    explosionDelay: explosionDelay // í­ë°œ ë”œë ˆì´
                });
                player.lastGrenade = now;
            }
            
            // ì›¨ì´ë¸Œ ìƒì„± (ë³´ìŠ¤ ì‹œìŠ¤í…œ ì œê±°)
            spawnInitialWave = () => {
                if (this.gameState.gameStatus !== 'spawning') return;
                
                // ì  ìˆ˜ ê²°ì •
                let enemyCount;
                if (this.gameState.wave === 1) {
                    enemyCount = 3;
                } else if (this.gameState.wave === 2) {
                    enemyCount = 4;
                } else if (this.gameState.wave === 3) {
                    enemyCount = 5;
                } else if (this.gameState.wave <= 10) {
                    enemyCount = Math.min(7, 5 + (this.gameState.wave - 3));
                } else if (this.gameState.wave <= 15) {
                    enemyCount = Math.min(10, 7 + (this.gameState.wave - 10));
                } else {
                    enemyCount = Math.min(12, 10 + (this.gameState.wave - 15));
                }
                
                // ì  ìƒì„±
                for (let i = 0; i < enemyCount; i++) {
                    setTimeout(() => {
                        let type = undefined;
                        if (this.gameState.wave >= 2 && Math.random() < 0.2) type = 'fast';
                        if (this.gameState.wave >= 3 && Math.random() < 0.15) type = 'tank';
                        if (this.gameState.wave >= 4 && Math.random() < 0.1) type = 'sniper';
                        if (this.gameState.wave >= 5 && Math.random() < 0.1) type = 'bomber';
                        this.gameState.enemies.push(this.createEnemy(type));
                    }, i * 500);
                }
                
                // ì•„ì´í…œ ìƒì„±
                const totalItemCount = Math.min(6, Math.floor(this.gameState.wave / 2) + 3);
                let ammoItemCount = 0;
                if (this.gameState.wave >= 3) {
                    ammoItemCount = 1;
                }
                
                for (let i = 0; i < totalItemCount; i++) {
                    setTimeout(() => {
                        let itemToCreate;
                        if (Math.random() < 0.12) { 
                            itemToCreate = this.ITEM_TYPES.find(item => item.type === 'ally_summon');
                        } else if (ammoItemCount > 0 && Math.random() < 0.5) {
                            itemToCreate = this.ITEM_TYPES.find(item => item.type === 'ammo');
                            ammoItemCount--;
                        } else if (Math.random() < 0.3) {
                            itemToCreate = this.ITEM_TYPES.find(item => item.type === 'multishot');
                        } else if (Math.random() < 0.2) {
                            itemToCreate = this.ITEM_TYPES.find(item => item.type === 'health');
                        } else {
                            const nonSpecialItems = this.ITEM_TYPES.filter(item => item.type !== 'ammo' && item.type !== 'ally_summon' && item.type !== 'multishot' && item.type !== 'health');
                            itemToCreate = nonSpecialItems[Math.floor(Math.random() * nonSpecialItems.length)];
                        }
                        
                        const item = this.createItem(
                            Math.random() * (this.canvas.width - 40) + 20,
                            Math.random() * (this.canvas.height - 200) + 50
                        );
                        
                        item.type = itemToCreate.type;
                        item.effect = itemToCreate.effect;
                        item.color = itemToCreate.color;
                        item.emoji = itemToCreate.emoji;
                        item.duration = itemToCreate.duration || 0;
                        item.tickInterval = itemToCreate.tickInterval || 0;
                        
                        this.gameState.items.push(item);
                    }, i * 3000);
                }
                
                console.log(`ì›¨ì´ë¸Œ ${this.gameState.wave} ì‹œì‘: ${enemyCount}ë§ˆë¦¬`);
            }
            
            // ìºë¦­í„° (í”Œë ˆì´ì–´ ë° ì ) ìƒíƒœ ì—…ë°ì´íŠ¸ (ìƒˆë¡œìš´ ì  AI ë¡œì§ ì¶”ê°€)
            updateCharacter = (character) => {
                const now = Date.now();
                // player ë³€ìˆ˜ë¥¼ í•¨ìˆ˜ ì‹œì‘ ë¶€ë¶„ì—ì„œ ì •ì˜í•˜ì—¬ ëª¨ë“  ì¡°ê±´ë¬¸ì—ì„œ ì ‘ê·¼ ê°€ëŠ¥í•˜ë„ë¡ í•¨
                const player = this.gameState.player; 

                // í”Œë ˆì´ì–´ ë‘”í™” íš¨ê³¼ í•´ì œ
                if (character === player) { // character === this.gameState.player ëŒ€ì‹  player ì‚¬ìš©
                    if (now > this.gameState.playerSlowedEndTime) {
                        character.speed = 5; // ê¸°ë³¸ ì†ë„ë¡œ ë³µê·€
                    }
                    // ì²´ë ¥ ì¬ìƒ íš¨ê³¼
                    if (now < character.healthRegenEndTime && now - character.lastRegenTick > character.tickInterval) {
                        character.health = Math.min(character.maxHealth, character.health + character.effect);
                        this.createFloatingText(character.x + character.width / 2, character.y, `+${character.effect}`, 'lime');
                        character.lastRegenTick = now;
                    }
                    // íƒ„ì•½ ì¬ìƒ íš¨ê³¼
                    if (now < character.ammoRegenEndTime && now - character.lastAmmoRegenTick > character.tickInterval) {
                        character.ammo = Math.min(character.maxAmmo, character.ammo + character.ammoRegenAmount);
                        this.createFloatingText(character.x + character.width / 2, character.y + 20, `+${character.ammoRegenAmount} íƒ„ì•½`, 'yellow');
                        character.lastAmmoRegenTick = now;
                    }
                }

                // ì¤‘ë ¥ ì ìš© (ë“œë¡ ì€ ì¤‘ë ¥ ë¬´ì‹œ)
                if (!character.onGround && !character.flies) {
                    character.vy += this.GRAVITY;
                }
                
                // ì§€ë©´ ì¶©ëŒ ì²˜ë¦¬ (ë“œë¡ ì€ ì§€ë©´ ì¶©ëŒ ì—†ìŒ)
                if (!character.flies && character.y + character.height > this.canvas.height - this.GROUND_Y) {
                    character.y = this.canvas.height - this.GROUND_Y - character.height;
                    character.vy = 0;
                    character.onGround = true;
                } else if (!character.flies) {
                    character.onGround = false;
                }
                
                // ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (ì‹œê°„ ì •ì§€ íš¨ê³¼ ì ìš©)
                if (this.gameState.timeSlowEffect > 0) { // ì‹œê°„ì´ ì™„ì „íˆ ë©ˆì¶”ì§€ ì•Šì•˜ì„ ë•Œë§Œ ì´ë™
                    character.x += character.vx * this.gameState.timeSlowEffect;
                    character.y += character.vy * this.gameState.timeSlowEffect;
                }
                
                // ë§ˆì°° ì ìš©
                character.vx *= this.FRICTION;
                
                // í™”ë©´ ê²½ê³„ ì œí•œ
                character.x = Math.max(0, Math.min(this.canvas.width - character.width, character.x));
                // ë“œë¡ ì€ Yì¶•ë„ í™”ë©´ ê²½ê³„ ì œí•œ (ìƒë‹¨)
                if (character.flies) {
                    character.y = Math.max(50, Math.min(this.canvas.height - this.GROUND_Y - character.height, character.y));
                }

                // í”Œë ˆì´ì–´ ì…ë ¥ ì²˜ë¦¬
                if (character === player) { // character === this.gameState.player ëŒ€ì‹  player ì‚¬ìš©
                    const currentSpeed = character.speed * (now > this.gameState.playerSlowedEndTime ? 1 : this.gameState.playerSlowEffect || 1);
                    if (this.keys['a']) character.vx -= currentSpeed;
                    if (this.keys['d']) character.vx += currentSpeed;
                    if ((this.keys['w'] || this.keys[' ']) && character.onGround) {
                        character.vy = -character.jumpPower;
                        character.onGround = false;
                    }
                    
                    // ë§ˆìš°ìŠ¤ ë°©í–¥ìœ¼ë¡œ í”Œë ˆì´ì–´ ë°”ë¼ë³´ê²Œ ì„¤ì •
                    const dx = this.mouse.x - (character.x + character.width / 2);
                    const dy = this.mouse.y - (character.y + character.height / 2);
                    character.facing = Math.atan2(dy, dx);
                    // gunRecoil ë³´ê°„ (ë¶€ë“œëŸ½ê²Œ ë³µê·€)
                    character.gunRecoil += (character.gunRecoilTarget - character.gunRecoil) * 0.25;
                    if (Math.abs(character.gunRecoil - character.gunRecoilTarget) < 0.5) character.gunRecoil = character.gunRecoilTarget;
                } else if (character.type === 'ally') {
                    // ì•„êµ° AI: ê°€ì¥ ê°€ê¹Œìš´ ì ì„ ì°¾ì•„ ì´ë™í•˜ê³  ê³µê²©
                    let closestEnemy = null;
                    let minDistance = Infinity;

                    this.gameState.enemies.forEach(enemy => {
                        const dx = enemy.x - character.x;
                        const dy = enemy.y - character.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestEnemy = enemy;
                        }
                    });

                    if (closestEnemy) {
                        const dx = closestEnemy.x - character.x;
                        const dy = closestEnemy.y - character.y;
                        const angle = Math.atan2(dy, dx);
                        character.facing = angle;

                        // ì ì—ê²Œ ì ‘ê·¼ (ë„ˆë¬´ ê°€ê¹Œì›Œì§€ë©´ ë©ˆì¶¤)
                        if (minDistance > 100) { // ì ê³¼ 100px ì´ìƒ ë–¨ì–´ì ¸ ìˆìœ¼ë©´ ì´ë™
                            character.vx += Math.cos(angle) * 0.5 * character.speed * this.gameState.timeSlowEffect;
                            character.vy += Math.sin(angle) * 0.5 * character.speed * this.gameState.timeSlowEffect;
                        } else { // ì ê³¼ ê°€ê¹Œì›Œì§€ë©´ ì†ë„ ì¤„ì„
                            character.vx *= 0.9 * this.gameState.timeSlowEffect;
                            character.vy *= 0.9 * this.gameState.timeSlowEffect;
                        }

                        // ê³µê²©
                        if (this.gameState.timeSlowEffect === 0) {
                            // ì‹œê°„ ì •ì§€ ì¤‘ì—ëŠ” ì¿¨íƒ€ì„ì„ ê°•ì œë¡œ ê°±ì‹ 
                            character.lastShot = now;
                        } else if (now - character.lastShot > character.shootInterval * this.gameState.timeSlowEffect) {
                            this.gameState.projectiles.push({
                                id: Date.now() + Math.random(),
                                x: character.x + character.width / 2,
                                y: character.y + character.height / 2,
                                vx: Math.cos(angle) * 7,
                                vy: Math.sin(angle) * 7,
                                radius: 3,
                                damage: character.damage,
                                life: 80,
                                color: character.color,
                                ownerId: character.id,
                                pierceCount: 0,
                                explosiveRadius: 0,
                                bounceCount: 0,
                                isHoming: false,
                                homingStrength: 0,
                                splitCount: 0,
                                hitEnemies: []
                            });
                            character.lastShot = now;
                        }
                    } else {
                        // ì ì´ ì—†ìœ¼ë©´ í”Œë ˆì´ì–´ ë”°ë¼ë‹¤ë‹˜
                        const dx = player.x - character.x; // player ë³€ìˆ˜ ì‚¬ìš©
                        const dy = player.y - character.y; // player ë³€ìˆ˜ ì‚¬ìš©
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance > 50) { // í”Œë ˆì´ì–´ì™€ 50px ì´ìƒ ë–¨ì–´ì ¸ ìˆìœ¼ë©´ ì´ë™
                            const angle = Math.atan2(dy, dx);
                            character.vx += Math.cos(angle) * 0.3 * character.speed * this.gameState.timeSlowEffect;
                            character.vy += Math.sin(angle) * 0.3 * character.speed * this.gameState.timeSlowEffect;
                        } else {
                            character.vx *= 0.9 * this.gameState.timeSlowEffect;
                            character.vy *= 0.9 * this.gameState.timeSlowEffect;
                        }
                    }

                } else {
                    // ì  AI ë™ì‘ (ì‹œê°„ ì •ì§€ íš¨ê³¼ ì ìš©)
                    if (this.gameState.timeSlowEffect === 0) return; // ì‹œê°„ì´ ì™„ì „íˆ ì •ì§€í–ˆìœ¼ë©´ ì ì€ ì›€ì§ì´ì§€ ì•ŠìŒ

                    const dx = (player.x + player.width / 2) - (character.x + character.width / 2); // player ë³€ìˆ˜ ì‚¬ìš©
                    const dy = (player.y + player.height / 2) - (character.y + character.height / 2); // player ë³€ìˆ˜ ì‚¬ìš©
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // === ë³´ìŠ¤ ìŠ¤í‚¬ ===
                    if (character.type === 'boss') {
                        // 1. ë¯¸ì‚¬ì¼ ë‚œì‚¬ (ì—¬ëŸ¬ ë°©í–¥ìœ¼ë¡œ íƒ„í™˜ í¼ë¶“ê¸°)
                        if (now - character.lastMissile > character.missileCooldown) {
                            const missileCount = 12 + Math.floor(this.gameState.wave/5);
                            for (let i = 0; i < missileCount; i++) {
                                const angle = (Math.PI * 2) * (i / missileCount);
                                this.gameState.projectiles.push({
                                    id: Date.now() + Math.random(),
                                    x: character.x + character.width / 2,
                                    y: character.y + character.height / 2,
                                    vx: Math.cos(angle) * 8,
                                    vy: Math.sin(angle) * 8,
                                    radius: 6,
                                    damage: Math.floor(character.damage * 0.7),
                                    life: 90,
                                    color: character.color,
                                    ownerId: character.id
                                });
                            }
                            this.createFloatingText(character.x + character.width/2, character.y-20, 'ë¯¸ì‚¬ì¼ ë‚œì‚¬!', 'orange');
                            character.lastMissile = now;
                        }
                        // 2. ìˆœê°„ì´ë™ (í”Œë ˆì´ì–´ ê·¼ì²˜ë¡œ)
                        if (now - character.lastTeleport > character.teleportCooldown) {
                            const newX = player.x + (Math.random() - 0.5) * 200;
                            const newY = player.y + (Math.random() - 0.5) * 200;
                            character.x = Math.max(0, Math.min(this.canvas.width - character.width, newX));
                            character.y = Math.max(50, Math.min(this.canvas.height - this.GROUND_Y - character.height, newY));
                            this.createCollectParticles(character.x, character.y, character.color);
                            this.createFloatingText(character.x + character.width/2, character.y-20, 'ìˆœê°„ì´ë™!', 'cyan');
                            character.lastTeleport = now;
                        }
                        // 3. ê´‘ì—­ í­ë°œ
                        if (now - character.lastExplosion > character.explosionCooldown) {
                            this.createExplosion(character.x + character.width/2, character.y + character.height/2, 120 + this.gameState.wave*2, Math.floor(character.damage * 1.2), character.id);
                            this.createFloatingText(character.x + character.width/2, character.y-20, 'ê´‘ì—­ í­ë°œ!', 'red');
                            character.lastExplosion = now;
                        }
                        // 4. ì†Œí™˜ (ì¼ë°˜ ì )
                        if (now - character.lastSummon > character.summonCooldown) {
                            const summonCount = 2 + Math.floor(this.gameState.wave/10);
                            for (let i = 0; i < summonCount; i++) {
                                const spawnX = character.x + (Math.random() - 0.5) * 120;
                                const spawnY = character.y + (Math.random() - 0.5) * 120;
                                const summonedEnemy = this.createEnemy();
                                summonedEnemy.x = Math.max(0, Math.min(this.canvas.width - summonedEnemy.width, spawnX));
                                summonedEnemy.y = Math.max(50, Math.min(this.canvas.height - this.GROUND_Y - summonedEnemy.height, spawnY));
                                this.gameState.enemies.push(summonedEnemy);
                            }
                            this.createFloatingText(character.x + character.width/2, character.y-20, 'ì†Œí™˜!', 'yellow');
                            character.lastSummon = now;
                        }
                        // 5. ì‰´ë“œ (ë¬´ì )
                        if (!character.isInvincible && now - character.lastShield > character.shieldCooldown) {
                            character.isInvincible = true;
                            character.invincibleEndTime = now + character.shieldDuration;
                            character.lastShield = now;
                            this.createFloatingText(character.x + character.width/2, character.y-20, 'ì‰´ë“œ!', 'lightblue');
                        }
                        if (character.isInvincible && now > character.invincibleEndTime) {
                            character.isInvincible = false;
                        }
                        // 6. ë¸”ë™í™€ (í”Œë ˆì´ì–´ë¥¼ ëŒì–´ë‹¹ê¹€)
                        if (now - character.lastBlackhole > character.blackholeCooldown) {
                            // ë¸”ë™í™€ íš¨ê³¼: í”Œë ˆì´ì–´ë¥¼ ë³´ìŠ¤ ìª½ìœ¼ë¡œ ìˆœê°„ì ìœ¼ë¡œ ëŒì–´ë‹¹ê¹€
                            const dx = (character.x + character.width/2) - (player.x + player.width/2);
                            const dy = (character.y + character.height/2) - (player.y + player.height/2);
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist < 600) {
                                player.vx += dx/dist * 30;
                                player.vy += dy/dist * 30;
                                this.createFloatingText(player.x + player.width/2, player.y-20, 'ë¸”ë™í™€!', 'purple');
                            }
                            this.createFloatingText(character.x + character.width/2, character.y-20, 'ë¸”ë™í™€!', 'purple');
                            character.lastBlackhole = now;
                        }
                    }

                    // ì¼ë°˜ ë³´ìŠ¤ AI ì´ë™/ê³µê²©
                    if (distance > 10) {
                        character.vx += (dx > 0 ? 1 : -1) * 0.3 * this.gameState.timeSlowEffect;
                        character.facing = Math.atan2(dy, dx);
                    }
                    // ê¸°ë³¸ ë°œì‚¬ (í”Œë ˆì´ì–´ í–¥í•´)
                    if (distance < 700 && now - character.lastShot > character.shootInterval * this.gameState.timeSlowEffect) {
                        const angle = Math.atan2(dy, dx);
                        this.gameState.projectiles.push({
                            id: Date.now() + Math.random(),
                            x: character.x + character.width / 2,
                            y: character.y + character.height / 2,
                            vx: Math.cos(angle) * 7,
                            vy: Math.sin(angle) * 7,
                            radius: 3,
                            damage: character.damage,
                            life: 80,
                            color: character.color,
                            ownerId: character.id,
                            pierceCount: 0,
                            explosiveRadius: 0,
                            bounceCount: 0,
                            isHoming: false,
                            homingStrength: 0,
                            splitCount: 0,
                            hitEnemies: []
                        });
                        character.lastShot = now;
                    }
                }

                // ì‹ ê·œ ì /ë³´ìŠ¤ ê³ ìœ  ìŠ¤í‚¬/AI êµ¬í˜„ ì˜ˆì‹œ (ì£¼ì„)
                if (character.type === 'mirror' && player) {
                    // ë¯¸ëŸ¬ ì : í”Œë ˆì´ì–´ ì›€ì§ì„ì„ ë”°ë¼í•¨ (ì¢Œìš° ë°˜ì „)
                    character.vx = -player.vx;
                    character.vy = player.vy;
                }
                if (character.type === 'leech') {
                    // í¡í˜ˆ ì : í”Œë ˆì´ì–´ì— ë‹¿ìœ¼ë©´ ì²´ë ¥ í¡ìˆ˜
                    // (ì¶©ëŒ ì²´í¬ í›„ player.health -= leechAmount, character.health += leechAmount ë“± êµ¬í˜„)
                }
                if (character.type === 'mine') {
                    // ì§€ë¢° ì : í”Œë ˆì´ì–´ ê·¼ì²˜ì—ì„œ í­ë°œ
                }
                if (character.type === 'freezer') {
                    // ë¹™ê²° ì : ë°œì‚¬ì²´ì— ë§ìœ¼ë©´ í”Œë ˆì´ì–´ ì´ë™ ì†ë„ ê°ì†Œ
                }
                if (character.type === 'reflector') {
                    // ë°˜ì‚¬ ì : ì¼ì • í™•ë¥ ë¡œ í”Œë ˆì´ì–´ íƒ„í™˜ ë°˜ì‚¬
                }
                if (character.type === 'healer') {
                    // íëŸ¬ ì : ì£¼ê¸°ì ìœ¼ë¡œ ì£¼ë³€ ì  ì²´ë ¥ íšŒë³µ
                }
                if (character.type === 'portal') {
                    // í¬íƒˆ ì : ìˆœê°„ì´ë™í•˜ë©° í”Œë ˆì´ì–´ ê·¼ì²˜ì— ë‚˜íƒ€ë‚¨
                }
                if (character.type === 'exploder') {
                    // í­ë°œ ì : ì£½ì„ ë•Œ í­ë°œ, ì£¼ë³€ì— ë°ë¯¸ì§€
                }
                if (character.type === 'magnet') {
                    // ìì„ ì : í”Œë ˆì´ì–´ì˜ ì•„ì´í…œì„ ëŒì–´ë‹¹ê¹€
                }
                if (character.type === 'curse') {
                    // ì €ì£¼ ì : ë§ì¶”ë©´ í”Œë ˆì´ì–´ì—ê²Œ ë””ë²„í”„
                }
                // === ì‹ ê·œ ë³´ìŠ¤ ===
                if (character.type === 'boss_delta') {
                    // ë¸íƒ€ ë³´ìŠ¤: ì£¼ê¸°ì ìœ¼ë¡œ ë¸”ë™í™€ ìƒì„±(í”Œë ˆì´ì–´ ëŒì–´ë‹¹ê¹€)
                }
                if (character.type === 'boss_epsilon') {
                    // ì—¡ì‹¤ë¡  ë³´ìŠ¤: ì²´ë ¥ ì¼ì • ì´í•˜ì—ì„œ ë¶„ì‹  ìƒì„±
                }
                if (character.type === 'boss_zeta') {
                    // ì œíƒ€ ë³´ìŠ¤: ì£¼ê¸°ì ìœ¼ë¡œ ì‹œê°„ ì™œê³¡(ì†ë„ ëœë¤í™”)
                }
                if (character.type === 'boss_eta') {
                    // ì—íƒ€ ë³´ìŠ¤: ì¼ì • ì‹œê°„ë§ˆë‹¤ ë ˆì´ì € ë°œì‚¬
                }
                if (character.type === 'boss_theta') {
                    // ì„íƒ€ ë³´ìŠ¤: ì¼ì • ì‹œê°„ë§ˆë‹¤ í”Œë ˆì´ì–´ ë°œì‚¬ì²´ ë°˜ì‚¬
                }
                // ...

                // === ê° ë³´ìŠ¤ë³„ ê³ ìœ  ìŠ¤í‚¬ ===
                if (character.type === 'boss_alpha') {
                    // 1. ë¯¸ë‹ˆì–¸ ì†Œí™˜
                    if (now - character.lastSummon > character.summonCooldown) {
                        for (let i = 0; i < character.summonCount; i++) {
                            const spawnX = character.x + (Math.random() - 0.5) * 100;
                            const spawnY = character.y + (Math.random() - 0.5) * 100;
                            const summonedEnemy = this.createEnemy(character.summonType);
                            summonedEnemy.x = spawnX;
                            summonedEnemy.y = spawnY;
                            this.gameState.enemies.push(summonedEnemy);
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ë¯¸ë‹ˆì–¸ ì†Œí™˜!', 'yellow');
                        character.lastSummon = now;
                    }
                    // 2. ì—°ì† ëŒì§„
                    if (now - character.lastDash > character.dashCooldown) {
                        character.isDashing = true;
                        let dashIdx = 0;
                        const dash = () => {
                            if (dashIdx < character.dashCount) {
                                const angle = Math.atan2(player.y - character.y, player.x - character.x);
                                character.vx += Math.cos(angle) * 30;
                                character.vy += Math.sin(angle) * 30;
                                this.createFloatingText(character.x + character.width/2, character.y-20, 'ëŒì§„!', 'orange');
                                dashIdx++;
                                setTimeout(dash, character.dashDuration);
                            } else {
                                character.isDashing = false;
                            }
                        };
                        dash();
                        character.lastDash = now;
                    }
                    // 3. ê´‘ì—­ ì¶©ê²©íŒŒ
                    if (now - character.lastShockwave > character.shockwaveCooldown) {
                        this.createExplosion(character.x + character.width/2, character.y + character.height/2, 180, character.damage * 1.5, character.id);
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ì¶©ê²©íŒŒ!', 'red');
                        character.lastShockwave = now;
                    }
                }
                if (character.type === 'boss_beta') {
                    // 1. ì‰´ë“œ(ë¬´ì )
                    if (!character.isInvincible && now - character.lastShield > character.shieldCooldown) {
                        character.isInvincible = true;
                        character.invincibleEndTime = now + character.shieldDuration;
                        character.lastShield = now;
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ì‰´ë“œ!', 'lightblue');
                    }
                    if (character.isInvincible && now > character.invincibleEndTime) {
                        character.isInvincible = false;
                    }
                    // 2. íƒ„ë§‰ ë°œì‚¬
                    if (now - character.lastBarrage > character.barrageCooldown) {
                        const count = 18;
                        for (let i = 0; i < count; i++) {
                            const angle = (Math.PI * 2) * (i / count);
                            this.gameState.projectiles.push({
                                id: Date.now() + Math.random(),
                                x: character.x + character.width / 2,
                                y: character.y + character.height / 2,
                                vx: Math.cos(angle) * 7,
                                vy: Math.sin(angle) * 7,
                                radius: 5,
                                damage: character.damage * 0.7,
                                life: 90,
                                color: character.color,
                                ownerId: character.id
                            });
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'íƒ„ë§‰!', 'cyan');
                        character.lastBarrage = now;
                    }
                    // 3. ì²´ë ¥ íšŒë³µ
                    if (now - character.lastHeal > character.healCooldown) {
                        character.health = Math.min(character.maxHealth, character.health + character.healAmount);
                        this.createFloatingText(character.x + character.width/2, character.y-20, `+${character.healAmount} íšŒë³µ!`, 'green');
                        character.lastHeal = now;
                    }
                }
                if (character.type === 'boss_gamma') {
                    // 1. ìˆœê°„ì´ë™
                    if (now - character.lastTeleport > character.teleportCooldown) {
                        const newX = player.x + (Math.random() - 0.5) * character.teleportRange;
                        const newY = player.y + (Math.random() - 0.5) * character.teleportRange;
                        character.x = Math.max(0, Math.min(this.canvas.width - character.width, newX));
                        character.y = Math.max(50, Math.min(this.canvas.height - this.GROUND_Y - character.height, newY));
                        this.createCollectParticles(character.x, character.y, character.color);
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ìˆœê°„ì´ë™!', 'orange');
                        character.lastTeleport = now;
                    }
                    // 2. ë ˆì´ì €
                    if (now - character.lastLaser > character.laserCooldown) {
                        // í”Œë ˆì´ì–´ ë°©í–¥ìœ¼ë¡œ ê°•ë ¥í•œ ë ˆì´ì €(ì§ì„ ìƒ í­ë°œ)
                        const angle = Math.atan2(player.y - character.y, player.x - character.x);
                        for (let d = 60; d < 400; d += 40) {
                            const lx = character.x + character.width/2 + Math.cos(angle) * d;
                            const ly = character.y + character.height/2 + Math.sin(angle) * d;
                            this.createExplosion(lx, ly, 40, character.damage * 1.2, character.id);
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ë ˆì´ì €!', 'red');
                        character.lastLaser = now;
                    }
                    // 3. ì†ë„ ë²„í”„
                    if (!character.isSpeedBuffed && now - character.lastSpeedBuff > character.speedBuffCooldown) {
                        character.speed *= 2;
                        character.isSpeedBuffed = true;
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ì†ë„ ë²„í”„!', 'lime');
                        setTimeout(() => {
                            character.speed /= 2;
                            character.isSpeedBuffed = false;
                        }, character.speedBuffDuration);
                        character.lastSpeedBuff = now;
                    }
                }
                if (character.type === 'boss_delta') {
                    // 1. ë¸”ë™í™€
                    if (now - character.lastBlackhole > character.blackholeCooldown) {
                        const dx = (character.x + character.width/2) - (player.x + player.width/2);
                        const dy = (character.y + character.height/2) - (player.y + player.height/2);
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < 600) {
                            player.vx += dx/dist * 30;
                            player.vy += dy/dist * 30;
                            this.createFloatingText(player.x + player.width/2, player.y-20, 'ë¸”ë™í™€!', 'purple');
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ë¸”ë™í™€!', 'purple');
                        character.lastBlackhole = now;
                    }
                    // 2. ê´‘ì—­ í­ë°œ
                    if (now - character.lastExplosion > character.explosionCooldown) {
                        this.createExplosion(character.x + character.width/2, character.y + character.height/2, 120, character.damage * 1.2, character.id);
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ê´‘ì—­ í­ë°œ!', 'red');
                        character.lastExplosion = now;
                    }
                    // 3. í”Œë ˆì´ì–´ ë‘”í™”
                    if (now - character.lastSlow > character.slowCooldown) {
                        player.speed = Math.max(1, player.speed * 0.5);
                        this.createFloatingText(player.x + player.width/2, player.y-20, 'ë‘”í™”!', 'blue');
                        setTimeout(() => { player.speed = 5; }, character.slowDuration);
                        character.lastSlow = now;
                    }
                }
                if (character.type === 'boss_epsilon') {
                    // 1. ë¶„ì‹  ìƒì„±
                    if (!character.hasCloned && now - character.lastClone > character.cloneCooldown) {
                        for (let i = 0; i < character.clones; i++) {
                            const clone = this.createEnemy('boss_epsilon');
                            clone.health = Math.floor(character.health * 0.3);
                            clone.x = character.x + (Math.random() - 0.5) * 120;
                            clone.y = character.y + (Math.random() - 0.5) * 120;
                            this.gameState.enemies.push(clone);
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ë¶„ì‹ !', 'yellow');
                        character.hasCloned = true;
                        character.lastClone = now;
                    }
                    // 2. íƒ„í™˜ ë°˜ì‚¬
                    if (!character.isReflecting && now - character.lastReflect > character.reflectCooldown) {
                        character.isReflecting = true;
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'íƒ„í™˜ ë°˜ì‚¬!', 'cyan');
                        setTimeout(() => { character.isReflecting = false; }, character.reflectDuration);
                        character.lastReflect = now;
                    }
                    // 3. ì²´ë ¥ í¡ìˆ˜
                    if (now - character.lastDrain > character.drainCooldown) {
                        player.health = Math.max(0, player.health - character.drainAmount);
                        character.health = Math.min(character.maxHealth, character.health + character.drainAmount);
                        this.createFloatingText(player.x + player.width/2, player.y-20, `-${character.drainAmount} í¡ìˆ˜!`, 'purple');
                        this.createFloatingText(character.x + character.width/2, character.y-20, `+${character.drainAmount} í¡ìˆ˜!`, 'purple');
                        character.lastDrain = now;
                    }
                }
                if (character.type === 'boss_zeta') {
                    // 1. ì‹œê°„ ì™œê³¡(ìŠ¬ë¡œìš°)
                    if (!character.isTimeWarp && now - character.lastTimeWarp > character.timeWarpCooldown) {
                        this.gameState.timeSlowEffect = 0.5;
                        character.isTimeWarp = true;
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ì‹œê°„ ì™œê³¡!', 'blue');
                        setTimeout(() => {
                            this.gameState.timeSlowEffect = 1;
                            character.isTimeWarp = false;
                        }, character.timeWarpDuration);
                        character.lastTimeWarp = now;
                    }
                    // 2. ì—°ë°œ ì‚¬ê²©
                    if (!character.isRapidFire && now - character.lastRapidFire > character.rapidFireCooldown) {
                        character.isRapidFire = true;
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ì—°ë°œ ì‚¬ê²©!', 'orange');
                        let shots = 0;
                        const rapid = () => {
                            if (shots < 10) {
                                const angle = Math.atan2(player.y - character.y, player.x - character.x) + (Math.random()-0.5)*0.3;
                                this.gameState.projectiles.push({
                                    id: Date.now() + Math.random(),
                                    x: character.x + character.width / 2,
                                    y: character.y + character.height / 2,
                                    vx: Math.cos(angle) * 12,
                                    vy: Math.sin(angle) * 12,
                                    radius: 5,
                                    damage: character.damage * 0.7,
                                    life: 90,
                                    color: character.color,
                                    ownerId: character.id
                                });
                                shots++;
                                setTimeout(rapid, 80);
                            } else {
                                character.isRapidFire = false;
                            }
                        };
                        rapid();
                        character.lastRapidFire = now;
                    }
                    // 3. ëœë¤ ìœ„ì¹˜ ì´ë™
                    if (now - character.lastRandomMove > character.randomMoveCooldown) {
                        character.x = Math.random() * (this.canvas.width - character.width);
                        character.y = Math.random() * (this.canvas.height - this.GROUND_Y - character.height);
                        this.createCollectParticles(character.x, character.y, character.color);
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ìˆœê°„ì´ë™!', 'cyan');
                        character.lastRandomMove = now;
                    }
                }
                if (character.type === 'boss_eta') {
                    // 1. ë ˆì´ì €
                    if (now - character.lastLaser > character.laserCooldown) {
                        const angle = Math.atan2(player.y - character.y, player.x - character.x);
                        for (let d = 60; d < 400; d += 40) {
                            const lx = character.x + character.width/2 + Math.cos(angle) * d;
                            const ly = character.y + character.height/2 + Math.sin(angle) * d;
                            this.createExplosion(lx, ly, 40, character.damage * 1.2, character.id);
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ë ˆì´ì €!', 'red');
                        character.lastLaser = now;
                    }
                    // 2. ì—°ì† ì í”„
                    if (now - character.lastJump > character.jumpCooldown) {
                        let jumpIdx = 0;
                        const jump = () => {
                            if (jumpIdx < character.jumpCount) {
                                character.vy = -character.jumpPower;
                                this.createFloatingText(character.x + character.width/2, character.y-20, 'ì í”„!', 'lime');
                                jumpIdx++;
                                setTimeout(jump, 400);
                            }
                        };
                        jump();
                        character.lastJump = now;
                    }
                    // 3. ë°©ì–´ë ¥ ì¦ê°€
                    if (!character.isArmorBuffed && now - character.lastArmorBuff > character.armorBuffCooldown) {
                        character.armor = (character.armor || 0) + 20;
                        character.isArmorBuffed = true;
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ë°©ì–´ë ¥ ì¦ê°€!', 'blue');
                        setTimeout(() => {
                            character.armor = (character.armor || 0) - 20;
                            character.isArmorBuffed = false;
                        }, character.armorBuffDuration);
                        character.lastArmorBuff = now;
                    }
                }
                if (character.type === 'boss_theta') {
                    // 1. ë°œì‚¬ì²´ ë°˜ì‚¬
                    if (!character.isReflecting && now - character.lastReflectAll > character.reflectAllCooldown) {
                        character.isReflecting = true;
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ë°œì‚¬ì²´ ë°˜ì‚¬!', 'cyan');
                        setTimeout(() => { character.isReflecting = false; }, character.reflectAllDuration);
                        character.lastReflectAll = now;
                    }
                    // 2. ë„íƒ„ íƒ„í™˜
                    if (now - character.lastRicochet > character.ricochetCooldown) {
                        for (let i = 0; i < character.ricochetCount; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            this.gameState.projectiles.push({
                                id: Date.now() + Math.random(),
                                x: character.x + character.width / 2,
                                y: character.y + character.height / 2,
                                vx: Math.cos(angle) * 10,
                                vy: Math.sin(angle) * 10,
                                radius: 5,
                                damage: character.damage * 0.7,
                                life: 120,
                                color: character.color,
                                ownerId: character.id,
                                bounceCount: 2
                            });
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ë„íƒ„!', 'orange');
                        character.lastRicochet = now;
                    }
                    // 3. í”Œë ˆì´ì–´ ìœ„ì¹˜ ì¶”ì 
                    if (!character.isTracking && now - character.lastTrack > character.trackCooldown) {
                        character.isTracking = true;
                        this.createFloatingText(character.x + character.width/2, character.y-20, 'ìœ„ì¹˜ ì¶”ì !', 'red');
                        setTimeout(() => { character.isTracking = false; }, character.trackDuration);
                        character.lastTrack = now;
                    }
                }
            }
            
            // ë°œì‚¬ì²´ ìƒíƒœ ì—…ë°ì´íŠ¸ ë° ì¶©ëŒ ê°ì§€ (ìœ ë ¹ ë¬´ì  ìƒíƒœ ì²˜ë¦¬ ì¶”ê°€)
            updateProjectiles = () => {
                // Homing logic: adjust velocity of homing projectiles
                for (let i = 0; i < this.gameState.projectiles.length; i++) {
                    const p = this.gameState.projectiles[i];
                    if (p.isHoming) {
                        let nearest = null, minDist = 99999;
                        for (const enemy of this.gameState.enemies) {
                            const dx = enemy.x + enemy.width/2 - p.x;
                            const dy = enemy.y + enemy.height/2 - p.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist < minDist) { minDist = dist; nearest = enemy; }
                        }
                        // Homing parameters
                        const maxTurn = (p.homingStrength || 0.08) * Math.PI; // ìµœëŒ€ íšŒì „ ê°ë„ (ë¼ë””ì•ˆ)
                        const speed = Math.sqrt(p.vx*p.vx + p.vy*p.vy) || 8;
                        if (nearest) {
                            const dx = nearest.x + nearest.width/2 - p.x;
                            const dy = nearest.y + nearest.height/2 - p.y;
                            const targetAngle = Math.atan2(dy, dx);
                            let currentAngle = Math.atan2(p.vy, p.vx);
                            let delta = targetAngle - currentAngle;
                            // -PI ~ PIë¡œ ë³´ì •
                            while (delta > Math.PI) delta -= 2*Math.PI;
                            while (delta < -Math.PI) delta += 2*Math.PI;
                            // íšŒì „ ê°ë„ ì œí•œ
                            if (Math.abs(delta) > maxTurn) delta = maxTurn * Math.sign(delta);
                            const newAngle = currentAngle + delta;
                            p.vx = Math.cos(newAngle) * speed;
                            p.vy = Math.sin(newAngle) * speed;
                        } else {
                            // ì ì´ ì—†ìœ¼ë©´ ê¸°ì¡´ ë°©í–¥/ì†ë„ ìœ ì§€ (ì •ì§€í•˜ì§€ ì•ŠìŒ)
                            // ì•„ë¬´ê²ƒë„ í•˜ì§€ ì•ŠìŒ
                        }
                    }
                }
                const projectilesToRemove = new Set();
                const player = this.gameState.player;
                // 1. ë°œì‚¬ì²´ ì´ë™/ìˆ˜ëª…
                for (let i = 0; i < this.gameState.projectiles.length; i++) {
                    const p = this.gameState.projectiles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life--;
                    if (
                        p.x < -100 || p.x > this.canvas.width + 100 ||
                        p.y < -100 || p.y > this.canvas.height + 100 ||
                        p.life <= 0
                    ) {
                        projectilesToRemove.add(i);
                        continue;
                    }
                }
                // 2. í”Œë ˆì´ì–´ ë°œì‚¬ì²´ â†’ ì  ì¶©ëŒ
                for (let i = 0; i < this.gameState.projectiles.length; i++) {
                    const p = this.gameState.projectiles[i];
                    if (p.ownerId === 'player') {
                        for (let j = 0; j < this.gameState.enemies.length; j++) {
                            const enemy = this.gameState.enemies[j];
                            if (!enemy) continue;
                            const dx = p.x - (enemy.x + enemy.width / 2);
                            const dy = p.y - (enemy.y + enemy.height / 2);
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < (p.radius || 0) + (enemy.width || 0) / 2) {
                                // ìœ ë ¹/ë³´ìŠ¤ ì‰´ë“œ ë¬´ì  ì²´í¬
                                if (enemy.type === 'ghost' && enemy.isInvincible) continue;
                                if (enemy.type === 'boss_beta' && enemy.isInvincible) continue;
                                enemy.health -= p.damage;
                                this.createFloatingText(enemy.x + enemy.width / 2, enemy.y, `-${p.damage}`, 'white');
                                this.createHitParticles(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                                // í­ë°œ ì‚¬ê²©
                                if (p.explosiveRadius && p.explosiveRadius > 0) {
                                    this.createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, p.explosiveRadius, p.damage, p.ownerId);
                                }
                                // ë¶„ì—´ ì‚¬ê²©
                                if (p.splitCount && p.splitCount > 0) {
                                    this.createSplitProjectiles(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, p.damage, p.ownerId, p.radius, p.splitCount);
                                }
                                if (enemy.health <= 0) {
                                    this.addScore(enemy.points || 100);
                                    if (Math.random() < 0.4) this.gameState.items.push(this.createItem(enemy.x, enemy.y));
                                    

                                    
                                    this.gameState.enemies = this.gameState.enemies.filter(e => e !== enemy);
                                }
                                projectilesToRemove.add(i);
                                break;
                            }
                        }
                    }
                }
                // 3. ì  ë°œì‚¬ì²´ â†’ í”Œë ˆì´ì–´ ì¶©ëŒ
                for (let i = 0; i < this.gameState.projectiles.length; i++) {
                    const p = this.gameState.projectiles[i];
                    // Only enemy bullets (not player or ally) can hit the player
                    if (p.ownerId && p.ownerId !== 'player' && p.ownerId !== 'ally') {
                        const dx = p.x - (player.x + player.width / 2);
                        const dy = p.y - (player.y + player.height / 2);
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < (p.radius || 0) + (player.width || 0) / 2) {
                            // ë¬´ì  ì²´í¬
                            if (Date.now() < player.invincibleEndTime) {
                                this.createFloatingText(player.x + player.width / 2, player.y, `ë¬´ì !`, 'gold');
                            } else {
                                let actualDamage = p.damage;
                                actualDamage = Math.max(0, actualDamage - player.armor);
                                if (Date.now() < player.shieldBoostEndTime) {
                                    actualDamage *= player.damageReductionFactor;
                                    this.createFloatingText(player.x + player.width / 2, player.y, `-${actualDamage.toFixed(0)} (ì‰´ë“œ)`, 'lightblue');
                                } else {
                                    this.createFloatingText(player.x + player.width / 2, player.y, `-${actualDamage.toFixed(0)}`, 'red');
                                }
                                player.health -= actualDamage;
                                this.createHitParticles(player.x + player.width / 2, player.y + player.height / 2);
                                player.lastHitById = p.ownerId;
                                if (player.health <= 0) this.gameOver();
                            }
                            projectilesToRemove.add(i);
                        }
                    }
                }
                // 4. ë°œì‚¬ì²´ë¼ë¦¬ ì¶©ëŒ(í”Œë ˆì´ì–´ vs ì )
                for (let i = 0; i < this.gameState.projectiles.length; i++) {
                    const p1 = this.gameState.projectiles[i];
                    if (p1.ownerId === 'player') {
                        for (let j = 0; j < this.gameState.projectiles.length; j++) {
                            if (i === j) continue;
                            const p2 = this.gameState.projectiles[j];
                            if (p2.ownerId && p2.ownerId !== 'player' && p2.ownerId !== 'ally') {
                                const dx = p1.x - p2.x;
                                const dy = p1.y - p2.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist < (p1.radius || 0) + (p2.radius || 0)) {
                                    projectilesToRemove.add(i);
                                    projectilesToRemove.add(j);
                                }
                            }
                        }
                    }
                }
                // ì‹¤ì œë¡œ ì œê±°
                this.gameState.projectiles = this.gameState.projectiles.filter((_, idx) => !projectilesToRemove.has(idx));
            };

            // ë¶„ì—´ ì‚¬ê²© (Split Shot) ì‹œ ì‘ì€ ë°œì‚¬ì²´ ìƒì„±
            createSplitProjectiles = (x, y, baseDamage, ownerId, parentRadius, splitLevel) => {
                const numSplits = 3 + splitLevel; // ë ˆë²¨ì— ë”°ë¼ ë¶„ì—´ë˜ëŠ” ì‘ì€ íƒ„í™˜ ìˆ˜ ì¦ê°€
                const splitSpeed = 5; // ì‘ì€ íƒ„í™˜ ì†ë„
                const splitDamage = baseDamage * 0.5; // ì‘ì€ íƒ„í™˜ ë°ë¯¸ì§€ (ì›ë³¸ì˜ ì ˆë°˜)
                const splitRadius = parentRadius / 1.5; // ì‘ì€ íƒ„í™˜ ë°˜ì§€ë¦„

                for (let i = 0; i < numSplits; i++) {
                    const splitAngle = Math.random() * Math.PI * 2; // ë¬´ì‘ìœ„ ë°©í–¥
                    this.gameState.projectiles.push({
                        id: Date.now() + Math.random(),
                        x: x,
                        y: y,
                        vx: Math.cos(splitAngle) * splitSpeed,
                        vy: Math.sin(splitAngle) * splitSpeed,
                        radius: 3, // ê¸°ì¡´ 7ì—ì„œ 4ë¡œ í•˜í–¥
                        damage: splitDamage,
                        life: 60, // ì§§ì€ ìˆ˜ëª…
                        color: '#9932cc', // ë¶„ì—´ ì‚¬ê²© ìƒ‰ìƒ
                        ownerId: ownerId,
                        pierceCount: 0,
                        explosiveRadius: 0,
                        bounceCount: 0,
                        isHoming: false,
                        homingStrength: 0,
                        splitCount: 0, // ë¶„ì—´ëœ íƒ„í™˜ì€ ë‹¤ì‹œ ë¶„ì—´í•˜ì§€ ì•ŠìŒ
                        hitEnemies: []
                    });
                }
            }

            // í­ë°œ íš¨ê³¼ ìƒì„± (ìˆ˜ë¥˜íƒ„ í­ë°œì—ë§Œ ì‚¬ìš©ë¨)
            createExplosion = (x, y, radius, damage, ownerId) => { // ownerId ì¶”ê°€
                // íŒŒí‹°í´ ìƒì„±
                for (let i = 0; i < 30; i++) {
                    this.gameState.particles.push({
                        x: x, y: y,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        life: 40, maxLife: 40,
                        color: '#ff4500', // ì£¼í™©ìƒ‰ í­ë°œ ìƒ‰ìƒ
                        size: Math.random() * 5 + 2
                    });
                }

                // í”Œë ˆì´ì–´ì—ê²Œ ë²”ìœ„ í”¼í•´ ì ìš© (ìˆ˜ë¥˜íƒ„ í­ë°œì—ë§Œ í•´ë‹¹)
                const player = this.gameState.player;
                let dx = x - (player.x + player.width / 2);
                let dy = y - (player.y + player.height / 2);
                let distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < radius + player.width / 2) {
                    // í”Œë ˆì´ì–´ ë¬´ì  ìƒíƒœ ì²´í¬
                    if (Date.now() < player.invincibleEndTime) {
                        this.createFloatingText(player.x + player.width / 2, player.y, `ë¬´ì !`, 'gold');
                    } else {
                        // í”Œë ˆì´ì–´ê°€ ë°œì‚¬í•œ ìˆ˜ë¥˜íƒ„ í­ë°œì—ëŠ” í”¼í•´ë¥¼ ì…ì§€ ì•Šë„ë¡
                        if (ownerId === 'player') {
                            this.createFloatingText(player.x + player.width / 2, player.y, `íšŒí”¼!`, 'cyan');
                            // ìˆ˜ë¥˜íƒ„ í­ë°œì— ì˜í•œ ì‚¬ë§ì€ ê¸°ë¡í•˜ì§€ ì•ŠìŒ
                            return; 
                        }

                        let actualDamage = damage;
                        // ë°©ì–´ë ¥ ì ìš©
                        actualDamage = Math.max(0, actualDamage - this.gameState.player.armor);
                        if (Date.now() < player.shieldBoostEndTime) {
                            actualDamage *= player.damageReductionFactor;
                            this.createFloatingText(player.x + player.width / 2, player.y, `-${actualDamage.toFixed(0)} (ì‰´ë“œ)`, 'lightblue');
                        } else {
                            this.createFloatingText(player.x + player.width / 2, player.y, `-${actualDamage.toFixed(0)}`, 'red'); // ë°ë¯¸ì§€ í…ìŠ¤íŠ¸
                        }
                        player.health -= actualDamage;
                        this.createHitParticles(player.x + player.width / 2, player.y + player.height / 2);
                        
                        // í­ë°œë¡œ ì¸í•œ í”¼í•´ì¼ ê²½ìš° ë§ˆì§€ë§‰ í”¼í•´ì ID ì €ì¥ (ìˆ˜ë¥˜íƒ„ì´ ì•„ë‹Œ ë‹¤ë¥¸ í­ë°œì— ëŒ€ë¹„)
                        this.gameState.player.lastHitById = ownerId;

                        if (player.health <= 0) {
                            this.gameOver();
                        }
                    }
                }

                // ì ë“¤ì—ê²Œ ë²”ìœ„ í”¼í•´ ì ìš© (ìˆ˜ë¥˜íƒ„ í­ë°œì—ë§Œ í•´ë‹¹)
                this.gameState.enemies.forEach(enemy => {
                    dx = x - (enemy.x + enemy.width / 2);
                    dy = y - (enemy.y + enemy.height / 2);
                    distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < radius + enemy.width / 2) {
                        // ìœ ë ¹ ë¬´ì  ìƒíƒœ ì²´í¬
                        if (enemy.type === 'ghost' && enemy.isInvincible) return;
                        // ë² íƒ€ ë³´ìŠ¤ ì‰´ë“œ ì²´í¬
                        if (enemy.type === 'boss_beta' && enemy.isInvincible) return;
                        // ë°©íŒ¨ë³‘ ë°©ì–´ ì²´í¬ (í­ë°œì€ ì „ë°©/í›„ë°© ìƒê´€ì—†ì´ í”¼í•´)
                        if (enemy.type === 'shielded') {
                            enemy.health -= damage * 0.5; // ë°©íŒ¨ë³‘ì€ í­ë°œ í”¼í•´ 50% ê°ì†Œ
                            this.createFloatingText(enemy.x + enemy.width / 2, enemy.y, `-${(damage * 0.5).toFixed(0)} (ë°©ì–´)`, 'orange');
                        } else {
                            enemy.health -= damage; // ì ì—ê²Œë„ ë™ì¼í•œ í­ë°œ ë°ë¯¸ì§€
                            this.createFloatingText(enemy.x + enemy.width / 2, enemy.y, `-${damage}`, 'white');
                        }
                        this.createHitParticles(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                        if (enemy.health <= 0) {
                            // ì  ì²˜ì¹˜ ë¡œì§ (ì ìˆ˜, ì•„ì´í…œ ë“œë¡­ ë“±)
                            this.addScore(enemy.points || 100);
                            if (Math.random() < 0.4) this.gameState.items.push(this.createItem(enemy.x, enemy.y));
                            

                            
                            this.gameState.enemies = this.gameState.enemies.filter(e => e.id !== enemy.id);
                        }
                    }
                });

                // ì•„êµ°ì—ê²Œ ë²”ìœ„ í”¼í•´ ì ìš©
                this.gameState.allies.forEach(ally => {
                    dx = x - (ally.x + ally.width / 2);
                    dy = y - (ally.y + ally.height / 2);
                    distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < radius + ally.width / 2) {
                         // ì•„êµ°ì´ ë°œì‚¬í•œ ìˆ˜ë¥˜íƒ„ í­ë°œì—ëŠ” í”¼í•´ë¥¼ ì…ì§€ ì•Šë„ë¡
                        if (ownerId === ally.id) {
                            this.createFloatingText(ally.x + ally.width / 2, ally.y, `íšŒí”¼!`, 'cyan');
                            return; 
                        }

                        ally.health -= damage;
                        this.createFloatingText(ally.x + ally.width / 2, ally.y, `-${damage}`, 'orange');
                        this.createHitParticles(ally.x + ally.width / 2, ally.y + ally.height / 2);
                        if (ally.health <= 0) {
                            this.gameState.allies = this.gameState.allies.filter(a => a.id !== ally.id);
                            this.createFloatingText(ally.x + ally.width / 2, ally.y, `ì‚¬ë§!`, 'grey');
                        }
                    }
                });
            }
            
            // ì•„ì´í…œ ìƒíƒœ ì—…ë°ì´íŠ¸ ë° í”Œë ˆì´ì–´ ì¶©ëŒ ê°ì§€
            updateItems = () => {
                const player = this.gameState.player;
                const now = Date.now();

                // ìì„ íš¨ê³¼ ì ìš©
                if (now < player.magnetEndTime) {
                    this.gameState.items.forEach(item => {
                        const dx = (player.x + player.width / 2) - (item.x + item.width / 2);
                        const dy = (player.y + player.height / 2) - (item.y + item.height / 2);
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < player.magnetRadius) {
                            const force = 0.5; // ìì„ í˜
                            item.vx += (dx / distance) * force;
                            item.vy += (dy / distance) * force;
                        }
                    });
                }


                this.gameState.items = this.gameState.items.filter(item => {
                    if (item.collected) return false; // ì´ë¯¸ ìˆ˜ì§‘ëœ ì•„ì´í…œì€ ì œê±°
                    
                    // ì¤‘ë ¥ ì ìš©
                    if (!item.onGround) {
                        item.vy += this.GRAVITY;
                    }
                    
                    // ì§€ë©´ ì¶©ëŒ ì²˜ë¦¬ (ë°”ìš´ìŠ¤ íš¨ê³¼)
                    if (item.y + item.height > this.canvas.height - this.GROUND_Y) {
                        item.y = this.canvas.height - this.GROUND_Y - item.height;
                        item.vy = -item.vy * 0.5; // ë°”ìš´ìŠ¤ íš¨ê³¼
                        if (Math.abs(item.vy) < 2) {
                            item.vy = 0;
                            item.onGround = true;
                        }
                    }
                    
                    // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                    item.x += item.vx;
                    item.y += item.vy;
                    
                    // ë§ˆì°° ì ìš©
                    item.vx *= 0.98;
                    
                    // í™”ë©´ ê²½ê³„ ì œí•œ
                    item.x = Math.max(0, Math.min(this.canvas.width - item.width, item.x));
                    
                    // ì§€ë©´ì— ìˆì„ ë•Œë§Œ ë– ë‹¤ë‹ˆëŠ” ì• ë‹ˆë©”ì´ì…˜
                    if (item.onGround) {
                        item.y += Math.sin(Date.now() * 0.003 + item.bobOffset) * 1;
                    }
                    
                    // í”Œë ˆì´ì–´ì™€ ì¶©ëŒ ì²´í¬
                    if (player.x < item.x + item.width &&
                        player.x + player.width > item.x &&
                        player.y < item.y + item.height &&
                        player.y + player.height > item.y) {
                        
                        this.collectItem(item); // ì•„ì´í…œ ìˆ˜ì§‘
                        return false; // ì•„ì´í…œ ì œê±°
                    }
                    
                    return true; // ì•„ì´í…œ ìœ ì§€
                });
            }
            
            // ì•„ì´í…œ ìˆ˜ì§‘ ì‹œ íš¨ê³¼ ì ìš©
            collectItem = (item) => {
                const player = this.gameState.player;
                const now = Date.now();
                
                switch (item.type) {
                    case 'health':
                        player.health = Math.min(player.maxHealth, player.health + item.effect);
                        this.createFloatingText(player.x + player.width / 2, player.y, `+${item.effect}`, 'green'); // ì²´ë ¥ í…ìŠ¤íŠ¸
                        this.showMessage(`+${item.effect} ì²´ë ¥!`, '', 1500);
                        break;
                    case 'ammo':
                        player.ammo = Math.min(player.maxAmmo, player.ammo + item.effect);
                        this.createFloatingText(player.x + player.width / 2, player.y, `+${item.effect}`, 'blue'); // íƒ„ì•½ í…ìŠ¤íŠ¸
                        this.showMessage(`+${item.effect} íƒ„ì•½!`, '', 1500);
                        break;
                    case 'speed':
                        player.speed = Math.min(10, player.speed + item.effect);
                        this.showMessage(`ì†ë„ ì¦ê°€!`, `+${item.effect}`, 1500);
                        break;
                    case 'shield':
                        player.maxHealth += item.effect;
                        player.health = Math.min(player.maxHealth, player.health + item.effect); // ìµœëŒ€ ì²´ë ¥ ì¦ê°€ ì‹œ í˜„ì¬ ì²´ë ¥ë„ ì¦ê°€
                        this.showMessage(`ë°©ì–´ë§‰ ê°•í™”!`, `+${item.effect} ìµœëŒ€ ì²´ë ¥`, 1500);
                        break;
                    case 'damage':
                        player.baseDamage = (player.baseDamage || 25) + item.effect; // ê¸°ë³¸ ê³µê²©ë ¥ 25ë¡œ ìˆ˜ì • ë°˜ì˜
                        this.showMessage(`ê³µê²©ë ¥ ì¦ê°€!`, `+${item.effect} ë°ë¯¸ì§€`, 1500);
                        break;
                    case 'multishot':
                        player.multishot = Math.min(99, (player.multishot || 1) + 1);
                        this.showMessage(`ë‹¤ì¤‘ ë°œì‚¬!`, `${player.multishot}ë°œ ë™ì‹œ ë°œì‚¬`, 2000);
                        break;
                    case 'megahealth':
                        player.health = Math.min(player.maxHealth, player.health + item.effect);
                        this.createFloatingText(player.x + player.width / 2, player.y, `+${item.effect}`, 'lime'); // ë©”ê°€ íë§ í…ìŠ¤íŠ¸
                        this.showMessage(`ë©”ê°€ íë§!`, `+${item.effect} ì²´ë ¥`, 2000);
                        break;
                    case 'rapid':
                        player.rapidFireTime = (Date.now() + 10000); // 10ì´ˆê°„ ë¹ ë¥¸ ë°œì‚¬
                        this.showMessage(`ì—°ë°œ ëª¨ë“œ!`, '10ì´ˆê°„ ë¹ ë¥¸ ë°œì‚¬', 2000);
                        break;
                    case 'invincibility':
                        player.invincibleEndTime = now + item.effect;
                        this.showMessage(`ë¬´ì !`, `${item.effect / 1000}ì´ˆê°„ ë¬´ì `, 2000);
                        break;
                    case 'grenade':
                        this.throwGrenade(); // ìˆ˜ë¥˜íƒ„ íˆ¬ì²™
                        this.showMessage(`ìˆ˜ë¥˜íƒ„!`, `ì ë“¤ì„ ë‚ ë ¤ë²„ë¦¬ì„¸ìš”!`, 1500);
                        break;
                    case 'shield_boost':
                        player.shieldBoostEndTime = now + item.duration;
                        player.damageReductionFactor = item.effect;
                        this.showMessage(`ì‰´ë“œ ê°•í™”!`, `ë°›ëŠ” í”¼í•´ ${item.effect * 100}% ê°ì†Œ`, 2000);
                        break;
                    case 'time_slow':
                        this.gameState.timeSlowEndTime = now + item.duration;
                        this.gameState.timeSlowEffect = item.effect;
                        this.showMessage(`ì‹œê°„ ë‘”í™”!`, `ëª¨ë“  ì  ëŠë ¤ì§`, 2000);
                        break;
                    case 'magnet':
                        player.magnetEndTime = now + item.duration;
                        this.showMessage(`ìì„!`, `ì•„ì´í…œì„ ëŒì–´ë‹¹ê¹ë‹ˆë‹¤`, 2000);
                        break;
                    case 'health_regen':
                        player.healthRegenEndTime = now + item.duration;
                        player.lastRegenTick = now; // ì²« í‹±ì€ ë°”ë¡œ ì ìš©
                        player.effect = item.effect; // ì²´ë ¥ ì¬ìƒëŸ‰ ì €ì¥
                        player.tickInterval = item.tickInterval; // ì²´ë ¥ ì¬ìƒ ê°„ê²© ì €ì¥
                        this.showMessage(`ì²´ë ¥ ì¬ìƒ!`, `${item.duration / 1000}ì´ˆê°„ ì²´ë ¥ íšŒë³µ`, 2000);
                        break;
                    case 'ally_summon':
                        this.showMessage(`ì•„êµ° ì†Œí™˜!`, `ë“ ë“ í•œ ì•„êµ°ì´ í•©ë¥˜í•©ë‹ˆë‹¤!`, 2000);
                        this.spawnAlly(player.x + (player.width / 2), player.y + (player.height / 2)); // í”Œë ˆì´ì–´ ìœ„ì¹˜ì— ì†Œí™˜
                        break;
                    case 'orbiting_knife':
                        player.orbitingKnives.push({
                            angle: Math.random() * Math.PI * 2, // ì´ˆê¸° ë¬´ì‘ìœ„ ê°ë„
                            radius: 60, // í”Œë ˆì´ì–´ë¡œë¶€í„°ì˜ ê±°ë¦¬
                            speed: 0.05, // ê°ì†ë„
                            damage: 15, // ì¹¼ë‚  ê³µê²©ë ¥
                            lastHit: 0, // ë§ˆì§€ë§‰ ê³µê²© ì‹œê°„ (ì¿¨ë‹¤ìš´ìš©)
                            cooldown: 200, // ê³µê²© ì¿¨ë‹¤ìš´ (ms)
                            color: this.ITEM_TYPES.find(i => i.type === 'orbiting_knife').color, // ì•„ì´í…œ íƒ€ì…ì—ì„œ ìƒ‰ìƒ ê°€ì ¸ì˜¤ê¸°
                            emoji: this.ITEM_TYPES.find(i => i.type === 'orbiting_knife').emoji // ì•„ì´í…œ íƒ€ì…ì—ì„œ ì´ëª¨ì§€ ê°€ì ¸ì˜¤ê¸°
                        });
                        this.showMessage(`íšŒì „ ì¹¼ë‚  íšë“!`, `í”Œë ˆì´ì–´ ì£¼ìœ„ë¥¼ ë•ë‹ˆë‹¤!`, 2000);
                        break;
                    case 'piercing_shot':
                        player.piercingShot = Math.min(99, player.piercingShot + item.effect);
                        this.showMessage(`ê´€í†µ ì‚¬ê²©!`, `íƒ„í™˜ì´ ì ì„ ê´€í†µí•©ë‹ˆë‹¤! (Lv.${player.piercingShot})`, 2000);
                        break;
                    case 'explosive_shot':
                        player.explosiveShot = Math.min(99, player.explosiveShot + item.effect);
                        this.showMessage(`í­ë°œ ì‚¬ê²©!`, `íƒ„í™˜ì´ í­ë°œí•©ë‹ˆë‹¤! (Lv.${player.explosiveShot})`, 2000);
                        break;
                    case 'ricochet_shot':
                        player.ricochetLevel = Math.min(99, player.ricochetLevel + item.effect);
                        this.showMessage(`ë„íƒ„ ì‚¬ê²©!`, `íƒ„í™˜ì´ ë²½ì—ì„œ íŠ•ê²¨ ë‚˜ê°‘ë‹ˆë‹¤! (Lv.${player.ricochetLevel})`, 2000);
                        break;
                    case 'homing_shot':
                        player.homingLevel = Math.min(99, player.homingLevel + item.effect);
                        this.showMessage(`ìœ ë„ ì‚¬ê²©!`, `íƒ„í™˜ì´ ì ì„ ì¶”ì í•©ë‹ˆë‹¤! (Lv.${player.homingLevel})`, 2000);
                        break;
                    case 'split_shot':
                        player.splitLevel = Math.min(99, player.splitLevel + item.effect);
                        this.showMessage(`ë¶„ì—´ ì‚¬ê²©!`, `íƒ„í™˜ì´ ë¶„ì—´í•˜ì—¬ ì¶”ê°€ í”¼í•´ë¥¼ ì¤ë‹ˆë‹¤! (Lv.${player.splitLevel})`, 2000);
                        break;
                    case 'life_steal':
                        player.lifeStealPercent = Math.min(0.2, player.lifeStealPercent + item.effect); // ìµœëŒ€ 20%
                        this.showMessage(`ìƒëª…ë ¥ í¡ìˆ˜!`, `í”¼í•´ëŸ‰ì˜ ${(player.lifeStealPercent * 100).toFixed(0)}% ì²´ë ¥ íšŒë³µ!`, 2000);
                        break;
                    case 'crit_chance':
                        player.critChance = Math.min(0.5, player.critChance + item.effect); // ìµœëŒ€ 50%
                        this.showMessage(`ì¹˜ëª…íƒ€ í™•ë¥ !`, `ì¹˜ëª…íƒ€ í™•ë¥  ${(player.critChance * 100).toFixed(0)}%`, 2000);
                        break;
                    case 'cooldown_reduction':
                        player.cooldownReduction = Math.min(0.5, player.cooldownReduction + item.effect); // ìµœëŒ€ 50%
                        this.showMessage(`ì¬ì‚¬ìš© ëŒ€ê¸°ì‹œê°„ ê°ì†Œ!`, `ë°œì‚¬ ì†ë„ ${(player.cooldownReduction * 100).toFixed(0)}% ì¦ê°€!`, 2000);
                        break;
                    case 'armor':
                        player.armor += item.effect;
                        this.showMessage(`ë°©ì–´ë ¥!`, `í”¼í•´ëŸ‰ ${item.effect} ê°ì†Œ!`, 2000);
                        break;
                    case 'time_stop':
                        this.gameState.timeStopEndTime = now + item.effect;
                        this.gameState.timeSlowEffect = 0; // ëª¨ë“  ì  ì •ì§€
                        this.showMessage(`ì‹œê°„ ì •ì§€!`, `${item.effect / 1000}ì´ˆê°„ ëª¨ë“  ì  ì •ì§€!`, 2000);
                        break;
                    case 'ammo_regen':
                        player.ammoRegenEndTime = now + item.duration;
                        player.lastAmmoRegenTick = now;
                        player.ammoRegenAmount = item.effect;
                        this.showMessage(`íƒ„ì•½ ì¬ìƒ!`, `${item.duration / 1000}ì´ˆê°„ íƒ„ì•½ ìë™ íšŒë³µ!`, 2000);
                        break;
                }
                
                this.createCollectParticles(item.x, item.y, item.color); // ì•„ì´í…œ ìˆ˜ì§‘ íŒŒí‹°í´ ìƒì„±
                this.addScore(50); // ì•„ì´í…œ ìˆ˜ì§‘ ì‹œ ì ìˆ˜ íšë“
                this.updateHUD(); // HUD ì—…ë°ì´íŠ¸
            }
            
            // í”¼ê²© íŒŒí‹°í´ ìƒì„±
            createHitParticles = (x, y) => {
                for (let i = 0; i < 6; i++) {
                    this.gameState.particles.push({
                        x: x, y: y,
                        vx: (Math.random() - 0.5) * 6, // ë¬´ì‘ìœ„ X ì†ë„
                        vy: (Math.random() - 0.5) * 6, // ë¬´ì‘ìœ„ Y ì†ë„
                        life: 30, maxLife: 30, // ìˆ˜ëª…
                        color: '#ff6b6b', // ìƒ‰ìƒ (ë¹¨ê°„ìƒ‰)
                        size: Math.random() * 3 + 1 // í¬ê¸°
                    });
                }
            }
            
            // ì•„ì´í…œ ìˆ˜ì§‘ íŒŒí‹°í´ ìƒì„±
            createCollectParticles = (x, y, color) => {
                for (let i = 0; i < 8; i++) {
                    this.gameState.particles.push({
                        x: x, y: y,
                        vx: (Math.random() - 0.5) * 4, // ë¬´ì‘ìœ„ X ì†ë„
                        vy: (Math.random() - 0.5) * 4, // ë¬´ì‘ìœ„ Y ì†ë„
                        life: 40, maxLife: 40, // ìˆ˜ëª…
                        color: color, // ì•„ì´í…œ ìƒ‰ìƒ
                        size: Math.random() * 4 + 2 // í¬ê¸°
                    });
                }
            }

            // ë– ë‹¤ë‹ˆëŠ” í…ìŠ¤íŠ¸ ìƒì„± (ì²´ë ¥ ë³€í™” ë“±)
            createFloatingText = (x, y, text, color) => {
                this.gameState.floatingTexts.push({
                    x: x,
                    y: y,
                    text: text,
                    color: color,
                    life: 60, // í…ìŠ¤íŠ¸ ìˆ˜ëª… (í”„ë ˆì„)
                    maxLife: 60,
                    vy: -1 // ìœ„ë¡œ ì´ë™í•˜ëŠ” ì†ë„
                });
            }
            
            // íŒŒí‹°í´ ìƒíƒœ ì—…ë°ì´íŠ¸
            updateParticles = () => {
                this.gameState.particles = this.gameState.particles.filter(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vx *= 0.98; // ì†ë„ ê°ì†Œ (ë§ˆì°°)
                    particle.vy *= 0.98; // ì†ë„ ê°ì†Œ (ë§ˆì°°)
                    particle.life--; // ìˆ˜ëª… ê°ì†Œ
                    
                    return particle.life > 0; // ìˆ˜ëª…ì´ ë‚¨ì€ íŒŒí‹°í´ë§Œ ìœ ì§€
                });
            }

            // ë– ë‹¤ë‹ˆëŠ” í…ìŠ¤íŠ¸ ìƒíƒœ ì—…ë°ì´íŠ¸
            updateFloatingTexts = () => {
                this.gameState.floatingTexts = this.gameState.floatingTexts.filter(text => {
                    text.y += text.vy; // ìœ„ë¡œ ì´ë™
                    text.life--; // ìˆ˜ëª… ê°ì†Œ
                    return text.life > 0; // ìˆ˜ëª…ì´ ë‚¨ì€ í…ìŠ¤íŠ¸ë§Œ ìœ ì§€
                });
            }
            
            // ì›¨ì´ë¸Œ ì™„ë£Œ ì²´í¬ (ë³´ìŠ¤ ì‹œìŠ¤í…œ ì œê±°)
            checkWaveComplete = () => {
                // ëª¨ë“  ì ì´ ì£½ì—ˆê³ , ê²Œì„ì´ ì§„í–‰ ì¤‘ì¼ ë•Œ
                if (this.gameState.enemies.length === 0 && this.gameState.gameStatus === 'playing') {
                    this.gameState.gameStatus = 'wave-complete';
                    this.showMessage(`ì›¨ì´ë¸Œ ${this.gameState.wave} ì™„ë£Œ!`, 'ë‹¤ìŒ ì›¨ì´ë¸Œ ì¤€ë¹„ ì¤‘...', 3000);
                    this.gameState.wave++;
                    
                    setTimeout(() => {
                        this.gameState.gameStatus = 'spawning';
                        this.spawnInitialWave();
                        this.gameState.gameStatus = 'playing';
                    }, 3000);
                }
            }
            
            // ê²Œì„ ì˜¤ë²„ ì²˜ë¦¬
            gameOver = () => {
                this.gameState.gameStatus = 'game-over'; // ê²Œì„ ìƒíƒœë¥¼ 'ê²Œì„ ì˜¤ë²„'ë¡œ ë³€ê²½
                this.showMessage('ê²Œì„ ì˜¤ë²„!', `ìµœì¢… ì ìˆ˜: ${this.gameState.score.toLocaleString()}`, 5000, true);
                // ì–´ë–¤ ì ì—ê²Œ ì£½ì—ˆëŠ”ì§€ ì½˜ì†”ì— ì¶œë ¥
                const lastHitById = this.gameState.player.lastHitById;
                if (lastHitById) {
                    // lastHitByIdê°€ ì ì˜ IDì¼ ê²½ìš° í•´ë‹¹ ì ì˜ ì •ë³´ë¥¼ ì°¾ìŒ
                    const killerEnemy = Object.values(this.ENEMY_TYPES).find(enemyType => 
                        this.gameState.enemies.some(enemy => enemy.id === lastHitById && enemy.type === enemyType.type)
                    );
                    if (killerEnemy) {
                        console.log(`í”Œë ˆì´ì–´ê°€ '${killerEnemy.name}'ì—ê²Œ ì‚¬ë§í–ˆìŠµë‹ˆë‹¤.`);
                    } else if (lastHitById === 'player') { // í”Œë ˆì´ì–´ ìŠ¤ìŠ¤ë¡œì—ê²Œ í”¼í•´ë¥¼ ì…ì€ ê²½ìš° (ìˆ˜ë¥˜íƒ„ ë“±)
                        console.log('í”Œë ˆì´ì–´ê°€ ìŠ¤ìŠ¤ë¡œì—ê²Œ í”¼í•´ë¥¼ ì…ì–´ ì‚¬ë§í–ˆìŠµë‹ˆë‹¤.');
                    } else {
                        console.log(`í”Œë ˆì´ì–´ê°€ ì•Œ ìˆ˜ ì—†ëŠ” ì ì—ê²Œ ì‚¬ë§í–ˆìŠµë‹ˆë‹¤ (ID: ${lastHitById}).`);
                    }
                } else {
                    console.log('í”Œë ˆì´ì–´ê°€ ì ì—ê²Œ ì§ì ‘ì ì¸ ê³µê²© ì—†ì´ ì‚¬ë§í–ˆìŠµë‹ˆë‹¤ (ì˜ˆ: ë‚™ì‚¬).');
                }
                // 5ì´ˆ í›„ ê²Œì„ ì¬ì‹œì‘ (ì‹œì‘ í™”ë©´ìœ¼ë¡œ ëŒì•„ê°€ì§€ ì•ŠìŒ)
                const restartBtn = document.getElementById('restartButton');
                restartBtn.style.display = 'block';
                restartBtn.onclick = () => {
                    restartBtn.style.display = 'none';
                    this.resetGame();
                };
            }
            
            // ê²Œì„ ì´ˆê¸°í™”
            resetGame = () => {
                // ê²Œì„ ìƒíƒœë¥¼ ì´ˆê¸°ê°’ìœ¼ë¡œ ì¬ì„¤ì •
                this.gameState = {
                    player: {
                        x: this.canvas.width / 2, y: this.canvas.height / 2,
                        width: 40, height: 40,
                        vx: 0, vy: 0,
                        health: 150, maxHealth: 150, // ê¸°ë³¸ê°’ 100ìœ¼ë¡œ ë³€ê²½
                        ammo: 30, maxAmmo: 30, // ê¸°ë³¸ê°’ 100ìœ¼ë¡œ ë³€ê²½
                        speed: 5, jumpPower: 15,
                        onGround: false, facing: 0,
                        expression: this.getRandomExpression(),
                        color: '#6366f1',
                        baseDamage: 10, // ê¸°ë³¸ê°’ 10ìœ¼ë¡œ ë³€ê²½
                        multishot: 1,
                        rapidFireTime: 0,
                        damageReductionFactor: 1,
                        shieldBoostEndTime: 0,
                        healthRegenEndTime: 0,
                        lastRegenTick: 0,
                        magnetEndTime: 0,
                        magnetRadius: 200,
                        lastHitById: null, // ì´ˆê¸°í™”
                        type: 'player', // í”Œë ˆì´ì–´ íƒ€ì…
                        orbitingKnives: [], // íšŒì „ ì¹¼ë‚  ì´ˆê¸°í™”
                        piercingShot: 0, // ê´€í†µ ì‚¬ê²© ì´ˆê¸°í™”
                        explosiveShot: 0, // í­ë°œ ì‚¬ê²© ì´ˆê¸°í™”
                        ricochetLevel: 0, // ë„íƒ„ ì‚¬ê²© ì´ˆê¸°í™”
                        homingLevel: 0, // ìœ ë„ ì‚¬ê²© ì´ˆê¸°í™”
                        splitLevel: 0, // ë¶„ì—´ ì‚¬ê²© ì´ˆê¸°í™”
                        lifeStealPercent: 0, // ìƒëª…ë ¥ í¡ìˆ˜ ì´ˆê¸°í™”
                        critChance: 0, // ì¹˜ëª…íƒ€ í™•ë¥  ì´ˆê¸°í™”
                        critMultiplier: 1.5, // ì¹˜ëª…íƒ€ ë°°ìœ¨ ì´ˆê¸°í™”
                        cooldownReduction: 0, // ì¬ì‚¬ìš© ëŒ€ê¸°ì‹œê°„ ê°ì†Œ ì´ˆê¸°í™”
                        armor: 0, // ë°©ì–´ë ¥ ì´ˆê¸°í™”
                        timeStopEndTime: 0, // ì‹œê°„ ì •ì§€ ì´ˆê¸°í™”
                        ammoRegenEndTime: 0, // íƒ„ì•½ ì¬ìƒ ì´ˆê¸°í™”
                        lastAmmoRegenTick: 0, // ë§ˆì§€ë§‰ íƒ„ì•½ ì¬ìƒ í‹± ì´ˆê¸°í™”
                        ammoRegenAmount: 0, // íƒ„ì•½ ì¬ìƒëŸ‰ ì´ˆê¸°í™”
                        dashCooldown: 0, // ë§ˆì§€ë§‰ ëŒ€ì‹œ ì‹œê°
                        dashEndTime: 0, // ëŒ€ì‹œ ì¢…ë£Œ ì‹œê°
                        isDashing: false, // ëŒ€ì‹œ ì¤‘ ì—¬ë¶€
                        reloadTime: 1500, // ê¸°ë³¸ ì¬ì¥ì „ ì‹œê°„(ms)
                        isReloading: false,
                        machineGunMode: false, // ê¸°ê´€ë‹¨ì´ íŒ¨ì‹œë¸Œ
                        machineGunPenalty: false, // ê¸°ê´€ë‹¨ì´ íŒ¨ë„í‹°
                        reloadPenalty: 0, // íŒ¨ì‹œë¸Œë¡œ ì¸í•œ ì¶”ê°€ ì¬ì¥ì „ ì‹œê°„(ms)
                        gunRecoil: 0,
                        gunRecoilTarget: 0,
                    },
                    enemies: [],
                    projectiles: [],
                    items: [],
                    particles: [],
                    floatingTexts: [],
                    allies: [], // ì•„êµ° ë°°ì—´ ì´ˆê¸°í™”
                    score: 0,
                    wave: 1,
                    gameStatus: 'playing', // ê²Œì„ ì˜¤ë²„ í›„ ë°”ë¡œ í”Œë ˆì´ ìƒíƒœë¡œ ì „í™˜
                    message: '',
                    messageTimer: 0,
                    playerSlowedEndTime: 0,
                    timeSlowEndTime: 0,
                    timeSlowEffect: 1
                };
                

                
                this.spawnInitialWave(); // ìƒˆ ê²Œì„ ì‹œì‘ ì‹œ ì´ˆê¸° ì›¨ì´ë¸Œ ìƒì„±
                this.updateHUD(); // HUD ì—…ë°ì´íŠ¸ (ì´ˆê¸°í™”ëœ ê°’ìœ¼ë¡œ)
                this.hideMessage(); // ë©”ì‹œì§€ ìˆ¨ê¸°ê¸°
                this.gameLoop(); // ê²Œì„ ë£¨í”„ ì¬ì‹œì‘
            }

            // ê²Œì„ ë©”ì‹œì§€ í‘œì‹œ
            showMessage = (text, subText, duration, showRestart) => {
                const messageEl = document.getElementById('gameMessage');
                const messageTextEl = document.getElementById('messageText');
                const messageSubTextEl = document.getElementById('messageSubText');
                const restartBtn = document.getElementById('restartButton');
                messageTextEl.textContent = text;
                messageSubTextEl.textContent = subText;
                messageEl.style.display = 'block';
                if (showRestart) {
                    restartBtn.style.display = 'block';
                } else if (restartBtn) {
                    restartBtn.style.display = 'none';
                }
                if (!showRestart) {
                    setTimeout(() => {
                        this.hideMessage();
                    }, duration);
                }
            }
            
            // ê²Œì„ ë©”ì‹œì§€ ìˆ¨ê¸°ê¸°
            hideMessage = () => {
                document.getElementById('gameMessage').style.display = 'none';
            }

            // ë³´ìƒ ì„ íƒ í™”ë©´ í‘œì‹œ
            showRewardSelection = (type = 'score') => {
                this.canvas.style.filter = 'blur(10px)';
                document.querySelector('.hud').style.display = 'none';
                document.getElementById('rewardSelectionScreen').style.display = 'flex';
                const titleEl = document.getElementById('rewardSelectionTitle');
                if (type === 'boss') {
                    titleEl.textContent = 'ë³´ìŠ¤ ì²˜ì¹˜! ë³´ìƒì„ ì„ íƒí•˜ì„¸ìš”.';
                } else {
                    titleEl.textContent = 'ì ìˆ˜ ë‹¬ì„±! ë³´ìƒì„ ì„ íƒí•˜ì„¸ìš”.';
                }
                const rewardOptionsEl = document.getElementById('rewardOptions');
                rewardOptionsEl.innerHTML = '';
                const shuffledRewards = [...this.REWARD_OPTIONS].sort(() => 0.5 - Math.random());
                const selectedRewards = shuffledRewards.slice(0, 3);
                selectedRewards.forEach(option => {
                    const button = document.createElement('button');
                    button.className = 'reward-button';
                    button.textContent = option.text;
                    button.addEventListener('click', () => {
                        this.applyReward(option.type, option.value);
                        this.hideRewardSelection();
                        this.gameState.gameStatus = 'playing';
                        this.updateHUD();
                        if (typeof this.gameLoop === 'function') {
                            this.gameLoop();
                        }
                    });
                    rewardOptionsEl.appendChild(button);
                });
            };

            // ë³´ìƒ ì„ íƒ í™”ë©´ ìˆ¨ê¸°ê¸°
            hideRewardSelection = () => {
                this.canvas.style.filter = 'blur(0px)'; // ìº”ë²„ìŠ¤ ë¸”ëŸ¬ ì œê±°
                document.querySelector('.hud').style.display = 'flex'; // HUD í‘œì‹œ
                document.getElementById('rewardSelectionScreen').style.display = 'none'; // ë³´ìƒ í™”ë©´ ìˆ¨ê¹€
            }

            // ì„ íƒëœ ë³´ìƒ ì ìš©
            applyReward = (type, value) => {
                const player = this.gameState.player;
                switch (type) {
                    case 'tank':
                        player.maxHealth += 100;
                        player.health = Math.min(player.maxHealth, player.health + 100);
                        player.speed -= 4;
                        this.showMessage('íƒ±í¬ê°€ ë˜ì–´!', 'ìµœëŒ€ ì²´ë ¥ +100, ì´ë™ ì†ë„ -4', 2000);
                        break;
                    case 'speedster':
                        player.speed += 10;
                        player.dashCooldown = Math.max(0, player.dashCooldown - 10000);
                        player.baseDamage *= 0.95;
                        player.reloadPenalty += 3000;
                        this.showMessage('ë¹¨ë¼ì§„ë‹¤ì•„ì•„ì•„ì•„!', 'ì†ë„ +10, ëŒ€ì‹œ ì¿¨íƒ€ì„ -10ì´ˆ, ê³µê²©ë ¥ -5%, ì¬ì¥ì „ +3ì´ˆ', 2000);
                        break;
                    case 'machine_gun':
                        player.machineGunMode = true;
                        player.machineGunPenalty = true;
                        player.reloadPenalty += 5000;
                        this.showMessage('ê¸°ê´€ë‹¨ì´!', 'ì—°ì‚¬, ì¬ì¥ì „ +5ì´ˆ, ê³µê²©ë ¥ -50%', 2000);
                        break;
                    case 'homing_master':
                        player.homingLevel = 3;
                        player.homingPenalty = true;
                        this.showMessage('ìœ ë„íƒ„!', 'ìœ ë„íƒ„ Lv.3, ê³µê²©ë ¥ -5%', 2000);
                        break;
                    case 'ricochet_shot':
                        player.ricochetLevel = 1;
                        this.showMessage('íƒ±íƒ±ë³¼!', 'ì´ì•Œì´ ë²½ì— íŠ•ê¹€', 2000);
                        break;
                    case 'vampire':
                        player.lifeStealPercent += 0.03;
                        player.reloadPenalty += 2000;
                        this.showMessage('ë±€íŒŒì´ì–´!', 'í¡í˜ˆ, ì¬ì¥ì „ +2ì´ˆ', 2000);
                        break;
                    case 'knife_shield':
                        for (let i = 0; i < 3; i++) {
                            player.orbitingKnives.push({
                                angle: Math.random() * Math.PI * 2,
                                radius: 60,
                                speed: 0.05,
                                damage: 15,
                                lastHit: 0,
                                cooldown: 200,
                                color: this.ITEM_TYPES.find(i => i.type === 'orbiting_knife').color,
                                emoji: this.ITEM_TYPES.find(i => i.type === 'orbiting_knife').emoji
                            });
                        }
                        this.showMessage('ì¹¼ë‚ ì´ ë‚˜ë¥¼ ê°ì‹¸ë„¤!', 'ì¹¼ë‚  3ê°œ ìƒì„±', 2000);
                        break;
                    case 'crit_master':
                        player.critChance += 0.2;
                        player.maxHealth = Math.floor(player.maxHealth * 0.9);
                        player.health = Math.min(player.maxHealth, player.health);
                        this.showMessage('ìŠ¤ì¹˜ê¸°ë§Œ í•´ë„ ì¹˜ëª…íƒ€!', 'ì¹˜ëª…íƒ€ +20%, ì²´ë ¥ -10%', 2000);
                        break;
                    case 'armor':
                        player.armor += 5;
                        this.showMessage('ë°©ì–´ë ¥!', 'í”¼í•´ëŸ‰ 5 ê°ì†Œ', 2000);
                        break;
                    case 'ammo_overflow':
                        player.ammoRegenEndTime = Date.now() + 10000;
                        player.ammoRegenAmount = 10;
                        player.maxAmmo += 20;
                        this.showMessage('íƒ„ì•½ì´ ë„˜ì³!', 'íƒ„ì•½ ìë™ íšŒë³µ, íƒ„ì•½í†µ +20', 2000);
                        break;
                    // ê¸°ì¡´ ë‹¨ìˆœ ë³´ìƒë„ ì§€ì›
                    case 'maxHealth':
                        player.maxHealth += value;
                        player.health = Math.min(player.maxHealth, player.health + value);
                        this.showMessage(`ìµœëŒ€ ì²´ë ¥ +${value}!`, '', 1500);
                        break;
                    case 'currentHealth':
                        player.health = Math.min(player.maxHealth, player.health + value);
                        this.createFloatingText(player.x + player.width / 2, player.y, `+${value}`, 'green');
                        this.showMessage(`ì²´ë ¥ +${value}!`, '', 1500);
                        break;
                    case 'damage':
                        player.baseDamage += value;
                        this.showMessage(`ê³µê²©ë ¥ +${value}!`, '', 1500);
                        break;
                    case 'speed':
                        player.speed += value;
                        this.showMessage(`ì´ë™ ì†ë„ +${value}!`, '', 1500);
                        break;
                    case 'multishot':
                        player.multishot = Math.min(99, (player.multishot || 1) + 1);
                        this.showMessage(`ë‹¤ì¤‘ ë°œì‚¬!`, `${player.multishot}ë°œ ë™ì‹œ ë°œì‚¬`, 2000);
                        break;
                    case 'orbiting_knife':
                        player.orbitingKnives.push({
                            angle: Math.random() * Math.PI * 2,
                            radius: 60,
                            speed: 0.05,
                            damage: 15,
                            lastHit: 0,
                            cooldown: 200,
                            color: this.ITEM_TYPES.find(i => i.type === 'orbiting_knife').color,
                            emoji: this.ITEM_TYPES.find(i => i.type === 'orbiting_knife').emoji
                        });
                        this.showMessage(`íšŒì „ ì¹¼ë‚  íšë“!`, `í”Œë ˆì´ì–´ ì£¼ìœ„ë¥¼ ë•ë‹ˆë‹¤!`, 2000);
                        break;
                    case 'piercing_shot':
                        player.piercingShot = Math.min(99, player.piercingShot + value);
                        this.showMessage(`ê´€í†µ ì‚¬ê²©!`, `íƒ„í™˜ì´ ì ì„ ê´€í†µí•©ë‹ˆë‹¤! (Lv.${player.piercingShot})`, 2000);
                        break;
                    case 'explosive_shot':
                        player.explosiveShot = Math.min(99, player.explosiveShot + value);
                        this.showMessage(`í­ë°œ ì‚¬ê²©!`, `íƒ„í™˜ì´ í­ë°œí•©ë‹ˆë‹¤! (Lv.${player.explosiveShot})`, 2000);
                        break;
                    case 'ricochet_shot':
                        player.ricochetLevel = Math.min(99, player.ricochetLevel + value);
                        this.showMessage(`ë„íƒ„ ì‚¬ê²©!`, `íƒ„í™˜ì´ ë²½ì—ì„œ íŠ•ê²¨ ë‚˜ê°‘ë‹ˆë‹¤! (Lv.${player.ricochetLevel})`, 2000);
                        break;
                    case 'homing_shot':
                        player.homingLevel = Math.min(99, player.homingLevel + value);
                        this.showMessage(`ìœ ë„ ì‚¬ê²©!`, `íƒ„í™˜ì´ ì ì„ ì¶”ì í•©ë‹ˆë‹¤! (Lv.${player.homingLevel})`, 2000);
                        break;
                    case 'split_shot':
                        player.splitLevel = Math.min(99, player.splitLevel + value);
                        this.showMessage(`ë¶„ì—´ ì‚¬ê²©!`, `íƒ„í™˜ì´ ë¶„ì—´í•˜ì—¬ ì¶”ê°€ í”¼í•´ë¥¼ ì¤ë‹ˆë‹¤! (Lv.${player.splitLevel})`, 2000);
                        break;
                    case 'life_steal':
                        player.lifeStealPercent = Math.min(0.2, player.lifeStealPercent + value);
                        this.showMessage(`ìƒëª…ë ¥ í¡ìˆ˜!`, `í”¼í•´ëŸ‰ì˜ ${(player.lifeStealPercent * 100).toFixed(0)}% ì²´ë ¥ íšŒë³µ!`, 2000);
                        break;
                    case 'crit_chance':
                        player.critChance = Math.min(0.5, player.critChance + value);
                        this.showMessage(`ì¹˜ëª…íƒ€ í™•ë¥ !`, `ì¹˜ëª…íƒ€ í™•ë¥  ${(player.critChance * 100).toFixed(0)}%`, 2000);
                        break;
                    case 'cooldown_reduction':
                        player.cooldownReduction = Math.min(0.5, player.cooldownReduction + value);
                        this.showMessage(`ì¬ì‚¬ìš© ëŒ€ê¸°ì‹œê°„ ê°ì†Œ!`, `ë°œì‚¬ ì†ë„ ${(player.cooldownReduction * 100).toFixed(0)}% ì¦ê°€!`, 2000);
                        break;
                    case 'armor':
                        player.armor += value;
                        this.showMessage(`ë°©ì–´ë ¥!`, `í”¼í•´ëŸ‰ ${value} ê°ì†Œ!`, 2000);
                        break;
                    case 'time_stop':
                        this.gameState.timeStopEndTime = Date.now() + value;
                        this.gameState.timeSlowEffect = 0;
                        this.showMessage(`ì‹œê°„ ì •ì§€!`, `${value / 1000}ì´ˆê°„ ëª¨ë“  ì  ì •ì§€!`, 2000);
                        break;
                    case 'ammo_regen':
                        player.ammoRegenEndTime = Date.now() + 5000;
                        player.lastAmmoRegenTick = Date.now();
                        player.ammoRegenAmount = value;
                        this.showMessage(`íƒ„ì•½ ì¬ìƒ!`, `5ì´ˆê°„ íƒ„ì•½ ìë™ íšŒë³µ!`, 2000);
                        break;
                }
                this.updateHUD();
            }
            
            // HUD ì—…ë°ì´íŠ¸ (ì²´ë ¥, íƒ„ì•½, ì ìˆ˜, ì›¨ì´ë¸Œ, ë¯¸ë‹ˆë§µ)
            updateHUD = () => {
                const player = this.gameState.player;
                const now = Date.now();
                
                // ì²´ë ¥ ë°” ì—…ë°ì´íŠ¸
                const healthPercent = (Math.max(0, player.health) / player.maxHealth) * 100;
                document.getElementById('healthFill').style.width = healthPercent + '%';
                document.getElementById('healthText').textContent = `${Math.max(0, player.health.toFixed(0))}/${player.maxHealth.toFixed(0)}`;
                
                // íƒ„ì•½ ë°” ì—…ë°ì´íŠ¸
                const ammoPercent = (player.ammo / player.maxAmmo) * 100;
                document.getElementById('ammoFill').style.width = ammoPercent + '%';
                document.getElementById('ammoText').textContent = `${player.ammo.toFixed(0)}/${player.maxAmmo.toFixed(0)}`;
                
                // ì ìˆ˜ ë° ì›¨ì´ë¸Œ ì—…ë°ì´íŠ¸
                document.getElementById('scoreText').textContent = this.gameState.score.toLocaleString();
                document.getElementById('waveText').textContent = `ì›¨ì´ë¸Œ ${this.gameState.wave}`;
                document.getElementById('enemyCount').textContent = `ì : ${this.gameState.enemies.length}ë§ˆë¦¬`;

                // ìƒˆë¡œìš´ ìŠ¤íƒ¯ ì—…ë°ì´íŠ¸
                document.getElementById('speedText').textContent = player.speed;
                document.getElementById('damageText').textContent = player.baseDamage;
                document.getElementById('multishotText').textContent = player.multishot;

                // í™œì„± íš¨ê³¼ ì—…ë°ì´íŠ¸
                const invincibilityEl = document.getElementById('invincibilityEffect');
                const shieldBoostEl = document.getElementById('shieldBoostEffect');
                const timeSlowEl = document.getElementById('timeSlowEffect');
                const magnetEl = document.getElementById('magnetEffect');
                const healthRegenEl = document.getElementById('healthRegenEffect');
                const rapidFireEl = document.getElementById('rapidFireEffect');
                const piercingShotEl = document.getElementById('piercingShotEffect'); 
                const explosiveShotEl = document.getElementById('explosiveShotEffect'); 
                const orbitingKnivesEl = document.getElementById('orbitingKnivesEffect'); 
                const ricochetShotEl = document.getElementById('ricochetShotEffect'); 
                const homingShotEl = document.getElementById('homingShotEffect'); 
                const splitShotEl = document.getElementById('splitShotEffect'); 
                const ammoRegenEl = document.getElementById('ammoRegenEffect');
                const timeStopEl = document.getElementById('timeStopEffect');
                const dashEl = document.getElementById('dashEffect');

                invincibilityEl.textContent = now < player.invincibleEndTime ? `ë¬´ì : ${( (player.invincibleEndTime - now) / 1000).toFixed(1)}ì´ˆ` : '';
                shieldBoostEl.textContent = now < player.shieldBoostEndTime ? `ì‰´ë“œ ê°•í™”: ${( (player.shieldBoostEndTime - now) / 1000).toFixed(1)}ì´ˆ (${(1 - player.damageReductionFactor) * 100}% ê°ì†Œ)` : '';
                timeSlowEl.textContent = now < this.gameState.timeSlowEndTime && this.gameState.timeSlowEffect > 0 ? `ì‹œê°„ ë‘”í™”: ${( (this.gameState.timeSlowEndTime - now) / 1000).toFixed(1)}ì´ˆ` : '';
                magnetEl.textContent = now < player.magnetEndTime ? `ìì„: ${( (player.magnetEndTime - now) / 1000).toFixed(1)}ì´ˆ` : '';
                healthRegenEl.textContent = now < player.healthRegenEndTime ? `ì²´ë ¥ ì¬ìƒ: ${( (player.healthRegenEndTime - now) / 1000).toFixed(1)}ì´ˆ` : '';
                rapidFireEl.textContent = now < player.rapidFireTime ? `ì—°ë°œ: ${( (player.rapidFireTime - now) / 1000).toFixed(1)}ì´ˆ` : '';
                piercingShotEl.textContent = player.piercingShot > 0 ? `ê´€í†µ ì‚¬ê²©: ${player.piercingShot}íšŒ` : '';
                explosiveShotEl.textContent = player.explosiveShot > 0 ? `í­ë°œ ì‚¬ê²©: Lv.${player.explosiveShot}` : '';
                orbitingKnivesEl.textContent = player.orbitingKnives.length > 0 ? `íšŒì „ ì¹¼ë‚ : ${player.orbitingKnives.length}ê°œ` : '';
                ricochetShotEl.textContent = player.ricochetLevel > 0 ? `ë„íƒ„ ì‚¬ê²©: Lv.${player.ricochetLevel}` : '';
                homingShotEl.textContent = player.homingLevel > 0 ? `ìœ ë„ ì‚¬ê²©: Lv.${player.homingLevel}` : '';
                splitShotEl.textContent = player.splitLevel > 0 ? `ë¶„ì—´ ì‚¬ê²©: Lv.${player.splitLevel}` : '';
                ammoRegenEl.textContent = now < player.ammoRegenEndTime ? `íƒ„ì•½ ì¬ìƒ: ${( (player.ammoRegenEndTime - now) / 1000).toFixed(1)}ì´ˆ` : '';
                timeStopEl.textContent = now < this.gameState.timeStopEndTime ? `ì‹œê°„ ì •ì§€: ${( (this.gameState.timeStopEndTime - now) / 1000).toFixed(1)}ì´ˆ` : '';
                if (dashEl) {
                    if (player.isDashing) dashEl.textContent = `ëŒ€ì‹œ: ë¬´ì !`;
                    else if (now - player.dashCooldown < 1000) dashEl.textContent = `ëŒ€ì‹œ ì¿¨íƒ€ì„: ${((1000 - (now - player.dashCooldown))/1000).toFixed(1)}ì´ˆ`;
                    else dashEl.textContent = '';
                }


                // íŒ¨ì‹œë¸Œ ìŠ¤í‚¬ ì—…ë°ì´íŠ¸
                const lifeStealEl = document.getElementById('lifeStealEffect');
                const critChanceEl = document.getElementById('critChanceEffect');
                const cooldownReductionEl = document.getElementById('cooldownReductionEffect');
                const armorEl = document.getElementById('armorEffect');

                lifeStealEl.textContent = player.lifeStealPercent > 0 ? `ìƒëª…ë ¥ í¡ìˆ˜: ${(player.lifeStealPercent * 100).toFixed(0)}%` : '';
                critChanceEl.textContent = player.critChance > 0 ? `ì¹˜ëª…íƒ€ í™•ë¥ : ${(player.critChance * 100).toFixed(0)}%` : '';
                cooldownReductionEl.textContent = player.cooldownReduction > 0 ? `ì¬ì‚¬ìš© ëŒ€ê¸°ì‹œê°„ ê°ì†Œ: ${(player.cooldownReduction * 100).toFixed(0)}%` : '';
                armorEl.textContent = player.armor > 0 ? `ë°©ì–´ë ¥: ${player.armor}` : '';

                // ë¯¸ë‹ˆë§µ ì—…ë°ì´íŠ¸
                this.updateMinimap();


                // 5. updateHUDì— XP í‘œì‹œ ì¶”ê°€
                document.getElementById('xpText').textContent = `XP: ${this.xp}`;
            }
            
            // ë¯¸ë‹ˆë§µ ì—…ë°ì´íŠ¸ (í”Œë ˆì´ì–´, ì , ì•„ì´í…œ ìœ„ì¹˜ í‘œì‹œ)
            updateMinimap = () => {
                const minimapPlayer = document.getElementById('minimapPlayer');
                const minimap = document.getElementById('minimap');
                
                // í”Œë ˆì´ì–´ ìœ„ì¹˜ ê³„ì‚° ë° ì—…ë°ì´íŠ¸
                const playerX = (this.gameState.player.x / this.canvas.width) * 120;
                const playerY = (this.gameState.player.y / this.canvas.height) * 120;
                
                minimapPlayer.style.left = playerX + 'px';
                minimapPlayer.style.top = playerY + 'px';
                
                // ê¸°ì¡´ ì /ì•„ì´í…œ ë„íŠ¸ ì œê±°
                const existingDots = minimap.querySelectorAll('.minimap-enemy, .minimap-item, .minimap-ally');
                existingDots.forEach(dot => dot.remove());
                
                // ì  ë„íŠ¸ ì¶”ê°€
                this.gameState.enemies.forEach(enemy => {
                    const enemyX = (enemy.x / this.canvas.width) * 120;
                    const enemyY = (enemy.y / this.canvas.height) * 120;
                    
                    const dot = document.createElement('div');
                    dot.className = 'minimap-enemy';
                    dot.style.left = enemyX + 'px';
                    dot.style.top = enemyY + 'px';
                    minimap.appendChild(dot);
                });
                
                // ì•„ì´í…œ ë„íŠ¸ ì¶”ê°€
                this.gameState.items.forEach(item => {
                    const itemX = (item.x / this.canvas.width) * 120;
                    const itemY = (item.y / this.canvas.height) * 120;
                    
                    const dot = document.createElement('div');
                    dot.className = 'minimap-item';
                    dot.style.left = itemX + 'px';
                    dot.style.top = itemY + 'px';
                    minimap.appendChild(dot);
                });

                // ì•„êµ° ë„íŠ¸ ì¶”ê°€
                this.gameState.allies.forEach(ally => {
                    const allyX = (ally.x / this.canvas.width) * 120;
                    const allyY = (ally.y / this.canvas.height) * 120;
                    
                    const dot = document.createElement('div');
                    dot.className = 'minimap-ally'; // ìƒˆë¡œìš´ í´ë˜ìŠ¤
                    dot.style.left = allyX + 'px';
                    dot.style.top = allyY + 'px';
                    dot.style.backgroundColor = ally.color; // ì•„êµ° ìƒ‰ìƒ
                    dot.style.width = '3px';
                    dot.style.height = '3px';
                    dot.style.borderRadius = '50%';
                    minimap.appendChild(dot);
                });
            }
            
            // ìºë¦­í„° (í”Œë ˆì´ì–´ ë° ì ) ê·¸ë¦¬ê¸° (ìœ ë ¹ ë¬´ì  ìƒíƒœ ì‹œ ì‹œê°ì  íš¨ê³¼ ì¶”ê°€)
            drawCharacter = (character) => {
                this.ctx.save(); // í˜„ì¬ ìº”ë²„ìŠ¤ ìƒíƒœ ì €ì¥
                
                // ê·¸ë¦¼ì ê·¸ë¦¬ê¸° (ë³€í™˜ ì „)
                this.ctx.globalAlpha = 0.2;
                this.ctx.fillStyle = 'black';
                this.ctx.fillRect(character.x + 3, character.y + character.height + 3, character.width, 5);
                
                // í”Œë ˆì´ì–´ ìºë¦­í„° ê·¸ë¦¬ê¸° (ë³€í™˜ ì ìš©)
                if (character.type === 'player') {
                    // ìºë¦­í„°ì˜ ì¤‘ì‹¬ìœ¼ë¡œ ìº”ë²„ìŠ¤ ì›ì  ì´ë™
                    this.ctx.translate(character.x + character.width / 2, character.y + character.height / 2);
                    // ë§ˆìš°ìŠ¤ ë°©í–¥ìœ¼ë¡œ í”Œë ˆì´ì–´ íšŒì „ (ìºë¦­í„°ì˜ ê¸°ë³¸ ë°©í–¥ì´ ì˜¤ë¥¸ìª½ì´ë¼ê³  ê°€ì •í•˜ê³  180ë„ íšŒì „ ë³´ì •)
                    this.ctx.rotate(character.facing + Math.PI); 

                    // ìºë¦­í„° ëª¸ì²´ (ê¸€ë˜ìŠ¤ íš¨ê³¼)
                    this.ctx.globalAlpha = 0.8;
                    this.ctx.fillStyle = character.color;
                    this.ctx.shadowBlur = 15;
                    this.ctx.shadowColor = character.color;
                    this.ctx.beginPath();
                    this.ctx.roundRect(-character.width / 2, -character.height / 2, character.width, character.height, 8);
                    this.ctx.fill();

                    // ê¸€ë˜ìŠ¤ íš¨ê³¼
                    this.ctx.globalAlpha = 0.3;
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    this.ctx.beginPath();
                    this.ctx.roundRect(-character.width / 2, -character.height / 2, character.width, character.height / 2, 8);
                    this.ctx.fill();

                    // í‘œì • ê·¸ë¦¬ê¸°
                    this.ctx.globalAlpha = 1;
                    this.ctx.fillStyle = 'white';
                    const fontSize = '16px';
                    this.ctx.font = `${fontSize} Poppins`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(character.expression, 0, 0); // ìƒˆë¡œìš´ ì›ì (0,0)ì— ê·¸ë¦¬ê¸°

                    // í”Œë ˆì´ì–´ ì´ ì´ëª¨ì§€ ê·¸ë¦¬ê¸° (í•­ìƒ ì™¼ì†ì— ê³ ì •)
                    this.ctx.font = '20px Poppins'; // ì´ ì´ëª¨ì§€ í¬ê¸°
                    this.ctx.fillStyle = 'black'; // ì´ ìƒ‰ìƒ ê²€ì •ìƒ‰ìœ¼ë¡œ ë³€ê²½
                    
                    // ì´ ì´ëª¨ì§€ë¥¼ í”Œë ˆì´ì–´ì˜ ì™¼ìª½ (ìºë¦­í„° ì¤‘ì‹¬ ê¸°ì¤€ ì™¼ìª½)ì— ê³ ì •
                    const gunOffsetX = -character.width / 2 - 10; // ìºë¦­í„° ì™¼ìª½ ëì—ì„œ 10px ë” ì™¼ìª½
                    const weaponEmoji = (this.currentWeapon === 'melee') ? 'ğŸ”ª' : 'ğŸ”«';
                    this.ctx.fillText(weaponEmoji, gunOffsetX, 0); // ê³„ì‚°ëœ ì˜¤í”„ì…‹ì— ì´ ê·¸ë¦¬ê¸°

                } else {
                    // ë¹„-í”Œë ˆì´ì–´ ìºë¦­í„° (ì , ì•„êµ°) ê·¸ë¦¬ê¸° (ë³€í™˜ ì—†ìŒ)
                    // ìºë¦­í„° ëª¸ì²´ (ê¸€ë˜ìŠ¤ íš¨ê³¼)
                    this.ctx.globalAlpha = 0.8;
                    this.ctx.fillStyle = character.color;
                    
                    // ë³´ìŠ¤ëŠ” ë” ê°•í•œ ê¸€ë¡œìš° íš¨ê³¼, ìœ ë ¹ì€ ë¬´ì  ìƒíƒœ ì‹œ ë‹¤ë¥¸ íš¨ê³¼
                    if (character.type && character.type.startsWith('boss')) { // ëª¨ë“  ë³´ìŠ¤ íƒ€ì…ì— ì ìš©
                        this.ctx.shadowBlur = 25;
                        this.ctx.shadowColor = character.color;
                        if (character.type === 'boss_beta' && character.isInvincible) { // ë² íƒ€ ë³´ìŠ¤ ì‰´ë“œ ì‹œ
                            this.ctx.globalAlpha = 0.4;
                            this.ctx.shadowBlur = 15;
                            this.ctx.shadowColor = 'rgba(135, 206, 235, 0.8)'; // ìŠ¤ì¹´ì´ë¸”ë£¨ ê¸€ë¡œìš°
                        }
                    } else if (character.type === 'ghost' && character.isInvincible) {
                        this.ctx.globalAlpha = 0.4; // ë¬´ì  ìƒíƒœ ì‹œ ë°˜íˆ¬ëª…
                        this.ctx.shadowBlur = 10;
                        this.ctx.shadowColor = 'rgba(255, 255, 255, 0.7)'; // í°ìƒ‰ ê¸€ë¡œìš°
                    } else if (character.type === 'berserker' && character.isRaging) {
                        this.ctx.shadowBlur = 20;
                        this.ctx.shadowColor = 'red'; // ê´‘ì „ì‚¬ ê´‘í­í™” ì‹œ ë¶‰ì€ ê¸€ë¡œìš°
                    }
                    else {
                        this.ctx.shadowBlur = 15;
                        this.ctx.shadowColor = character.color;
                    }
                    
                    this.ctx.beginPath();
                    this.ctx.roundRect(character.x, character.y, character.width, character.height, 8);
                    this.ctx.fill();
                    
                    // ê¸€ë˜ìŠ¤ íš¨ê³¼
                    this.ctx.globalAlpha = 0.3;
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    this.ctx.beginPath();
                    this.ctx.roundRect(character.x, character.y, character.width, character.height / 2, 8);
                    this.ctx.fill();
                    
                    // í‘œì • ê·¸ë¦¬ê¸°
                    this.ctx.globalAlpha = 1;
                    this.ctx.fillStyle = 'white';
                    
                    // ë³´ìŠ¤ëŠ” ë” í° í°íŠ¸
                    const fontSize = character.type && character.type.startsWith('boss') ? '20px' : '16px'; // character.type ì²´í¬ ì¶”ê°€
                    this.ctx.font = `${fontSize} Poppins`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(character.expression, character.x + character.width / 2, character.y + character.height / 2);
                    
                    // ì  íƒ€ì… í‘œì‹œ (ì‘ì€ ì•„ì´ì½˜)
                    if (character.type && character !== this.gameState.player) { // character.type ì²´í¬ ì¶”ê°€
                        this.ctx.font = '10px Poppins';
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        let typeIcon = '';
                        switch (character.type) {
                            case 'fast': typeIcon = 'âš¡'; break;
                            case 'tank': typeIcon = 'ğŸ›¡'; break;
                            case 'sniper': typeIcon = 'ğŸ¯'; break;
                            case 'bomber': typeIcon = 'ğŸ’£'; break;
                            case 'guardian': typeIcon = 'ğŸ›¡ï¸'; break;
                            case 'assassin': typeIcon = 'ğŸ—¡'; break;
                            case 'heavy': typeIcon = 'ğŸ’ª'; break;
                            case 'ghost': typeIcon = 'ğŸ‘»'; break; 
                            case 'medic': typeIcon = 'â•'; break; 
                            case 'summoner': typeIcon = 'ğŸŒ€'; break; 
                            case 'jumper': typeIcon = 'â¬†ï¸'; break; 
                            case 'shielded': typeIcon = 'ğŸ›¡ï¸'; break; 
                            case 'teleporter': typeIcon = 'ğŸ’«'; break; 
                            case 'drone': typeIcon = 'ğŸ“¡'; break; 
                            case 'spitter': typeIcon = 'ğŸ¦ '; break; 
                            case 'berserker': typeIcon = 'ğŸ’¢'; break; 
                            case 'boss_alpha': typeIcon = 'Î±'; break; // ì•ŒíŒŒ ë³´ìŠ¤ ì•„ì´ì½˜
                            case 'boss_beta': typeIcon = 'Î²'; break; // ë² íƒ€ ë³´ìŠ¤ ì•„ì´ì½˜
                            case 'boss_gamma': typeIcon = 'Î³'; break; // ê°ë§ˆ ë³´ìŠ¤ ì•„ì´ì½˜
                            case 'ally': typeIcon = 'ğŸ¤–'; break; // ì•„êµ° ì•„ì´ì½˜
                            default: typeIcon = ''; break;
                        }
                        if (typeIcon) {
                            this.ctx.fillText(typeIcon, character.x + character.width - 8, character.y + 8);
                        }
                    }
                    
                    // ì²´ë ¥ ë°” ê·¸ë¦¬ê¸°
                    if (character.health < character.maxHealth || (character.type && character.type.startsWith('boss')) || character.type === 'ally') { // ë³´ìŠ¤, ì•„êµ°ë„ í•­ìƒ ì²´ë ¥ë°” í‘œì‹œ
                        const barWidth = character.width;
                        const barHeight = (character.type && character.type.startsWith('boss')) ? 6 : 4; // character.type ì²´í¬ ì¶”ê°€
                        const barX = character.x;
                        const barY = character.y - 12;
                        
                        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                        this.ctx.fillRect(barX, barY, barWidth, barHeight);
                        
                        let healthColor;
                        if (character === this.gameState.player) {
                            healthColor = '#22c55e';
                        } else if (character.type && character.type.startsWith('boss')) { // character.type ì²´í¬ ì¶”ê°€
                            healthColor = '#dc2626';
                        } else if (character.type === 'ally') { // ì•„êµ° ì²´ë ¥ë°” ìƒ‰ìƒ
                            healthColor = '#90ee90';
                        } else {
                            healthColor = character.color;
                        }
                        
                        this.ctx.fillStyle = healthColor;
                        this.ctx.fillRect(barX, barY, (character.health / character.maxHealth) * barWidth, barHeight);
                    }
                }
                
                this.ctx.restore(); // ì €ì¥ëœ ìº”ë²„ìŠ¤ ìƒíƒœ ë³µì›
            }

            // íšŒì „ ì¹¼ë‚  ê·¸ë¦¬ê¸° ë° ì¶©ëŒ ê°ì§€
            drawOrbitingKnives = () => {
                const player = this.gameState.player;
                const now = Date.now();

                player.orbitingKnives.forEach(knife => {
                    // ê°ë„ ì—…ë°ì´íŠ¸ (ì‹œê°„ ë‘”í™” íš¨ê³¼ ì ìš©)
                    knife.angle += knife.speed * (this.gameState.timeSlowEffect < 1 ? this.gameState.timeSlowEffect : 1);

                    // ì¹¼ë‚  ìœ„ì¹˜ ê³„ì‚°
                    const knifeX = player.x + player.width / 2 + Math.cos(knife.angle) * knife.radius;
                    const knifeY = player.y + player.height / 2 + Math.sin(knife.angle) * knife.radius;

                    // ì¹¼ë‚  ê·¸ë¦¬ê¸°
                    this.ctx.save();
                    this.ctx.globalAlpha = 0.9;
                    this.ctx.fillStyle = knife.color;
                    this.ctx.shadowBlur = 10;
                    this.ctx.shadowColor = knife.color;
                    this.ctx.beginPath();
                    this.ctx.roundRect(knifeX - 5, knifeY - 5, 10, 10, 2); // ì‘ì€ ì‚¬ê°í˜•ìœ¼ë¡œ ì¹¼ë‚  í‘œí˜„
                    this.ctx.fill();
                    this.ctx.globalAlpha = 1;
                    this.ctx.font = '12px Poppins';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(knife.emoji, knifeX, knifeY);
                    this.ctx.restore();

                    // ì ê³¼ì˜ ì¶©ëŒ ê°ì§€
                    this.gameState.enemies = this.gameState.enemies.filter(enemy => {
                        const dx = knifeX - (enemy.x + enemy.width / 2);
                        const dy = knifeY - (enemy.y + enemy.height / 2);
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        // ì¿¨ë‹¤ìš´ ì²´í¬ ë° ì¶©ëŒ ë²”ìœ„ ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
                        if (distance < 15 + enemy.width / 2 && now - knife.lastHit > knife.cooldown) { // 15ëŠ” ì¹¼ë‚ ì˜ ëŒ€ëµì ì¸ ë°˜ì§€ë¦„
                            // ìœ ë ¹, ë°©íŒ¨ë³‘, ë² íƒ€ ë³´ìŠ¤ ì‰´ë“œ ë¬´ì  ìƒíƒœ ì²´í¬
                            if (enemy.type === 'ghost' && enemy.isInvincible) return true;
                            if (enemy.type === 'boss_beta' && enemy.isInvincible) return true;

                            let actualDamage = knife.damage;
                            if (enemy.type === 'shielded') {
                                const angleToKnife = Math.atan2(dy, dx);
                                const angleDiff = Math.abs(angleToKnife - enemy.facing);
                                if (angleDiff < enemy.shieldAngle || angleDiff > (2 * Math.PI - enemy.shieldAngle)) {
                                    // ë°©íŒ¨ë³‘ì´ ì¹¼ë‚ ì„ ë°©ì–´í•˜ëŠ” ë°©í–¥ì— ìˆìœ¼ë©´ í”¼í•´ ê°ì†Œ
                                    actualDamage *= 0.1;
                                    this.createFloatingText(enemy.x + enemy.width / 2, enemy.y, `-${actualDamage.toFixed(0)} (ë°©ì–´)`, 'orange');
                                } else {
                                    this.createFloatingText(enemy.x + enemy.width / 2, enemy.y, `-${actualDamage.toFixed(0)}`, 'white');
                                }
                            } else {
                                this.createFloatingText(enemy.x + enemy.width / 2, enemy.y, `-${actualDamage.toFixed(0)}`, 'white');
                            }
                            enemy.health -= actualDamage;

                            this.createHitParticles(knifeX, knifeY);
                            knife.lastHit = now; // ì´ ì¹¼ë‚ ì˜ ë§ˆì§€ë§‰ ê³µê²© ì‹œê°„ ì—…ë°ì´íŠ¸

                            // ìƒëª…ë ¥ í¡ìˆ˜ (Life Steal) ì ìš©
                            if (player.lifeStealPercent > 0) {
                                const healedAmount = actualDamage * player.lifeStealPercent;
                                player.health = Math.min(player.maxHealth, player.health + healedAmount);
                                this.createFloatingText(player.x + player.width / 2, player.y - 20, `+${healedAmount.toFixed(0)} í¡ìˆ˜`, 'lightgreen');
                            }

                            if (enemy.health <= 0) {
                                this.addScore(enemy.points);
                                if (Math.random() < 0.4) this.gameState.items.push(this.createItem(enemy.x, enemy.y));
                                this.gameState.enemies = this.gameState.enemies.filter(e => e !== enemy);
                                return false; // ì  ì œê±°
                            }
                        }
                        return true; // ì  ìœ ì§€
                    });
                });
            }
            
            // ë°œì‚¬ì²´ ê·¸ë¦¬ê¸°
            drawProjectile = (projectile) => {
                this.ctx.save();
                this.ctx.globalAlpha = 0.8;
                this.ctx.fillStyle = projectile.color;
                this.ctx.shadowBlur = 8;
                this.ctx.shadowColor = projectile.color;
                this.ctx.beginPath();
                this.ctx.arc(projectile.x, projectile.y, projectile.radius, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.restore();
            }
            
            // ì•„ì´í…œ ê·¸ë¦¬ê¸°
            drawItem = (item) => {
                this.ctx.save();
                this.ctx.globalAlpha = 0.9;
                this.ctx.fillStyle = item.color;
                this.ctx.shadowBlur = 10;
                this.ctx.shadowColor = item.color;
                this.ctx.beginPath();
                this.ctx.roundRect(item.x, item.y, item.width, item.height, 4);
                this.ctx.fill();
                
                // ì•„ì´í…œ ì•„ì´ì½˜ ê·¸ë¦¬ê¸°
                this.ctx.globalAlpha = 1;
                this.ctx.font = '12px Poppins';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(item.emoji, item.x + item.width / 2, item.y + item.height / 2);
                
                this.ctx.restore();
            }
            
            // íŒŒí‹°í´ ê·¸ë¦¬ê¸°
            drawParticle = (particle) => {
                this.ctx.save();
                this.ctx.globalAlpha = particle.life / particle.maxLife; // ìˆ˜ëª…ì— ë”°ë¼ íˆ¬ëª…ë„ ì¡°ì ˆ
                this.ctx.fillStyle = particle.color;
                this.ctx.beginPath();
                this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.restore();
            }

            // ë– ë‹¤ë‹ˆëŠ” í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸°
            drawFloatingText = (text) => {
                this.ctx.save();
                this.ctx.globalAlpha = text.life / text.maxLife; // ìˆ˜ëª…ì— ë”°ë¼ íˆ¬ëª…ë„ ì¡°ì ˆ
                this.ctx.fillStyle = text.color;
                this.ctx.font = 'bold 16px Poppins';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(text.text, text.x, text.y);
                this.ctx.restore();
            }
            
            // ë°°ê²½ ê·¸ë¦¬ê¸°
            drawBackground = () => {
                // ë°°ê²½ ê·¸ë¼ë°ì´ì…˜
                const gradient = this.ctx.createLinearGradient(0, 0, this.canvas.width, this.canvas.height);
                gradient.addColorStop(0, '#667eea');
                gradient.addColorStop(1, '#764ba2');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // ì§€ë©´ ê·¸ë¦¬ê¸°
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                this.ctx.fillRect(0, this.canvas.height - this.GROUND_Y, this.canvas.width, this.GROUND_Y);
            }
            
            // ëª¨ë“  ê²Œì„ ìš”ì†Œ ë Œë”ë§
            render = () => {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); // ìº”ë²„ìŠ¤ ì´ˆê¸°í™”
                
                this.drawBackground(); // ë°°ê²½ ê·¸ë¦¬ê¸°
                
                // ìºë¦­í„° ê·¸ë¦¬ê¸°
                this.drawCharacter(this.gameState.player);
                this.gameState.enemies.forEach(enemy => this.drawCharacter(enemy));
                this.gameState.allies.forEach(ally => this.drawCharacter(ally));
                
                // íšŒì „ ì¹¼ë‚  ê·¸ë¦¬ê¸° ë° ì¶©ëŒ
                this.drawOrbitingKnives();
                
                // íŒŒí‹°í´ ê·¸ë¦¬ê¸°
                this.gameState.particles.forEach(particle => this.drawParticle(particle));
                
                // ë°œì‚¬ì²´ ê·¸ë¦¬ê¸°
                this.gameState.projectiles.forEach(projectile => this.drawProjectile(projectile));
                
                // ì•„ì´í…œ ê·¸ë¦¬ê¸°
                this.gameState.items.forEach(item => this.drawItem(item));
                
                // ë– ë‹¤ë‹ˆëŠ” í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸°
                this.gameState.floatingTexts.forEach(text => this.drawFloatingText(text));
                
                // íŒŒí‹°í´ ìƒíƒœ ì—…ë°ì´íŠ¸
                this.updateParticles();
                
                // ë°œì‚¬ì²´ ìƒíƒœ ì—…ë°ì´íŠ¸ ë° ì¶©ëŒ ê°ì§€
                this.updateProjectiles();
                
                // ì•„ì´í…œ ìƒíƒœ ì—…ë°ì´íŠ¸ ë° í”Œë ˆì´ì–´ ì¶©ëŒ ê°ì§€
                this.updateItems();
                
                // HUD ì—…ë°ì´íŠ¸
                this.updateHUD();
                this.updateFloatingTexts();
            }
            // ê²Œì„ ë£¨í”„
            gameLoop = () => {
                // ì‹œê°„ ì •ì§€/ë‘”í™” í•´ì œ ì²´í¬
                const now = Date.now();
                if (now > this.gameState.timeStopEndTime && now > this.gameState.timeSlowEndTime) {
                    this.gameState.timeSlowEffect = 1;
                } else if (now > this.gameState.timeStopEndTime && now < this.gameState.timeSlowEndTime) {
                    this.gameState.timeSlowEffect = 0.5;
                } else if (now < this.gameState.timeStopEndTime) {
                    this.gameState.timeSlowEffect = 0;
                } else if (now < this.gameState.timeSlowEndTime) {
                    this.gameState.timeSlowEffect = 0.5;
                }
                // 1. ìƒíƒœ ì—…ë°ì´íŠ¸
                this.updateCharacter(this.gameState.player);
                this.gameState.enemies.forEach(e => this.updateCharacter(e));
                this.gameState.allies.forEach(a => this.updateCharacter(a));
                // 2. ì›¨ì´ë¸Œ ì™„ë£Œ ì²´í¬
                this.checkWaveComplete();
                // 3. ë Œë”ë§
                this.render();
                // 4. ë‹¤ìŒ í”„ë ˆì„ ì˜ˆì•½
                if (this.gameState.gameStatus === 'playing' || this.gameState.gameStatus === 'wave-complete') {
                    requestAnimationFrame(this.gameLoop);
                }
            }

            // 1. Add addScore method to GlassCombatArena
            addScore = (amount) => {
                this.gameState.score += amount;
                this.updateHUD();
                while (this.nextMilestoneIndex < this.scoreMilestones.length && this.gameState.score >= this.scoreMilestones[this.nextMilestoneIndex]) {
                    this.pauseGameForReward();
                    this.nextMilestoneIndex++;
                }
            };

            pauseGameForReward = () => {
                this.gameState.gameStatus = 'reward-selection';
                this.showRewardSelection('score');
            };

            updateShopList = () => {
                const shopList = document.getElementById('shopList');
                shopList.innerHTML = '';
                this.SHOP_ITEMS.forEach(item => {
                    const affordable = this.gameState.score >= item.price;
                    const itemDiv = document.createElement('div');
                    itemDiv.style.display = 'flex';
                    itemDiv.style.justifyContent = 'space-between';
                    itemDiv.style.alignItems = 'center';
                    itemDiv.style.margin = '10px 0';
                    itemDiv.style.padding = '10px 0';
                    itemDiv.style.borderBottom = '1px solid rgba(255,255,255,0.15)';
                    itemDiv.style.color = '#fff';
                    const label = document.createElement('span');
                    label.textContent = `${item.text}`;
                    const price = document.createElement('span');
                    price.textContent = `${item.price}ì `;
                    price.style.marginLeft = '16px';
                    price.style.color = affordable ? '#ffe066' : '#aaa';
                    price.style.fontWeight = 'normal';
                    const buyBtn = document.createElement('button');
                    buyBtn.textContent = affordable ? 'êµ¬ë§¤' : 'êµ¬ë§¤ë¶ˆê°€';
                    buyBtn.disabled = !affordable;
                    buyBtn.style.marginLeft = '18px';
                    buyBtn.style.background = affordable ? '#ffe066' : '#888';
                    buyBtn.style.color = '#222';
                    buyBtn.style.fontWeight = 'bold';
                    buyBtn.style.border = 'none';
                    buyBtn.style.borderRadius = '8px';
                    buyBtn.style.padding = '6px 18px';
                    buyBtn.style.cursor = affordable ? 'pointer' : 'not-allowed';
                    buyBtn.onclick = () => {
                        if (this.gameState.score >= item.price) {
                            this.gameState.score -= item.price;
                            this.applyReward(item.type, item.value);
                            this.updateHUD();
                            this.updateShopList();
                        }
                    };
                    itemDiv.appendChild(label);
                    itemDiv.appendChild(price);
                    itemDiv.appendChild(buyBtn);
                    shopList.appendChild(itemDiv);
                });
            };
        }

        // === Add after GlassCombatArena class definition or at the end of the script ===
        window.onload = function() {
          // Hide startScreen, show introScreen
          document.getElementById('startScreen').style.display = 'none';
          document.getElementById('introScreen').style.display = 'flex';

          // Attach event listener to Solo Play button
          document.getElementById('soloButton').onclick = function() {
            document.getElementById('introScreen').style.display = 'none';
            if (window.game && typeof window.game.startGame === 'function') {
              window.game.startGame();
            }
          };
          // (Optional) Disable multiButton for now
          document.getElementById('multiButton').onclick = function() {
            document.getElementById('multiInfo').style.display = 'block';
          };
          // ìƒì  ì—´ê¸°/ë‹«ê¸° ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
          document.getElementById('shopButton').onclick = function() {
            document.getElementById('shopPopup').style.display = 'block';
            window.game.updateShopList();
          };
          document.getElementById('closeShopButton').onclick = function() {
            document.getElementById('shopPopup').style.display = 'none';
          };
          // í€˜ìŠ¤íŠ¸ ë²„íŠ¼ ì—´ê¸°
          document.getElementById('questButton').onclick = function() {
            document.getElementById('questPopup').style.display = 'block';
            document.getElementById('questList').innerHTML = '<div>ì˜ˆì‹œ í€˜ìŠ¤íŠ¸: 5ì›¨ì´ë¸Œ ëŒíŒŒ<br>ì˜ˆì‹œ í€˜ìŠ¤íŠ¸: 2000ì  ë‹¬ì„±<br>ì˜ˆì‹œ í€˜ìŠ¤íŠ¸: ë³´ìŠ¤ ì²˜ì¹˜</div>';
          };
          // í€˜ìŠ¤íŠ¸ íŒì—… ë‹«ê¸°
          document.getElementById('closeQuestButton').onclick = function() {
            document.getElementById('questPopup').style.display = 'none';
          };
        };

        // === GlassCombatArena í´ë˜ìŠ¤ ì •ì˜ ëë‚œ í›„ ===
        window.game = new GlassCombatArena();
    </script>
</body>
</html>
