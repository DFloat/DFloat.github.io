<!DOCTYPE html>
<html lang="ko">
<head>
    <!-- Firebase SDK 및 설정 -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
    <script>
    const firebaseConfig = {
        apiKey: "AIzaSyBGKn7TDPIQL9E0_IQhWs2NYuqe1jy27P0",
        authDomain: "glasscombatarena.firebaseapp.com",
        databaseURL: "https://glasscombatarena-default-rtdb.asia-southeast1.firebasedatabase.app/",
        projectId: "glasscombatarena",
        storageBucket: "glasscombatarena.firebasestorage.app",
        messagingSenderId: "678597065462",
        appId: "1:678597065462:web:36b0420611e79bf041cad7",
        measurementId: "G-F2PQDZPDBL"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>글래스 컴뱃 아레나</title>
    <meta name="description" content="2D 브라우저 기반 전투 게임 - 중력 물리학, 글래스모피즘 UI, 봇 전투 시스템">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="icon" type="image/png" href="icon.png">
    <style>
        /* 전역 CSS 재설정 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* body 스타일: 폰트, 배경, 오버플로우 숨김, 전체 화면 */
        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* 게임 캔버스 스타일: 절대 위치, 커서, 배경, 블러 전환 효과 */
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); /* 캔버스 배경도 동일하게 설정 */
            filter: blur(10px); /* 초기 블러 효과 */
            transition: filter 0.5s ease; /* 블러 전환 애니메이션 */
            display: block; /* 항상 보이도록 설정 */
        }
        
        /* 글래스 카드 스타일: 배경 흐림, 테두리, 그림자 */
        .glass-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            color: #fff;
        }
        
        /* HUD (Head-Up Display) 스타일: 왼쪽 상단 고정, flexbox로 내부 요소 정렬 */
        .hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            pointer-events: none;
            z-index: 10;
            display: none;
            flex-direction: row;
            gap: 18px;
            justify-content: center;
            align-items: flex-start;
            padding: 12px 0 0 0;
        }
        
        /* HUD 내부 아이템 스타일: 상호작용 가능 */
        .hud-item {
            pointer-events: auto;
            margin: 0 4px;
            min-width: 170px;
            max-width: 260px;
        }
        
        /* 체력/탄약 바 스타일 */
        .health-bar, .ammo-bar {
            width: 150px;
            height: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            overflow: hidden;
            margin: 8px 0;
        }
        
        /* 체력 바 채우기 스타일: 그라데이션, 너비 전환 효과 */
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ef4444, #f87171);
            transition: width 0.3s ease;
        }
        
        /* 탄약 바 채우기 스타일: 그라데이션, 너비 전환 효과 */
        .ammo-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #60a5fa);
            transition: width 0.3s ease;
        }
        
        /* 스탯 텍스트 스타일 */
        .stats {
            color: white;
            font-size: 14px;
            font-weight: 500;
        }
        
        /* 점수 텍스트 스타일 */
        .score {
            color: white;
            font-size: 20px;
            font-weight: bold;
            text-align: center;
        }
        
        /* 웨이브 텍스트 스타일 */
        .wave {
            color: white;
            font-size: 16px;
            font-weight: 600;
            text-align: center;
            margin-top: 8px;
        }
        
        /* 조작법 텍스트 스타일 */
        .controls {
            color: white;
            font-size: 12px;
        }
        
        /* 조작 키 표시 스타일 */
        .control-key {
            background: rgba(255, 255, 255, 0.1);
            padding: 4px 8px;
            border-radius: 4px;
            margin: 2px;
            display: inline-block;
        }
        
        /* 게임 메시지 컨테이너 스타일 */
        .message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
        }
        
        /* 게임 메시지 주 텍스트 스타일 */
        .message-text {
            color: white;
            font-size: 32px;
            font-weight: bold;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        /* 게임 메시지 보조 텍스트 스타일 */
        .message-sub {
            color: rgba(255, 255, 255, 0.8);
            font-size: 18px;
            text-align: center;
            margin-top: 8px;
        }
        
        /* 깜빡임 애니메이션 */
        .animate-pulse {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* 미니맵 스타일 */
        .minimap {
            width: 120px;
            height: 120px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            position: relative;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        /* 미니맵 플레이어 도트 스타일 */
        .minimap-player {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #3b82f6;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        /* 미니맵 적 도트 스타일 */
        .minimap-enemy {
            position: absolute;
            width: 3px;
            height: 3px;
            background: #ef4444;
            border-radius: 50%;
        }
        
        /* 미니맵 아이템 도트 스타일 */
        .minimap-item {
            position: absolute;
            width: 2px;
            height: 2px;
            background: #fbbf24;
            border-radius: 50%;
        }

        /* 시작 화면 스타일 */
        #startScreen {
            position: absolute; /* 캔버스 위에 오버레이 */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 101; /* HUD보다 높게 설정 */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
            padding: 40px;
        }

        #startScreen h1 {
            font-size: 4em;
            margin-bottom: 20px;
            text-shadow: 0 0 15px rgba(255,255,255,0.5);
        }

        #startScreen p {
            font-size: 1.2em;
            margin-bottom: 30px;
            opacity: 0.8;
        }

        #startButton {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            padding: 15px 30px;
            font-size: 1.5em;
            font-weight: 600;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        #startButton:hover {
            background: rgba(255, 255, 255, 0.3);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
            transform: translateY(-2px);
        }

        #startButton:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        /* 보상 선택 화면 스타일 */
        #rewardSelectionScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200; /* 가장 위에 표시 */
            display: none; /* 초기에는 숨김 */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
            padding: 30px;
        }

        #rewardSelectionScreen h2 {
            font-size: 2.5em;
            margin-bottom: 25px;
            text-shadow: 0 0 10px rgba(255,255,255,0.4);
        }

        .reward-options {
            display: flex;
            gap: 20px;
            flex-wrap: wrap; /* 작은 화면에서 줄바꿈 */
            justify-content: center;
        }

        .reward-button {
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.25);
            border-radius: 12px;
            padding: 20px 25px;
            font-size: 1.2em;
            font-weight: bold;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(8px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
            min-width: 180px;
        }

        .reward-button:hover {
            background: rgba(255, 255, 255, 0.25);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.25);
            transform: translateY(-3px);
        }

        .reward-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        #shopPopup h2 {
            color: #fff;
            font-weight: bold;
        }

        #shopList {
            color: #fff;
            font-weight: normal;
        }

        /* --- 2. 상점 UI/로직: 점수로 패시브 업그레이드 구매 --- */
        /* 1) 상점에 표시할 아이템 목록 및 가격 설정 (보상 목록과 동일, 가격은 예시) */

        /* 2) 상점 UI에 아이템 표시 및 구매 로직 구현 */

        /* 3) 상점 버튼 클릭 시 updateShopList 호출 */
        document.getElementById('shopButton').onclick = () => {
            document.getElementById('shopPopup').style.display = 'block';
            this.updateShopList();
        };
    </style>
</head>
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>글래스 컴뱃 아레나</title>
    <meta name="description" content="2D 브라우저 기반 전투 게임 - 중력 물리학, 글래스모피즘 UI, 봇 전투 시스템">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* 전역 CSS 재설정 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* body 스타일: 폰트, 배경, 오버플로우 숨김, 전체 화면 */
        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* 게임 캔버스 스타일: 절대 위치, 커서, 배경, 블러 전환 효과 */
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); /* 캔버스 배경도 동일하게 설정 */
            filter: blur(10px); /* 초기 블러 효과 */
            transition: filter 0.5s ease; /* 블러 전환 애니메이션 */
            display: block; /* 항상 보이도록 설정 */
        }
        
        /* 글래스 카드 스타일: 배경 흐림, 테두리, 그림자 */
        .glass-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            color: #fff;
        }
        
        /* HUD (Head-Up Display) 스타일: 왼쪽 상단 고정, flexbox로 내부 요소 정렬 */
        .hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            pointer-events: none;
            z-index: 10;
            display: none;
            flex-direction: row;
            gap: 18px;
            justify-content: center;
            align-items: flex-start;
            padding: 12px 0 0 0;
        }
        
        /* HUD 내부 아이템 스타일: 상호작용 가능 */
        .hud-item {
            pointer-events: auto;
            margin: 0 4px;
            min-width: 170px;
            max-width: 260px;
        }
        
        /* 체력/탄약 바 스타일 */
        .health-bar, .ammo-bar {
            width: 150px;
            height: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            overflow: hidden;
            margin: 8px 0;
        }
        
        /* 체력 바 채우기 스타일: 그라데이션, 너비 전환 효과 */
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ef4444, #f87171);
            transition: width 0.3s ease;
        }
        
        /* 탄약 바 채우기 스타일: 그라데이션, 너비 전환 효과 */
        .ammo-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #60a5fa);
            transition: width 0.3s ease;
        }
        
        /* 스탯 텍스트 스타일 */
        .stats {
            color: white;
            font-size: 14px;
            font-weight: 500;
        }
        
        /* 점수 텍스트 스타일 */
        .score {
            color: white;
            font-size: 20px;
            font-weight: bold;
            text-align: center;
        }
        
        /* 웨이브 텍스트 스타일 */
        .wave {
            color: white;
            font-size: 16px;
            font-weight: 600;
            text-align: center;
            margin-top: 8px;
        }
        
        /* 조작법 텍스트 스타일 */
        .controls {
            color: white;
            font-size: 12px;
        }
        
        /* 조작 키 표시 스타일 */
        .control-key {
            background: rgba(255, 255, 255, 0.1);
            padding: 4px 8px;
            border-radius: 4px;
            margin: 2px;
            display: inline-block;
        }
        
        /* 게임 메시지 컨테이너 스타일 */
        .message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
        }
        
        /* 게임 메시지 주 텍스트 스타일 */
        .message-text {
            color: white;
            font-size: 32px;
            font-weight: bold;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        /* 게임 메시지 보조 텍스트 스타일 */
        .message-sub {
            color: rgba(255, 255, 255, 0.8);
            font-size: 18px;
            text-align: center;
            margin-top: 8px;
        }
        
        /* 깜빡임 애니메이션 */
        .animate-pulse {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* 미니맵 스타일 */
        .minimap {
            width: 120px;
            height: 120px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            position: relative;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        /* 미니맵 플레이어 도트 스타일 */
        .minimap-player {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #3b82f6;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        /* 미니맵 적 도트 스타일 */
        .minimap-enemy {
            position: absolute;
            width: 3px;
            height: 3px;
            background: #ef4444;
            border-radius: 50%;
        }
        
        /* 미니맵 아이템 도트 스타일 */
        .minimap-item {
            position: absolute;
            width: 2px;
            height: 2px;
            background: #fbbf24;
            border-radius: 50%;
        }

        /* 시작 화면 스타일 */
        #startScreen {
            position: absolute; /* 캔버스 위에 오버레이 */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 101; /* HUD보다 높게 설정 */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
            padding: 40px;
        }

        #startScreen h1 {
            font-size: 4em;
            margin-bottom: 20px;
            text-shadow: 0 0 15px rgba(255,255,255,0.5);
        }

        #startScreen p {
            font-size: 1.2em;
            margin-bottom: 30px;
            opacity: 0.8;
        }

        #startButton {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            padding: 15px 30px;
            font-size: 1.5em;
            font-weight: 600;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        #startButton:hover {
            background: rgba(255, 255, 255, 0.3);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
            transform: translateY(-2px);
        }

        #startButton:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        /* 보상 선택 화면 스타일 */
        #rewardSelectionScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200; /* 가장 위에 표시 */
            display: none; /* 초기에는 숨김 */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
            padding: 30px;
        }

        #rewardSelectionScreen h2 {
            font-size: 2.5em;
            margin-bottom: 25px;
            text-shadow: 0 0 10px rgba(255,255,255,0.4);
        }

        .reward-options {
            display: flex;
            gap: 20px;
            flex-wrap: wrap; /* 작은 화면에서 줄바꿈 */
            justify-content: center;
        }

        .reward-button {
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.25);
            border-radius: 12px;
            padding: 20px 25px;
            font-size: 1.2em;
            font-weight: bold;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(8px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
            min-width: 180px;
        }

        .reward-button:hover {
            background: rgba(255, 255, 255, 0.25);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.25);
            transform: translateY(-3px);
        }

        .reward-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        #shopPopup h2 {
            color: #fff;
            font-weight: bold;
        }

        #shopList {
            color: #fff;
            font-weight: normal;
        }

        /* --- 2. 상점 UI/로직: 점수로 패시브 업그레이드 구매 --- */
        /* 1) 상점에 표시할 아이템 목록 및 가격 설정 (보상 목록과 동일, 가격은 예시) */

        /* 2) 상점 UI에 아이템 표시 및 구매 로직 구현 */

        /* 3) 상점 버튼 클릭 시 updateShopList 호출 */
        document.getElementById('shopButton').onclick = () => {
            document.getElementById('shopPopup').style.display = 'block';
            this.updateShopList();
        };
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <!-- HUD 요소들 -->
    <div class="hud">
        <div class="glass-card hud-item" style="display:flex; flex-direction:row; align-items:center; gap:22px; min-width:unset; max-width:unset;">
            <div style="display:flex; align-items:center; gap:10px;">
                <div style="display:flex; align-items:center; gap:6px;">
                    <div style="width:8px; height:8px; background:#ef4444; border-radius:50%; animation:pulse 2s infinite;"></div>
                    <span>체력</span>
                    <div class="health-bar" style="width:70px; margin:0 4px;"><div class="health-fill" id="healthFill" style="width:100%;"></div></div>
                    <span id="healthText">100/100</span>
                </div>
                <div style="display:flex; align-items:center; gap:6px; margin-left:16px;">
                    <div style="width:8px; height:8px; background:#3b82f6; border-radius:50%; animation:pulse 2s infinite;"></div>
                    <span>탄약</span>
                    <div class="ammo-bar" style="width:70px; margin:0 4px;"><div class="ammo-fill" id="ammoFill" style="width:100%;"></div></div>
                    <span id="ammoText">60/60</span>
                </div>
                <div style="display:flex; align-items:center; gap:6px; margin-left:16px;">
                    <div style="width:8px; height:8px; background:#8b5cf6; border-radius:50%;"></div>
                    <span>속도</span>
                    <span id="speedText">5</span>
                </div>
                <div style="display:flex; align-items:center; gap:6px; margin-left:16px;">
                    <div style="width:8px; height:8px; background:#dc2626; border-radius:50%;"></div>
                    <span>공격력</span>
                    <span id="damageText">20</span>
                </div>
                <div style="display:flex; align-items:center; gap:6px; margin-left:16px;">
                    <div style="width:8px; height:8px; background:#7c3aed; border-radius:50%;"></div>
                    <span>다중 발사</span>
                    <span id="multishotText">1</span>
                </div>
                <div style="display:flex; align-items:center; gap:6px; margin-left:16px;">
                    <span style="color:white; font-weight:600;">활성 효과</span>
                    <div id="activeEffects" style="font-size:12px; display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
                        <div id="invincibilityEffect"></div>
                        <div id="shieldBoostEffect"></div>
                        <div id="timeSlowEffect"></div>
                        <div id="magnetEffect"></div>
                        <div id="healthRegenEffect"></div>
                        <div id="rapidFireEffect"></div>
                        <div id="piercingShotEffect"></div>
                        <div id="explosiveShotEffect"></div>
                        <div id="orbitingKnivesEffect"></div>
                        <div id="ricochetShotEffect"></div>
                        <div id="homingShotEffect"></div>
                        <div id="splitShotEffect"></div>
                        <div id="ammoRegenEffect"></div>
                        <div id="timeStopEffect"></div>
                        <div id="dashEffect"></div>
                        <div id="lifeStealEffect"></div>
                        <div id="critChanceEffect"></div>
                        <div id="cooldownReductionEffect"></div>
                        <div id="armorEffect"></div>
                    </div>
                </div>
                <!-- 점수/웨이브/적 수 표시 (오른쪽 끝에 가로로) -->
                <span id="scoreText" style="margin-left:22px; color:#fff; font-size:1.1em; font-weight:600;"></span>
                <span id="waveText" style="margin-left:14px; color:#fff; font-size:1.1em; font-weight:600;"></span>
                <span id="enemyCount" style="margin-left:14px; color:#fff; font-size:1.1em; font-weight:600;"></span>
                <!-- 1. HUD에 XP와 상점 버튼 추가 -->
                <span id="xpText" style="margin-left:18px; color:#ffe066; font-size:1.1em; font-weight:600;"></span>
                <button id="shopButton" style="margin-left:12px; font-size:1em; border-radius:6px; border:none; background:#ffe066; color:#222; padding:4px 16px; cursor:pointer;">상점</button>
                <button id="testZoneHUDButton" style="margin-left:12px; font-size:1em; border-radius:6px; border:none; background:#ff6b6b; color:#fff; padding:4px 16px; cursor:pointer; display:none;">테스트 존</button>
                <button id="enemyDexHUDButton" style="margin-left:12px; font-size:1em; border-radius:6px; border:none; background:#8b5cf6; color:#fff; padding:4px 16px; cursor:pointer;">적 도감</button>
            </div>
        </div>
    </div>
    
    <!-- 플레이어2 HUD (멀티플레이 모드에서만 표시) -->
    <div id="player2HUD" class="glass-card hud-item" style="display:none; position:fixed; top:80px; left:24px; z-index:20; flex-direction:row; align-items:center; gap:22px; min-width:unset; max-width:unset;">
        <div style="display:flex; align-items:center; gap:10px;">
            <div style="display:flex; align-items:center; gap:6px;">
                <div style="width:8px; height:8px; background:#ef4444; border-radius:50%; animation:pulse 2s infinite;"></div>
                <span style="color:#fff;">P2 체력</span>
                <div class="health-bar" style="width:70px; margin:0 4px;"><div class="health-fill" id="healthFill2" style="width:100%;"></div></div>
                <span id="healthText2" style="color:#fff;">100/100</span>
            </div>
            <div style="display:flex; align-items:center; gap:6px; margin-left:16px;">
                <div style="width:8px; height:8px; background:#ef4444; border-radius:50%; animation:pulse 2s infinite;"></div>
                <span style="color:#fff;">P2 탄약</span>
                <div class="ammo-bar" style="width:70px; margin:0 4px;"><div class="ammo-fill" id="ammoFill2" style="width:100%;"></div></div>
                <span id="ammoText2" style="color:#fff;">60/60</span>
            </div>
        </div>
    </div>
    
    <!-- 나머지 HUD(웨이브, 조작법, 미니맵 등)는 아래/오른쪽 등 별도 배치 필요시 추가 -->
    
    <!-- 게임 메시지 -->
    <div class="message" id="gameMessage" style="display: none;">
        <div class="glass-card">
            <div class="message-text" id="messageText"></div>
            <div class="message-sub" id="messageSubText"></div>
            <button id="restartButton" style="display:none; margin-top:18px; font-size:1.2em; padding:10px 30px; border-radius:8px; background:#6366f1; color:white; border:none; cursor:pointer;">재시작</button>
        </div>
    </div>

    <!-- 시작 화면 -->
    <div id="startScreen" class="glass-card">
        <h1>글래스 컴뱃 아레나</h1>
        <p>2D 브라우저 기반 전투 게임 - 중력 물리학, 글래스모피즘 UI, 봇 전투 시스템</p>
        <button id="startButton">시작하기</button>
        <button id="enemyDexButton">적 도감</button>
    </div>

    <!-- 보상 선택 화면 -->
    <div id="rewardSelectionScreen" class="glass-card">
        <h2 id="rewardSelectionTitle">보상 선택</h2>
        <div class="reward-options" id="rewardOptions">
            <!-- 보상 버튼들이 여기에 동적으로 추가됩니다. -->
        </div>
    </div>

    <!-- 적 도감 화면 -->
    <div id="enemyDexScreen" class="glass-card" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); z-index:300; min-width:600px; min-height:400px; max-width:90vw; max-height:80vh; flex-direction:row; align-items:stretch; padding:0; overflow:hidden; backdrop-filter:blur(20px); background:rgba(255,255,255,0.15); border:1px solid rgba(255,255,255,0.2); box-shadow:0 8px 32px rgba(0,0,0,0.3);">
        <!-- 좌측 리스트 -->
        <div id="enemyDexList" style="width:200px; background:rgba(255,255,255,0.1); border-right:1px solid rgba(255,255,255,0.2); overflow-y:auto; max-height:80vh; min-height:400px; display:flex; flex-direction:column; backdrop-filter:blur(10px);"></div>
        <!-- 우측 상세 -->
        <div id="enemyDexDetail" style="flex:1; display:flex; flex-direction:column; align-items:center; justify-content:flex-start; min-width:300px; padding:32px 16px 16px 16px; overflow-y:auto; background:rgba(255,255,255,0.05); backdrop-filter:blur(5px);"></div>
        <button id="closeEnemyDexButton" style="position:absolute; top:12px; right:16px; background:rgba(255,255,255,0.2); border:1px solid rgba(255,255,255,0.3); border-radius:8px; padding:8px 16px; color:#fff; cursor:pointer; backdrop-filter:blur(10px); transition:all 0.3s ease;">닫기</button>
    </div>

    <!-- 퀘스트 버튼 및 퀘스트 팝업 -->
    <button id="questButton" style="position:absolute; top:24px; left:220px; z-index:20; background:rgba(255,255,255,0.18); color:white; border:none; border-radius:8px; padding:8px 18px; font-size:15px; cursor:pointer;">퀘스트</button>
    <div id="questPopup" class="glass-card" style="display:none; position:absolute; top:60px; left:220px; z-index:30; min-width:260px; min-height:180px;">
        <h3 style="color:white; margin-bottom:12px;">퀘스트</h3>
        <div id="questList" style="color:white; font-size:15px;"></div>
        <button id="closeQuestButton" style="margin-top:18px;">닫기</button>
    </div>

    <!-- 인트로 화면: 솔로/함께 플레이/테스팅 존 선택 -->
    <div id="introScreen" class="glass-card" style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); z-index:200; display:flex; flex-direction:column; align-items:center; justify-content:center; min-width:340px; min-height:280px;">
        <h1 style="font-size:2.5em; margin-bottom:18px;">글래스 컴뱃 아레나</h1>
        <div class="reward-options" style="margin-bottom:20px;">
            <button id="soloButton" class="reward-button" style="min-width:200px;">솔로 플레이</button>
            <button id="multiButton" class="reward-button" style="min-width:200px;">함께 플레이</button>
            <button id="testZoneButton" class="reward-button" style="min-width:200px;">테스팅 존</button>
        </div>
        <div style="margin-bottom:15px; display:flex; align-items:center; gap:8px;">
            <input type="checkbox" id="mobileModeCheckbox" style="width:18px; height:18px; cursor:pointer;">
            <label for="mobileModeCheckbox" style="color:#fff; font-size:1.1em; cursor:pointer;">📱 모바일 모드</label>
        </div>
        <div id="multiInfo" style="display:none; color:#fff; margin-top:18px; font-size:1.1em;">함께 플레이(온라인)는 추후 지원 예정입니다.</div>
    </div>

    <div id="multiJoinPopup" class="glass-card" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); z-index:300;">
        <h2>온라인 방 입장</h2>
        <input id="multiNickname" placeholder="닉네임" style="margin-bottom:8px; width:90%;" />
        <input id="multiRoomId" placeholder="방 코드(아무거나)" style="margin-bottom:8px; width:90%;" />
        <button id="multiJoinBtn">입장</button>
        <button id="multiJoinCancel">취소</button>
    </div>

    <div id="mobileControls" style="display:none; position:fixed; bottom:0; left:0; right:0; z-index:100; pointer-events:none;">
        <!-- 왼쪽(이동) 조이스틱 - 파란색 글래스모피즘 -->
        <div id="joystickContainer" style="position:absolute; bottom:80px; left:80px; width:120px; height:120px; pointer-events:auto;">
            <div id="joystickBase" style="width:100%; height:100%; background:rgba(59,130,246,0.25); border:2px solid rgba(59,130,246,0.3); border-radius:50%; display:flex; align-items:center; justify-content:center; backdrop-filter:blur(10px);">
                <div id="joystickThumb" style="width:50px; height:50px; background:rgba(59,130,246,0.7); border-radius:50%; position:absolute; transform:translate(-50%, -50%);"></div>
            </div>
        </div>
    
        <!-- 오른쪽(조준) 조이스틱 - 빨간색 글래스모피즘 -->
        <div id="aimJoystickContainer" style="position:absolute; bottom:80px; right:80px; width:120px; height:120px; pointer-events:auto;">
            <div id="aimJoystickBase" style="width:100%; height:100%; background:rgba(239,68,68,0.25); border:2px solid rgba(239,68,68,0.3); border-radius:50%; display:flex; align-items:center; justify-content:center; backdrop-filter:blur(10px);">
                <div id="aimJoystickThumb" style="width:50px; height:50px; background:rgba(239,68,68,0.7); border-radius:50%; position:absolute; transform:translate(-50%, -50%);"></div>
            </div>
        </div>
    
        <!-- 액션 버튼들 - 중앙 하단에 배치 -->
        <div id="actionButtons" style="position:absolute; bottom:30px; left:50%; transform:translateX(-50%); display:flex; flex-direction:row; gap:15px; pointer-events:auto;">
            <button id="jumpButton" class="mobile-button" style="width:60px; height:60px; background:rgba(34,197,94,0.8); border:2px solid rgba(255,255,255,0.3); border-radius:50%; color:#fff; font-size:20px; cursor:pointer; backdrop-filter:blur(10px);">↑</button>
            <button id="fireButton" class="mobile-button" style="width:80px; height:80px; background:rgba(239,68,68,0.8); border:2px solid rgba(255,255,255,0.3); border-radius:50%; color:#fff; font-size:24px; cursor:pointer; backdrop-filter:blur(10px);">●</button>
            <button id="reloadButton" class="mobile-button" style="width:60px; height:60px; background:rgba(59,130,246,0.8); border:2px solid rgba(255,255,255,0.3); border-radius:50%; color:#fff; font-size:18px; cursor:pointer; backdrop-filter:blur(10px);">R</button>
        </div>
    </div>

    <!-- 멀티플레이 모드 선택 -->
    <div id="multiplayerModeSelect" class="glass-card" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); z-index:200; min-width:400px;">
        <h2 style="text-align:center; margin-bottom:20px; color:#fff;">멀티플레이 모드 선택</h2>
        <div style="display:flex; flex-direction:column; gap:15px;">
            <button id="leaderSystemButton" class="mode-button" style="background:rgba(99, 102, 241, 0.8); border:none; border-radius:8px; padding:15px; color:#fff; cursor:pointer; text-align:left;">
                <h3 style="margin:0 0 8px 0;">리더 시스템</h3>
                <p style="margin:0; font-size:14px; opacity:0.9;">플레이어1이 리더가 되어 조준 방향을 결정하고, 플레이어2가 따라갑니다.</p>
            </button>
            <button id="hybridSystemButton" class="mode-button" style="background:rgba(34, 197, 94, 0.8); border:none; border-radius:8px; padding:15px; color:#fff; cursor:pointer; text-align:left;">
                <h3 style="margin:0 0 8px 0;">하이브리드 시스템</h3>
                <p style="margin:0; font-size:14px; opacity:0.9;">플레이어1은 마우스 조준, 플레이어2는 자동 조준으로 플레이합니다.</p>
            </button>
            <button id="onlineMultiplayerButton" class="mode-button" style="background:rgba(14, 165, 233, 0.8); border:none; border-radius:8px; padding:15px; color:#fff; cursor:pointer; text-align:left;">
                <h3 style="margin:0 0 8px 0;">온라인으로 플레이</h3>
                <p style="margin:0; font-size:14px; opacity:0.9;">실시간 온라인 멀티플레이(베타)</p>
            </button>
            <div id="onlineMultiplayerPopup" class="glass-card" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); z-index:220; min-width:340px; min-height:180px; text-align:center;">
                <h2 style="color:#0ea5e9; margin-bottom:12px;">온라인 멀티플레이</h2>
                <div style="color:white; font-size:1.1em; margin-bottom:18px;">
                    온라인 방을 만들거나, 아래 리스트에서 입장할 수 있습니다.
                </div>
                <div style="margin-bottom:12px;">
                    <input id="roomNameInput" type="text" placeholder="방 이름 입력" style="padding:7px; border-radius:5px; border:none; width:140px;">
                    <button id="createRoomButton" style="padding:7px 16px; border-radius:5px; border:none; background:#22c55e; color:white; margin-left:6px; cursor:pointer;">방 만들기</button>
                </div>
                <div id="roomListContainer" style="margin-bottom:18px; text-align:left; max-height:180px; overflow-y:auto; background:rgba(0,0,0,0.08); border-radius:8px; padding:10px 8px; color:#fff; font-size:1em; min-width:220px;">
                    <b>방 리스트</b>
                    <div id="roomList"></div>
                </div>
                <button id="closeOnlineMultiplayerPopup" style="margin-top:8px;">닫기</button>
            </div>
            <button id="backToIntro" class="back-button" style="background:rgba(255,255,255,0.2); border:none; border-radius:6px; padding:10px; color:#fff; cursor:pointer;">← 뒤로가기</button>
        </div>
    </div>

    <!-- 리더 시스템 설정 -->
    <div id="leaderSetup" class="glass-card" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); z-index:200; min-width:400px;">
        <h2 style="text-align:center; margin-bottom:20px; color:#fff;">리더 시스템 설정</h2>
        <div style="display:flex; flex-direction:column; gap:15px;">
            <div>
                <label style="color:#fff; display:block; margin-bottom:5px;">리더 이름:</label>
                <input id="leaderName" type="text" placeholder="리더" style="width:100%; padding:8px; border-radius:4px; border:none;">
            </div>
            <div>
                <label style="color:#fff; display:block; margin-bottom:5px;">리더 색상:</label>
                <input id="leaderColor" type="color" value="#3b82f6" style="width:100%; height:40px; border:none; border-radius:4px;">
            </div>
            <div>
                <label style="color:#fff; display:block; margin-bottom:5px;">따르는자 이름:</label>
                <input id="followerName" type="text" placeholder="따르는자" style="width:100%; padding:8px; border-radius:4px; border:none;">
            </div>
            <div>
                <label style="color:#fff; display:block; margin-bottom:5px;">따르는자 색상:</label>
                <input id="followerColor" type="color" value="#ef4444" style="width:100%; height:40px; border:none; border-radius:4px;">
            </div>
            <button id="leaderStartButton" class="start-button" style="background:#6366f1; border:none; border-radius:6px; padding:12px; color:#fff; cursor:pointer; font-weight:bold;">게임 시작</button>
            <button id="backToModeSelect" class="back-button" style="background:rgba(255,255,255,0.2); border:none; border-radius:6px; padding:10px; color:#fff; cursor:pointer;">← 뒤로가기</button>
        </div>
    </div>

    <!-- 하이브리드 시스템 설정 -->
    <div id="hybridSetup" class="glass-card" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); z-index:200; min-width:400px;">
        <h2 style="text-align:center; margin-bottom:20px; color:#fff;">하이브리드 시스템 설정</h2>
        <div style="display:flex; flex-direction:column; gap:15px;">
            <div>
                <label style="color:#fff; display:block; margin-bottom:5px;">플레이어1 이름:</label>
                <input id="player1Name" type="text" placeholder="플레이어1" style="width:100%; padding:8px; border-radius:4px; border:none;">
            </div>
            <div>
                <label style="color:#fff; display:block; margin-bottom:5px;">플레이어1 색상:</label>
                <input id="player1Color" type="color" value="#3b82f6" style="width:100%; height:40px; border:none; border-radius:4px;">
            </div>
            <div>
                <label style="color:#fff; display:block; margin-bottom:5px;">플레이어2 이름:</label>
                <input id="player2Name" type="text" placeholder="플레이어2" style="width:100%; padding:8px; border-radius:4px; border:none;">
            </div>
            <div>
                <label style="color:#fff; display:block; margin-bottom:5px;">플레이어2 색상:</label>
                <input id="player2Color" type="color" value="#ef4444" style="width:100%; height:40px; border:none; border-radius:4px;">
            </div>
            <div>
                <label style="color:#fff; display:block; margin-bottom:5px;">하이브리드 플레이어 선택:</label>
                <select id="hybridPlayer" style="width:100%; padding:8px; border-radius:4px; border:none;">
                    <option value="player1">플레이어1 (마우스 조준)</option>
                    <option value="player2">플레이어2 (자동 조준)</option>
                </select>
            </div>
            <button id="hybridStartButton" class="start-button" style="background:#22c55e; border:none; border-radius:6px; padding:12px; color:#fff; cursor:pointer; font-weight:bold;">게임 시작</button>
            <button id="backToModeSelect" class="back-button" style="background:rgba(255,255,255,0.2); border:none; border-radius:6px; padding:10px; color:#fff; cursor:pointer;">← 뒤로가기</button>
        </div>
    </div>
    </div>

    <!-- 랭킹 화면 -->
    <div id="rankingScreen" class="glass-card" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); z-index:250; min-width:340px; min-height:320px;">
        <h2 style="color:white; margin-bottom:12px;">랭킹</h2>
        <div id="rankingList" style="color:white; font-size:15px; min-height:180px;"></div>
        <button id="closeRankingButton" style="margin-top:18px;">닫기</button>
    </div>

    <!-- 보스 체력바 및 이름 표시용 -->
    <div id="bossBarContainer" style="display:none; position:fixed; top:38px; left:50%; transform:translateX(-50%); z-index:30; min-width:320px; max-width:60vw;">
        <div id="bossName" style="color:#fff; font-size:2em; font-weight:700; text-align:center; text-shadow:0 2px 8px #000; margin-bottom:6px;"></div>
        <div style="background:rgba(0,0,0,0.3); border-radius:8px; width:100%; height:22px; box-shadow:0 2px 8px #000;">
            <div id="bossBar" style="height:100%; background:linear-gradient(90deg,#ff007f,#ff8c00); border-radius:8px; width:100%; transition:width 0.3s;"></div>
        </div>
    </div>

    <!-- 미니맵 (HUD 아래 오른쪽 등 원하는 위치로 조정 가능) -->
    <div class="minimap" id="minimap" style="position:fixed; top:60px; right:32px; z-index:15;">
        <div class="minimap-player" id="minimapPlayer"></div>
    </div>

    <!-- 2. 상점 팝업 UI 추가 (body 하단) -->
    <div id="shopPopup" class="glass-card" style="display:none; position:fixed; top:80px; left:50%; transform:translateX(-50%); z-index:200; min-width:340px; min-height:220px;">
        <h2 style="color:#222; margin-bottom:12px;">상점 (XP로 업그레이드)</h2>
        <div id="shopList" style="color:#222; font-size:15px; min-height:120px;"></div>
        <button id="closeShopButton" style="margin-top:18px;">닫기</button>
    </div>

    <!-- 3. 테스트 존 UI 추가 -->
    <div id="testZonePopup" class="glass-card" style="display:none; position:fixed; top:80px; left:50%; transform:translateX(-50%); z-index:200; min-width:800px; min-height:500px;">
        <h2 style="color:#222; margin-bottom:12px;">테스트 존</h2>
        <div style="display:flex; gap:20px; flex-wrap:wrap;">
            <!-- 적 소환 패널 -->
            <div style="flex:1; min-width:200px;">
                <h3 style="color:#222; margin-bottom:8px;">적 소환</h3>
                <div id="enemySpawnList" style="color:#222; font-size:14px; max-height:200px; overflow-y:auto;"></div>
            </div>
            <!-- 보스 소환 패널 -->
            <div style="flex:1; min-width:200px;">
                <h3 style="color:#222; margin-bottom:8px;">보스 소환</h3>
                <div id="bossSpawnList" style="color:#222; font-size:14px; max-height:200px; overflow-y:auto;"></div>
            </div>
            <!-- 능력 부여 패널 -->
            <div style="flex:1; min-width:200px;">
                <h3 style="color:#222; margin-bottom:8px;">능력 부여</h3>
                <div id="abilityList" style="color:#222; font-size:14px; max-height:200px; overflow-y:auto;"></div>
            </div>
        </div>
        <div style="display:flex; gap:10px; margin-top:18px;">
            <button id="returnToMenuButton" style="background:#ff6b6b; color:#fff;">메인 메뉴</button>
        </div>
    </div>

    <!-- 솔로 모드 선택 팝업 -->
    <div id="soloModeSelect" class="glass-card" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); z-index:210; min-width:340px;">
        <h2 style="text-align:center; margin-bottom:20px; color:#fff;">솔로 모드 선택</h2>
        <div style="display:flex; flex-direction:column; gap:15px;">
            <button id="normalModeButton" class="mode-button" style="background:rgba(99, 102, 241, 0.8); border:none; border-radius:8px; padding:15px; color:#fff; cursor:pointer; text-align:left; font-size:1.1em;">일반 모드</button>
            <button id="bossRushModeButton" class="mode-button" style="background:rgba(239, 68, 68, 0.8); border:none; border-radius:8px; padding:15px; color:#fff; cursor:pointer; text-align:left; font-size:1.1em;">보스 러시 모드</button>
            <button id="backToIntroFromSolo" class="back-button" style="background:rgba(255,255,255,0.2); border:none; border-radius:6px; padding:10px; color:#fff; cursor:pointer;">← 뒤로가기</button>
        </div>
    </div>
    <div id="enterRoomPopup" class="glass-card" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); z-index:230; min-width:320px; text-align:center;">
        <h2 style="color:#0ea5e9; margin-bottom:12px;">방 입장</h2>
        <div style="margin-bottom:12px;">
            <input id="playerNameInput" type="text" placeholder="플레이어 이름 입력" style="padding:7px; border-radius:5px; border:none; width:140px;">
        </div>
        <button id="enterRoomButton" style="padding:7px 16px; border-radius:5px; border:none; background:#6366f1; color:white; margin-right:8px; cursor:pointer;">입장</button>
        <button id="cancelEnterRoomButton" style="padding:7px 16px; border-radius:5px; border:none; background:#aaa; color:white; cursor:pointer;">취소</button>
    </div>
    <div id="roomLobbyPopup" class="glass-card" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); z-index:240; min-width:340px; text-align:center;">
        <h2 style="color:#0ea5e9; margin-bottom:12px;">방 로비</h2>
        <div id="lobbyRoomName" style="color:#fff; margin-bottom:10px;"></div>
        <div id="lobbyPlayerList" style="margin-bottom:16px; color:#fff; text-align:left; min-width:180px;"></div>
        <button id="readyButton" style="padding:7px 16px; border-radius:5px; border:none; background:#22c55e; color:white; margin-right:8px; cursor:pointer;">준비</button>
        <button id="leaveLobbyButton" style="padding:7px 16px; border-radius:5px; border:none; background:#aaa; color:white; cursor:pointer;">나가기</button>
        <div id="lobbyStatusMsg" style="margin-top:12px; color:#0ea5e9;"></div>
    </div>

    <script>
        // GlassCombatArena 게임 클래스 정의
        class GlassCombatArena {
            constructor() {
                // 캔버스 및 2D 컨텍스트 초기화
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.resizeCanvas(); // 캔버스 크기 조정
                
                // 게임 상태 초기화
                this.gameState = {
                    player: { // 플레이어 객체
                        x: this.canvas.width / 2, // 초기 X 위치 (캔버스 중앙)
                        y: this.canvas.height / 2, // 초기 Y 위치 (캔버스 중앙)
                        width: 40, // 너비
                        height: 40, // 높이
                        vx: 0, // X축 속도
                        vy: 0, // Y축 속도
                        health: 200, // 현재 체력 (150 -> 200으로 변경)
                        maxHealth: 200, // 최대 체력 (150 -> 200으로 변경)
                        ammo: 30, // 현재 탄약 (30발로 고정)
                        maxAmmo: 30, // 최대 탄약 (30발로 고정)
                        speed: 5, // 이동 속도
                        jumpPower: 15, // 점프력
                        onGround: false, // 지면 접촉 여부
                        facing: 0, // 바라보는 방향 (라디안)
                        expression: ':D', // 표정
                        color: '#6366f1', // 색상
                        baseDamage: 10, // 기본 공격력 (20 -> 25로 상향)
                        multishot: 1, // 다중 발사 횟수
                        rapidFireTime: 0, // 연발 모드 종료 시간
                        damageReductionFactor: 1, // 피해 감소율 (1 = 100% 피해, 0.5 = 50% 피해)
                        shieldBoostEndTime: 0, // 쉴드 강화 종료 시간
                        healthRegenEndTime: 0, // 체력 재생 종료 시간
                        lastRegenTick: 0, // 마지막 체력 재생 틱 시간
                        magnetEndTime: 0, // 자석 효과 종료 시간
                        magnetRadius: 200, // 자석 효과 범위
                        lastHitById: null, // 마지막으로 플레이어에게 피해를 준 엔티티의 ID
                        type: 'player', // 플레이어 타입 추가
                        orbitingKnives: [], // 회전 칼날 배열 추가
                        piercingShot: 0, // 관통 사격 레벨 (0: 없음, 1+: 관통 횟수)
                        explosiveShot: 0, // 폭발 사격 레벨 (0: 없음, 1+: 레벨)
                        ricochetLevel: 0, // 도탄 사격 레벨
                        homingLevel: 0, // 유도 사격 레벨
                        splitLevel: 0, // 분열 사격 레벨
                        lifeStealPercent: 0, // 생명력 흡수율
                        critChance: 0, // 치명타 확률
                        critMultiplier: 1.5, // 치명타 배율
                        cooldownReduction: 0, // 재사용 대기시간 감소율
                        armor: 0, // 방어력 (고정 피해 감소)
                        timeStopEndTime: 0, // 시간 정지 종료 시간
                        ammoRegenEndTime: 0, // 탄약 재생 종료 시간
                        lastAmmoRegenTick: 0, // 마지막 탄약 재생 틱
                        ammoRegenAmount: 0, // 탄약 재생량
                        dashCooldown: 0, // 마지막 대시 시각
                        dashEndTime: 0, // 대시 종료 시각
                        isDashing: false, // 대시 중 여부
                        reloadTime: 1500, // 기본 재장전 시간(ms)
                        isReloading: false,
                        machineGunMode: false, // 기관단총 패시브
                        machineGunPenalty: false, // 기관단총 패널티
                        reloadPenalty: 0, // 패시브로 인한 추가 재장전 시간(ms)
                        gunRecoil: 0,
                        gunRecoilTarget: 0,
                    },
                    player2: null, // 플레이어2 객체 (멀티플레이용)
                    multiplayerMode: null, // 멀티플레이 모드 ('leader', 'hybrid', null)
                    multiplayerConfig: null, // 멀티플레이 설정
                    // 부활 시스템 관련 속성들
                    player1Dead: false, // 플레이어1 사망 여부
                    player2Dead: false, // 플레이어2 사망 여부
                    lastDeathWave: 0, // 마지막 사망한 웨이브
                    revivalWaveCount: 0, // 부활을 위한 웨이브 카운트
                    enemies: [], // 적 배열
                    projectiles: [], // 발사체 배열
                    items: [], // 아이템 배열
                    particles: [], // 파티클 배열
                    floatingTexts: [], // 떠다니는 텍스트 배열 (체력 변화 등)
                    allies: [], // 아군 배열 추가
                    score: 0, // 현재 점수
                    wave: 1, // 현재 웨이브
                    gameStatus: 'start', // 게임 상태 ('start', 'playing', 'wave-complete', 'game-over', 'reward-selection')
                    message: '', // 현재 표시되는 메시지 텍스트
                    messageTimer: 0, // 메시지 타이머
                    playerSlowedEndTime: 0, // 플레이어 둔화 효과 종료 시간
                    timeSlowEndTime: 0, // 시간 둔화 효과 종료 시간 (적 느려짐)
                    timeSlowEffect: 1 // 시간 둔화 효과 (1 = 정상 속도, 0 = 정지)
                };
                
                // 입력 상태 초기화
                this.keys = {}; // 눌린 키 상태 저장 객체
                this.mouse = { x: 0, y: 0 }; // 마우스 현재 위치
                
                // 모바일 모드 관련 변수
                this.mobileMode =  false; // 모바일 모드 활성화 여부
                this.touchControls = {
                    joystick: { x: 0, y: 0, active: false, centerX: 0, centerY: 0 },
                    aimJoystick: { x: 0, y: 0, active: false, centerX: 0, centerY: 0 },
                    fireButton: { pressed: false },
                    jumpButton: { pressed: false },
                    reloadButton: { pressed: false },
                };
                
                // 게임 상수 정의 (난이도 및 게임 플레이 조정)
                this.GRAVITY = 0.8; // 중력 가속도
                this.FRICTION = 0.85; // 마찰 계수
                this.GROUND_Y = 50; // 지면의 Y 좌표 (캔버스 하단으로부터의 거리)
                
                // 퀘스트 시스템 초기화
                this.questSystem = {
                    activeQuests: [],
                    completedQuests: [],
                    questTypes: [
                        {
                            id: 'wave_clear',
                            name: '웨이브 돌파',
                            description: '{target}웨이브까지 클리어',
                            type: 'wave',
                            rewards: { score: 500, health: 50 }
                        },
                        {
                            id: 'score_reach',
                            name: '점수 달성',
                            description: '{target}점 달성',
                            type: 'score',
                            rewards: { score: 300, ammo: 30 }
                        },
                        {
                            id: 'boss_kill',
                            name: '보스 처치',
                            description: '보스 {target}마리 처치',
                            type: 'boss_kill',
                            rewards: { score: 1000, health: 100, ammo: 50 }
                        },
                        {
                            id: 'enemy_kill',
                            name: '적 처치',
                            description: '적 {target}마리 처치',
                            type: 'enemy_kill',
                            rewards: { score: 200, health: 30 }
                        },
                        {
                            id: 'item_collect',
                            name: '아이템 수집',
                            description: '아이템 {target}개 수집',
                            type: 'item_collect',
                            rewards: { score: 150, ammo: 20 }
                        }
                    ]
                };
                // 사용자 요청에 따라 표정 배열에 ': @' 추가
                this.EXPRESSIONS = [':D', ':>', ':<', ':O', ':/', ':#', 'XD', 'X>', ':V', ':@']; // 캐릭터 표정 배열
                
                // 아이템 타입 정의 (새로운 아이템 추가)
                this.ITEM_TYPES = [
                    { type: 'health', effect: 50, color: '#22c55e', emoji: '❤️' }, // 체력 회복
                    { type: 'ammo', effect: 30, color: '#f59e0b', emoji: '🔋' }, // 탄약 회복
                    { type: 'speed', effect: 2, color: '#8b5cf6', emoji: '🚀' }, // 이동 속도 증가
                    { type: 'shield', effect: 50, color: '#3b82f6', emoji: '🛡️' }, // 최대 체력 증가
                    { type: 'damage', effect: 10, color: '#dc2626', emoji: '⚔️' }, // 공격력 증가
                    { type: 'multishot', effect: 3, color: '#7c3aed', emoji: '💥' }, // 다중 발사
                    { type: 'megahealth', effect: 100, color: '#059669', emoji: '💚' }, // 대량 체력 회복
                    { type: 'rapid', effect: 5, color: '#ea580c', emoji: '⚡' }, // 연발 모드
                    { type: 'invincibility', effect: 5000, color: '#ffd700', emoji: '✨' }, // 무적 (5초)
                    { type: 'grenade', effect: 1, color: '#6b7280', emoji: '💣' }, // 수류탄
                    { type: 'shield_boost', effect: 0.5, duration: 10000, color: '#87ceeb', emoji: '🔵' }, // 쉴드 강화 (10초, 50% 피해 감소)
                    { type: 'time_slow', effect: 0.5, duration: 5000, color: '#800080', emoji: '⏳' }, // 시간 둔화 (5초, 50% 느려짐)
                    { type: 'magnet', effect: 200, duration: 8000, color: '#8b4513', emoji: '  ' }, // 자석 (8초, 200px 범위)
                    { type: 'health_regen', effect: 5, duration: 10000, tickInterval: 500, color: '#32cd32', emoji: '⚕️' }, // 체력 재생 (10초, 0.5초마다 5회복)
                    { type: 'ally_summon', effect: 1, color: '#90ee90', emoji: '🤖' }, // 아군 소환 아이템
                    { type: 'orbiting_knife', effect: 1, color: '#c0c0c0', emoji: '🔪' }, // 회전 칼날 아이템
                    { type: 'piercing_shot', effect: 1, color: '#800080', emoji: '✨' }, // 관통 사격 아이템
                    { type: 'explosive_shot', effect: 1, color: '#ff4500', emoji: '💥' }, // 폭발 사격 아이템
                    { type: 'ricochet_shot', effect: 1, color: '#00ced1', emoji: '↩️' }, // 도탄 사격
                    { type: 'homing_shot', effect: 1, color: '#ff1493', emoji: '🧭' }, // 유도 사격
                    { type: 'split_shot', effect: 1, color: '#9932cc', emoji: '➕' }, // 분열 사격
                    { type: 'time_stop', effect: 3000, color: '#4b0082', emoji: '🛑' }, // 시간 정지 (3초)
                    { type: 'ammo_regen', effect: 10, duration: 5000, tickInterval: 200, color: '#ffd700', emoji: '🟡' } // 탄약 재생 (5초, 0.2초마다 10회복)
                ];
                
                // 적 타입 정의 (새로운 적 추가됨)
                this.ENEMY_TYPES = {
                    boss: {
                        name: '글래스 보스',
                        health: 800,
                        speed: 2.5,
                        damage: 40,
                        color: '#ff007f',
                        size: 90,
                        shootInterval: 900,
                        points: 3000,
                        missileCooldown: 3000, lastMissile: 0, // 미사일 난사
                        teleportCooldown: 6000, lastTeleport: 0, // 순간이동
                        explosionCooldown: 7000, lastExplosion: 0, // 광역 폭발
                        summonCooldown: 9000, lastSummon: 0, // 소환
                        shieldCooldown: 12000, lastShield: 0, shieldDuration: 3000, isInvincible: false, invincibleEndTime: 0, // 쉴드
                        blackholeCooldown: 15000, lastBlackhole: 0, // 블랙홀
                        description: '모든 보스 능력을 가진 궁극의 보스. 웨이브가 오를수록 더욱 강해진다.',
                        dexInfo: {
                            category: '보스',
                            difficulty: '★★★★★',
                            abilities: ['미사일 난사', '순간이동', '광역 폭발', '소환', '쉴드', '블랙홀'],
                            strategy: '모든 능력을 가진 최종 보스. 체력이 높고 다양한 공격 패턴을 사용합니다. 쉴드 상태일 때는 무적이므로 기다려야 합니다.',
                            weakness: '쉴드가 끝난 후 집중 공격'
                        }
                    },
                    basic: {
                        name: '기본 적', 
                        health: 40, 
                        speed: 2, 
                        damage: 15, 
                        color: '#ef4444', 
                        size: 35, 
                        shootInterval: 2000, 
                        points: 100,
                        description: '가장 기본적인 적. 특별한 능력은 없지만 균형잡힌 스탯을 가지고 있습니다.',
                        dexInfo: {
                            category: '일반',
                            difficulty: '★☆☆☆☆',
                            abilities: ['기본 발사'],
                            strategy: '가장 기본적인 적으로, 특별한 패턴 없이 단순히 플레이어를 향해 발사합니다.',
                            weakness: '체력이 낮아 빠르게 처치 가능'
                        }
                    },
                    fast: {
                        name: '빠른 적', 
                        health: 25, 
                        speed: 4, 
                        damage: 12, 
                        color: '#f97316', 
                        size: 30, 
                        shootInterval: 1500, 
                        points: 150,
                        description: '빠른 속도로 움직이며 자주 발사하는 적. 체력은 낮지만 회피하기 어려울 수 있습니다.',
                        dexInfo: {
                            category: '일반',
                            difficulty: '★★☆☆☆',
                            abilities: ['빠른 이동', '빠른 발사'],
                            strategy: '속도가 빠르고 발사 간격이 짧아 회피하기 어렵습니다. 우선 처치하는 것이 좋습니다.',
                            weakness: '체력이 매우 낮아 한 번의 공격으로 처치 가능'
                        }
                    },
                    tank: {
                        name: '탱크 적', 
                        health: 80, 
                        speed: 1, 
                        damage: 25, 
                        color: '#7c3aed', 
                        size: 45, 
                        shootInterval: 3000, 
                        points: 250,
                        description: '높은 체력과 공격력을 가진 중장갑 적. 느리지만 강력한 공격을 합니다.',
                        dexInfo: {
                            category: '일반',
                            difficulty: '★★★☆☆',
                            abilities: ['높은 체력', '강력한 공격'],
                            strategy: '체력이 높고 공격력이 강하지만 속도가 느립니다. 거리를 두고 공격하는 것이 좋습니다.',
                            weakness: '속도가 매우 느려 회피하기 쉬움'
                        }
                    },
                    sniper: {
                        name: '저격수', 
                        health: 30, 
                        speed: 1.5, 
                        damage: 30, 
                        color: '#06b6d4', 
                        size: 32, 
                        shootInterval: 4000, 
                        points: 200,
                        description: '높은 공격력과 긴 사거리를 가진 저격 적. 발사 간격이 길지만 한 번 맞으면 큰 피해를 입습니다.',
                        dexInfo: {
                            category: '일반',
                            difficulty: '★★☆☆☆',
                            abilities: ['높은 공격력', '긴 사거리'],
                            strategy: '공격력이 높지만 발사 간격이 길어 예측하기 쉽습니다. 발사 타이밍을 노려 공격하세요.',
                            weakness: '체력이 낮고 발사 간격이 길어 회피하기 쉬움'
                        }
                    },
                    bomber: {
                        name: '폭격병', 
                        health: 45, 
                        speed: 1.5, 
                        damage: 30, 
                        color: '#b91c1c', 
                        size: 38, 
                        shootInterval: 3000, 
                        points: 220,
                        description: '강력한 폭발 공격을 하는 적. 체력은 보통이지만 공격력이 높습니다.',
                        dexInfo: {
                            category: '일반',
                            difficulty: '★★★☆☆',
                            abilities: ['폭발 공격', '높은 공격력'],
                            strategy: '공격력이 높아 주의가 필요합니다. 우선 처치하거나 거리를 두고 싸우세요.',
                            weakness: '체력이 보통이고 속도가 느림'
                        }
                    },
                    guardian: {
                        name: '수호자', 
                        health: 200, 
                        speed: 1.2, 
                        damage: 45, 
                        color: '#1e40af', 
                        size: 55, 
                        shootInterval: 1800, 
                        points: 400,
                        description: '매우 높은 체력과 강력한 공격력을 가진 정예 적. 처치하기 어렵지만 높은 점수를 제공합니다.',
                        dexInfo: {
                            category: '정예',
                            difficulty: '★★★★☆',
                            abilities: ['매우 높은 체력', '강력한 공격', '빠른 발사'],
                            strategy: '체력이 매우 높고 공격력도 강합니다. 우선순위를 두고 집중 공격하거나, 다른 적들을 먼저 처치한 후 상대하세요.',
                            weakness: '속도가 느려 회피하기 쉬움'
                        }
                    },
                    assassin: {
                        name: '암살자', 
                        health: 35, 
                        speed: 5, 
                        damage: 20, 
                        color: '#6b21a8', 
                        size: 28, 
                        shootInterval: 1200, 
                        points: 180,
                        description: '매우 빠른 속도로 움직이며 자주 공격하는 적. 체력은 낮지만 회피하기 매우 어렵습니다.',
                        dexInfo: {
                            category: '일반',
                            difficulty: '★★★★☆',
                            abilities: ['매우 빠른 이동', '빠른 발사'],
                            strategy: '속도가 매우 빠르고 발사 간격이 짧아 가장 위험한 적 중 하나입니다. 우선 처치하는 것이 필수입니다.',
                            weakness: '체력이 매우 낮아 한 번의 공격으로 처치 가능'
                        }
                    },
                    heavy: {
                        name: '중장병', 
                        health: 100, 
                        speed: 0.8, 
                        damage: 40, 
                        color: '#92400e', 
                        size: 50, 
                        shootInterval: 2500, 
                        points: 300,
                        description: '높은 체력과 강력한 공격력을 가진 중장갑 적. 매우 느리지만 한 번 맞으면 큰 피해를 입습니다.',
                        dexInfo: {
                            category: '일반',
                            difficulty: '★★★☆☆',
                            abilities: ['높은 체력', '강력한 공격'],
                            strategy: '체력이 높고 공격력이 강하지만 속도가 매우 느립니다. 거리를 두고 안전하게 공격하세요.',
                            weakness: '속도가 매우 느려 회피하기 매우 쉬움'
                        }
                    },
                    ghost: {
                        name: '유령', 
                        health: 20, 
                        speed: 6, 
                        damage: 10, 
                        color: '#a8a29e', 
                        size: 25, 
                        shootInterval: 2500, 
                        points: 200, 
                        isInvincible: false, 
                        invincibilityDuration: 1000, // 유령 전용 속성
                        description: '일시적으로 무적이 되는 능력을 가진 빠른 적.',
                        dexInfo: {
                            category: '특수',
                            difficulty: '★★☆☆☆',
                            abilities: ['일시 무적', '빠른 이동'],
                            strategy: '무적 상태일 때는 공격이 통하지 않습니다. 무적이 끝날 때까지 기다리거나 다른 적을 공격하세요.',
                            weakness: '체력이 매우 낮아 한 번의 공격으로 처치 가능'
                        }
                    },
                    medic: {
                        name: '치유사', 
                        health: 50, 
                        speed: 1.5, 
                        damage: 0, 
                        color: '#10b981', 
                        size: 30, 
                        shootInterval: 5000, 
                        points: 300, 
                        healAmount: 20, 
                        healRadius: 150,
                        description: '다른 적들을 치료하는 능력을 가진 적. 직접 공격력은 없지만 다른 적들을 강화시킵니다.',
                        dexInfo: {
                            category: '지원',
                            difficulty: '★★☆☆☆',
                            abilities: ['적 치료', '지속적인 위협'],
                            strategy: '치유사가 살아있으면 다른 적들이 계속 회복됩니다. 우선 처치하는 것이 필수입니다.',
                            weakness: '직접 공격력이 없고 체력이 보통임'
                        }
                    },
                    summoner: {
                        name: '소환사', 
                        health: 70, 
                        speed: 1, 
                        damage: 5, 
                        color: '#9333ea', 
                        size: 40, 
                        shootInterval: 8000, 
                        points: 400, 
                        summonCount: 1, 
                        summonType: 'basic',
                        description: '다른 적들을 소환하는 능력을 가진 적. 직접 공격력은 낮지만 소환된 적들이 위험합니다.',
                        dexInfo: {
                            category: '특수',
                            difficulty: '★★★☆☆',
                            abilities: ['적 소환', '지속적인 위협'],
                            strategy: '소환사가 살아있으면 계속해서 적을 소환합니다. 우선 처치하는 것이 필수입니다.',
                            weakness: '직접 공격력이 매우 낮음'
                        }
                    },
                    jumper: {
                        name: '점퍼', 
                        health: 30, 
                        speed: 3, 
                        damage: 18, 
                        color: '#facc15', 
                        size: 35, 
                        shootInterval: 2000, 
                        points: 120, 
                        jumpCooldown: 2000, 
                        lastJump: 0,
                        description: '점프 능력을 가진 적. 갑자기 점프하여 예상치 못한 위치에서 공격할 수 있습니다.',
                        dexInfo: {
                            category: '특수',
                            difficulty: '★★☆☆☆',
                            abilities: ['점프', '예측 불가능한 이동'],
                            strategy: '점프로 갑자기 위치를 바꿀 수 있어 회피하기 어려울 수 있습니다. 점프 패턴을 파악하세요.',
                            weakness: '체력이 낮고 점프 후 공격까지 시간이 필요'
                        }
                    },
                    shielded: {
                        name: '방패병', 
                        health: 120, 
                        speed: 0.7, 
                        damage: 20, 
                        color: '#6b7280', 
                        size: 45, 
                        shootInterval: 2800, 
                        points: 280, 
                        shieldAngle: Math.PI / 3,
                        description: '방패를 가진 적. 특정 방향에서의 공격을 막을 수 있습니다.',
                        dexInfo: {
                            category: '특수',
                            difficulty: '★★★☆☆',
                            abilities: ['방패', '공격 방어'],
                            strategy: '방패로 특정 방향의 공격을 막습니다. 방패가 없는 방향에서 공격하세요.',
                            weakness: '속도가 매우 느리고 방패가 모든 방향을 막지 못함'
                        }
                    },
                    teleporter: {
                        name: '순간이동병', 
                        health: 35, 
                        speed: 1, 
                        damage: 25, 
                        color: '#a78bfa', 
                        size: 30, 
                        shootInterval: 3500, 
                        points: 220, 
                        teleportCooldown: 4000, 
                        lastTeleport: 0, // 순간이동병 전용 속성
                        description: '순간이동 능력을 가진 적. 갑자기 사라졌다가 다른 위치에서 나타납니다.',
                        dexInfo: {
                            category: '특수',
                            difficulty: '★★★☆☆',
                            abilities: ['순간이동', '예측 불가능한 위치'],
                            strategy: '순간이동으로 갑자기 위치를 바꿀 수 있어 회피하기 어려울 수 있습니다. 순간이동 후 공격까지 시간이 필요하니 그 타이밍을 노리세요.',
                            weakness: '순간이동 후 공격까지 시간이 필요하고 체력이 보통임'
                        }
                    },
                    drone: {
                        name: '드론', 
                        health: 20, 
                        speed: 7, 
                        damage: 10, 
                        color: '#94a3b8', 
                        size: 20, 
                        shootInterval: 1000, 
                        points: 80, 
                        flies: true, // 드론 전용 속성
                        description: '매우 빠른 속도로 움직이는 소형 적. 공격력은 낮지만 빠른 속도로 위협적입니다.',
                        dexInfo: {
                            category: '기본',
                            difficulty: '★★☆☆☆',
                            abilities: ['빠른 이동', '빠른 공격'],
                            strategy: '매우 빠른 속도로 움직이므로 예측하기 어렵습니다. 빠른 반응으로 회피하세요.',
                            weakness: '체력이 매우 낮아 한 번의 공격으로 처치 가능'
                        }
                    },
                    spitter: {
                        name: '슬라임병', 
                        health: 50, 
                        speed: 1.3, 
                        damage: 15, 
                        color: '#16a34a', 
                        size: 35, 
                        shootInterval: 2500, 
                        points: 180, 
                        slowEffect: 0.5, 
                        slowDuration: 3000, // 슬라임병 전용 속성
                        description: '플레이어를 둔화시키는 능력을 가진 적. 맞으면 일정 시간 동안 속도가 느려집니다.',
                        dexInfo: {
                            category: '특수',
                            difficulty: '★★☆☆☆',
                            abilities: ['플레이어 둔화', '지속적인 위협'],
                            strategy: '둔화 효과로 인해 다른 적들의 공격을 피하기 어려워집니다. 우선 처치하는 것이 좋습니다.',
                            weakness: '속도가 느리고 체력이 보통임'
                        }
                    },
                    berserker: {
                        name: '광전사', 
                        health: 60, 
                        speed: 3, 
                        damage: 20, 
                        color: '#be123c', 
                        size: 38, 
                        shootInterval: 1800, 
                        points: 250, 
                        rageThreshold: 0.3, 
                        rageSpeedBoost: 1.5, 
                        rageDamageBoost: 1.5, 
                        isRaging: false, // 광전사 전용 속성
                        description: '체력이 낮아지면 광분 상태가 되어 속도와 공격력이 증가하는 적.',
                        dexInfo: {
                            category: '특수',
                            difficulty: '★★★☆☆',
                            abilities: ['광분 상태', '능력치 증가'],
                            strategy: '체력이 30% 이하로 떨어지면 광분 상태가 되어 위험해집니다. 광분 상태 전에 처치하세요.',
                            weakness: '광분 상태 전에는 일반적인 적과 비슷함'
                        }
                    },
                    // 새로운 보스 타입
                    boss_alpha: {
                        name: '알파 보스', health: 200, speed: 2, damage: 25, color: '#ff007f', size: 65, shootInterval: 1800, points: 700,
                        summonCooldown: 10000, lastSummon: 0, summonCount: 2, summonType: 'basic',
                        // 스킬1: 미니언 소환
                        dashCooldown: 7000, lastDash: 0, dashCount: 3, dashDuration: 300, isDashing: false,
                        // 스킬2: 연속 돌진
                        shockwaveCooldown: 12000, lastShockwave: 0,
                        description: '미니언 소환, 연속 돌진, 광역 충격파'
                    },
                    boss_beta: {
                        name: '베타 보스', health: 300, speed: 1.5, damage: 20, color: '#00ffff', size: 70, shootInterval: 2500, points: 800,
                        // 스킬1: 쉴드(무적)
                        shieldCooldown: 10000, lastShield: 0, shieldDuration: 3000, isInvincible: false, invincibleEndTime: 0,
                        // 스킬2: 탄막 발사
                        barrageCooldown: 8000, lastBarrage: 0,
                        // 스킬3: 체력 회복
                        healCooldown: 14000, lastHeal: 0, healAmount: 60,
                        description: '쉴드, 탄막, 체력 회복'
                    },
                    boss_gamma: {
                        name: '감마 보스', health: 180, speed: 3.5, damage: 35, color: '#ff8c00', size: 60, shootInterval: 1000, points: 900,
                        // 스킬1: 순간이동
                        teleportCooldown: 6000, lastTeleport: 0, teleportRange: 200,
                        // 스킬2: 레이저
                        laserCooldown: 9000, lastLaser: 0, laserDuration: 1200,
                        // 스킬3: 속도 버프
                        speedBuffCooldown: 12000, lastSpeedBuff: 0, speedBuffDuration: 3000, isSpeedBuffed: false,
                        description: '순간이동, 레이저, 속도 버프'
                    },
                    boss_delta: {
                        name: '델타 보스', health: 350, speed: 1.7, damage: 30, color: '#22223b', size: 80, shootInterval: 2000, points: 1200,
                        // 스킬1: 블랙홀
                        blackholeCooldown: 9000, lastBlackhole: 0, blackholeRadius: 180,
                        // 스킬2: 광역 폭발
                        explosionCooldown: 11000, lastExplosion: 0,
                        // 스킬3: 플레이어 둔화
                        slowCooldown: 13000, lastSlow: 0, slowDuration: 3000,
                        description: '블랙홀, 광역 폭발, 플레이어 둔화'
                    },
                    boss_epsilon: {
                        name: '엡실론 보스', health: 320, speed: 2.2, damage: 22, color: '#fbbf24', size: 75, shootInterval: 1800, points: 1100,
                        // 스킬1: 분신 생성
                        cloneCooldown: 10000, lastClone: 0, clones: 2, hasCloned: false,
                        // 스킬2: 탄환 반사
                        reflectCooldown: 9000, lastReflect: 0, reflectDuration: 2000, isReflecting: false,
                        // 스킬3: 체력 흡수
                        drainCooldown: 12000, lastDrain: 0, drainAmount: 40,
                        description: '분신, 탄환 반사, 체력 흡수'
                    },
                    boss_zeta: {
                        name: '제타 보스', health: 300, speed: 2.5, damage: 28, color: '#06d6a0', size: 78, shootInterval: 1700, points: 1300,
                        // 스킬1: 시간 왜곡(슬로우)
                        timeWarpCooldown: 8000, lastTimeWarp: 0, timeWarpDuration: 2500, isTimeWarp: false,
                        // 스킬2: 연발 사격
                        rapidFireCooldown: 9000, lastRapidFire: 0, rapidFireDuration: 2000, isRapidFire: false,
                        // 스킬3: 랜덤 위치 이동
                        randomMoveCooldown: 11000, lastRandomMove: 0,
                        description: '시간 왜곡, 연발 사격, 랜덤 이동'
                    },
                    boss_eta: {
                        name: '에타 보스', health: 400, speed: 1.3, damage: 40, color: '#ff006e', size: 90, shootInterval: 3000, points: 1500,
                        // 스킬1: 레이저
                        laserCooldown: 7000, lastLaser: 0, laserDuration: 1200,
                        // 스킬2: 연속 점프
                        jumpCooldown: 9000, lastJump: 0, jumpCount: 3, jumpPower: 30,
                        // 스킬3: 방어력 증가
                        armorBuffCooldown: 12000, lastArmorBuff: 0, armorBuffDuration: 4000, isArmorBuffed: false,
                        description: '레이저, 연속 점프, 방어력 증가'
                    },
                    boss_theta: {
                        name: '쎄타 보스', health: 370, speed: 1.8, damage: 26, color: '#3a86ff', size: 85, shootInterval: 2100, points: 1250,
                        // 스킬1: 발사체 반사
                        reflectAllCooldown: 10000, lastReflectAll: 0, reflectAllDuration: 2000, isReflecting: false,
                        // 스킬2: 도탄 탄환
                        ricochetCooldown: 9000, lastRicochet: 0, ricochetCount: 5,
                        // 스킬3: 플레이어 위치 추적
                        trackCooldown: 11000, lastTrack: 0, trackDuration: 2000, isTracking: false,
                        description: '발사체 반사, 도탄, 위치 추적'
                    },
                    // === 신규 적 10종 ===
                    mirror: {
                        name: '미러 적', 
                        health: 35, 
                        speed: 2.5, 
                        damage: 15, 
                        color: '#b6e0fe', 
                        size: 32, 
                        shootInterval: 1800, 
                        points: 180, 
                        mirrorPlayer: true, // 플레이어 움직임 따라함
                        description: '플레이어의 움직임을 따라하는 능력을 가진 적. 예측하기 어려운 패턴을 보입니다.',
                        dexInfo: {
                            category: '특수',
                            difficulty: '★★☆☆☆',
                            abilities: ['플레이어 모방', '예측 불가능한 움직임'],
                            strategy: '플레이어의 움직임을 따라하므로 예측하기 어렵습니다. 패턴을 파악하여 대응하세요.',
                            weakness: '체력이 낮고 직접적인 공격력은 보통임'
                        }
                    },
                    leech: {
                        name: '흡혈 적', 
                        health: 30, 
                        speed: 2, 
                        damage: 10, 
                        color: '#a21caf', 
                        size: 30, 
                        shootInterval: 2000, 
                        points: 160, 
                        leechAmount: 10, // 닿으면 체력 흡수
                        description: '플레이어와 닿으면 체력을 흡수하는 능력을 가진 적.',
                        dexInfo: {
                            category: '특수',
                            difficulty: '★★☆☆☆',
                            abilities: ['체력 흡수', '접촉 공격'],
                            strategy: '닿으면 체력을 흡수하므로 접촉을 피해야 합니다. 원거리에서 공격하세요.',
                            weakness: '체력이 낮고 공격력이 낮음'
                        }
                    },
                    mine: {
                        name: '지뢰 적', 
                        health: 20, 
                        speed: 1, 
                        damage: 40, 
                        color: '#fbbf24', 
                        size: 28, 
                        shootInterval: 99999, 
                        points: 120, 
                        explodesOnNear: true, 
                        explodeRadius: 60, // 근접 폭발
                        description: '플레이어가 가까이 오면 폭발하는 지뢰형 적.',
                        dexInfo: {
                            category: '특수',
                            difficulty: '★★☆☆☆',
                            abilities: ['근접 폭발', '높은 폭발 데미지'],
                            strategy: '가까이 가면 폭발하므로 원거리에서 공격하세요. 폭발 반경을 고려하여 거리를 유지하세요.',
                            weakness: '체력이 매우 낮고 직접 공격력이 없음'
                        }
                    },
                    freezer: {
                        name: '빙결 적', 
                        health: 28, 
                        speed: 1.7, 
                        damage: 12, 
                        color: '#38bdf8', 
                        size: 30, 
                        shootInterval: 2200, 
                        points: 150, 
                        freezeOnHit: true, 
                        freezeDuration: 2000, // 맞으면 빙결
                        description: '플레이어를 맞추면 빙결시키는 능력을 가진 적.',
                        dexInfo: {
                            category: '특수',
                            difficulty: '★★☆☆☆',
                            abilities: ['플레이어 빙결', '이동 제한'],
                            strategy: '맞으면 빙결되어 움직일 수 없게 됩니다. 회피에 집중하고 우선 처치하세요.',
                            weakness: '체력이 낮고 공격력이 낮음'
                        }
                    },
                    reflector: {
                        name: '반사 적', 
                        health: 40, 
                        speed: 1.5, 
                        damage: 15, 
                        color: '#f472b6', 
                        size: 34, 
                        shootInterval: 2500, 
                        points: 200, 
                        reflectChance: 0.3, // 30% 확률로 탄환 반사
                        description: '일정 확률로 탄환을 반사하는 능력을 가진 적.',
                        dexInfo: {
                            category: '특수',
                            difficulty: '★★★☆☆',
                            abilities: ['탄환 반사', '예측 불가능한 공격'],
                            strategy: '30% 확률로 탄환을 반사하므로 공격할 때 주의해야 합니다. 반사된 탄환을 피하세요.',
                            weakness: '속도가 느리고 반사 확률이 30%로 제한적임'
                        }
                    },
                    healer: {
                        name: '힐러 적', 
                        health: 32, 
                        speed: 1.2, 
                        damage: 0, 
                        color: '#bef264', 
                        size: 32, 
                        shootInterval: 4000, 
                        points: 180, 
                        healAmount: 15, 
                        healRadius: 120, 
                        healsOthers: true, // 주변 적 회복
                        description: '주변의 다른 적들을 치료하는 능력을 가진 적.',
                        dexInfo: {
                            category: '지원',
                            difficulty: '★★☆☆☆',
                            abilities: ['적 치료', '지속적인 위협'],
                            strategy: '다른 적들을 치료하므로 우선 처치해야 합니다. 치료 범위를 벗어나서 공격하세요.',
                            weakness: '직접 공격력이 없고 체력이 낮음'
                        }
                    },
                    portal: {
                        name: '포탈 적', 
                        health: 30, 
                        speed: 2.2, 
                        damage: 13, 
                        color: '#818cf8', 
                        size: 30, 
                        shootInterval: 2000, 
                        points: 170, 
                        teleportsNearPlayer: true, 
                        teleportCooldown: 3000, 
                        lastTeleport: 0, // 순간이동
                        description: '플레이어 근처로 순간이동하는 능력을 가진 적.',
                        dexInfo: {
                            category: '특수',
                            difficulty: '★★★☆☆',
                            abilities: ['순간이동', '예측 불가능한 위치'],
                            strategy: '갑자기 플레이어 근처로 순간이동할 수 있습니다. 순간이동 후 공격까지 시간이 필요하니 그 타이밍을 노리세요.',
                            weakness: '체력이 낮고 순간이동 후 공격까지 시간이 필요'
                        }
                    },
                    exploder: {
                        name: '폭발 적', 
                        health: 25, 
                        speed: 2, 
                        damage: 18, 
                        color: '#f87171', 
                        size: 28, 
                        shootInterval: 99999, 
                        points: 140, 
                        explodesOnDeath: true, 
                        explodeRadius: 70, // 죽으면 폭발
                        description: '죽을 때 폭발하는 능력을 가진 적.',
                        dexInfo: {
                            category: '특수',
                            difficulty: '★★☆☆☆',
                            abilities: ['사후 폭발', '광역 데미지'],
                            strategy: '죽을 때 폭발하므로 다른 적들과 함께 있을 때 주의해야 합니다. 폭발 반경을 고려하여 처치하세요.',
                            weakness: '체력이 낮고 직접 공격력이 없음'
                        }
                    },
                    magnet: {
                        name: '자석 적', 
                        health: 30, 
                        speed: 1.8, 
                        damage: 10, 
                        color: '#fde047', 
                        size: 30, 
                        shootInterval: 2000, 
                        points: 160, 
                        pullsItems: true, 
                        magnetRadius: 180, // 아이템 끌어당김
                        description: '주변의 아이템을 끌어당기는 능력을 가진 적.',
                        dexInfo: {
                            category: '특수',
                            difficulty: '★★☆☆☆',
                            abilities: ['아이템 흡수', '자원 제한'],
                            strategy: '아이템을 끌어당기므로 아이템을 얻기 어려워집니다. 우선 처치하여 아이템을 확보하세요.',
                            weakness: '체력이 낮고 공격력이 낮음'
                        }
                    },
                    curse: {
                        name: '저주 적', 
                        health: 28, 
                        speed: 1.6, 
                        damage: 10, 
                        color: '#a3a3a3', 
                        size: 30, 
                        shootInterval: 2200, 
                        points: 170, 
                        cursesPlayer: true, 
                        curseDuration: 2500, // 맞추면 디버프
                        description: '플레이어를 맞추면 저주를 걸어 디버프를 주는 적.',
                        dexInfo: {
                            category: '특수',
                            difficulty: '★★☆☆☆',
                            abilities: ['플레이어 저주', '디버프 공격'],
                            strategy: '맞으면 저주 효과로 인해 능력치가 감소합니다. 회피에 집중하고 우선 처치하세요.',
                            weakness: '체력이 낮고 공격력이 낮음'
                        }
                    },
                    floater: {
                        name: '플로터', 
                        health: 35, 
                        speed: 2.5, 
                        damage: 15, 
                        color: '#8b5cf6', 
                        size: 32, 
                        shootInterval: 2000, 
                        points: 180, 
                        flies: true, 
                        floatDirection: 0, 
                        lastDirectionChange: 0, // 자유로운 움직임
                        description: '자유롭게 움직이는 능력을 가진 적. 예측하기 어려운 패턴을 보입니다.',
                        dexInfo: {
                            category: '특수',
                            difficulty: '★★☆☆☆',
                            abilities: ['자유로운 움직임', '예측 불가능한 패턴'],
                            strategy: '자유롭게 움직이므로 예측하기 어렵습니다. 패턴을 파악하여 대응하세요.',
                            weakness: '체력이 보통이고 직접적인 특수 능력이 제한적임'
                        }
                    },
                    phaser: {
                        name: '페이저', 
                        health: 40, 
                        speed: 2, 
                        damage: 20, 
                        color: '#06b6d4', 
                        size: 35, 
                        shootInterval: 1800, 
                        points: 200, 
                        phaseCooldown: 8000, 
                        lastPhase: 0, 
                        phaseDuration: 2000, 
                        isPhasing: false, // 페이즈 스킬
                        description: '일정 시간 동안 페이즈 상태가 되어 무적이 되는 능력을 가진 적.',
                        dexInfo: {
                            category: '특수',
                            difficulty: '★★★☆☆',
                            abilities: ['페이즈 무적', '일시적 보호'],
                            strategy: '페이즈 상태일 때는 공격이 통하지 않습니다. 페이즈가 끝날 때까지 기다리거나 다른 적을 공격하세요.',
                            weakness: '페이즈 상태가 아닐 때는 일반적인 적과 비슷함'
                        }
                    },
                    // === 완전히 새로운 적 10종 추가 ===
                    timekeeper: {
                        name: '타임키퍼', 
                        health: 50, 
                        speed: 2.0, 
                        damage: 20, 
                        color: '#ff6b9d', 
                        size: 35, 
                        shootInterval: 2000, 
                        points: 280, 
                        timeReverse: true, 
                        timeReverseCooldown: 12000, 
                        lastTimeReverse: 0, 
                        timeReverseDuration: 3000, 
                        isTimeReversed: false, // 시간 역행
                        description: '시간을 역행시켜 체력을 회복하는 능력을 가진 적.',
                        dexInfo: {
                            category: '특수',
                            difficulty: '★★★☆☆',
                            abilities: ['시간 역행', '체력 회복'],
                            strategy: '시간 역행으로 체력을 회복할 수 있습니다. 회복 전에 처치하거나 회복 후 다시 공격하세요.',
                            weakness: '시간 역행 쿨다운이 길고 일반 상태에서는 보통임'
                        }
                    },
                    gravity: {
                        name: '그래비티', 
                        health: 45, 
                        speed: 1.8, 
                        damage: 18, 
                        color: '#9d4edd', 
                        size: 38, 
                        shootInterval: 2500, 
                        points: 260, 
                        gravityField: true, 
                        gravityCooldown: 8000, 
                        lastGravity: 0, 
                        gravityRadius: 200, 
                        gravityStrength: 0.8, // 중력장 생성
                        description: '중력장을 생성하여 플레이어를 끌어당기는 능력을 가진 적.',
                        dexInfo: {
                            category: '특수',
                            difficulty: '★★★☆☆',
                            abilities: ['중력장', '플레이어 끌어당김'],
                            strategy: '중력장으로 플레이어를 끌어당기므로 다른 적들의 공격을 피하기 어려워집니다. 중력장 범위를 벗어나세요.',
                            weakness: '중력장 쿨다운이 길고 일반 상태에서는 보통임'
                        }
                    },
                    echo: {
                        name: '에코', 
                        health: 40, 
                        speed: 2.2, 
                        damage: 15, 
                        color: '#4cc9f0', 
                        size: 32, 
                        shootInterval: 1800, 
                        points: 240, 
                        echoShot: true, 
                        echoCount: 3, 
                        echoDelay: 500, 
                        lastEcho: 0, // 에코 발사
                        description: '에코 효과로 여러 발의 탄환을 연속으로 발사하는 적.',
                        dexInfo: {
                            category: '특수',
                            difficulty: '★★☆☆☆',
                            abilities: ['에코 발사', '연속 공격'],
                            strategy: '에코로 여러 발의 탄환을 연속으로 발사합니다. 탄환의 타이밍을 파악하여 회피하세요.',
                            weakness: '체력이 보통이고 에코 발사 후 공격까지 시간이 필요'
                        }
                    },
                    vortex: {
                        name: '보르텍스', 
                        health: 55, 
                        speed: 1.5, 
                        damage: 25, 
                        color: '#7209b7', 
                        size: 40, 
                        shootInterval: 3000, 
                        points: 320, 
                        vortexPull: true, 
                        vortexCooldown: 10000, 
                        lastVortex: 0, 
                        vortexRadius: 250, 
                        vortexStrength: 2.0, // 소용돌이 끌어당김
                        description: '소용돌이를 생성하여 플레이어를 강하게 끌어당기는 능력을 가진 적.',
                        dexInfo: {
                            category: '특수',
                            difficulty: '★★★☆☆',
                            abilities: ['소용돌이', '강한 끌어당김'],
                            strategy: '소용돌이로 강하게 끌어당기므로 다른 적들의 공격을 피하기 어려워집니다. 소용돌이 범위를 벗어나세요.',
                            weakness: '소용돌이 쿨다운이 길고 일반 상태에서는 보통임'
                        }
                    },
                    prism: {
                        name: '프리즘', 
                        health: 35, 
                        speed: 2.5, 
                        damage: 12, 
                        color: '#f72585', 
                        size: 30, 
                        shootInterval: 1600, 
                        points: 220, 
                        prismSplit: true, 
                        prismCount: 5, 
                        prismAngle: Math.PI/3, 
                        lastPrism: 0, // 프리즘 분산
                        description: '프리즘 효과로 탄환을 여러 방향으로 분산시키는 적.',
                        dexInfo: {
                            category: '특수',
                            difficulty: '★★☆☆☆',
                            abilities: ['프리즘 분산', '다방향 공격'],
                            strategy: '프리즘으로 탄환을 여러 방향으로 분산시킵니다. 분산된 탄환들을 모두 피해야 합니다.',
                            weakness: '체력이 낮고 개별 탄환의 데미지가 낮음'
                        }
                    },
                    quantum: {
                        name: '퀀텀', 
                        health: 60, 
                        speed: 2.8, 
                        damage: 30, 
                        color: '#3a0ca3', 
                        size: 36, 
                        shootInterval: 2200, 
                        points: 300, 
                        quantumTeleport: true, 
                        quantumCooldown: 6000, 
                        lastQuantum: 0, 
                        quantumRange: 300, // 양자 순간이동
                        description: '양자 순간이동 능력을 가진 적. 갑자기 사라졌다가 다른 위치에서 나타납니다.',
                        dexInfo: {
                            category: '특수',
                            difficulty: '★★★☆☆',
                            abilities: ['양자 순간이동', '예측 불가능한 위치'],
                            strategy: '양자 순간이동으로 갑자기 위치를 바꿀 수 있어 회피하기 어려울 수 있습니다. 순간이동 후 공격까지 시간이 필요하니 그 타이밍을 노리세요.',
                            weakness: '순간이동 후 공격까지 시간이 필요하고 체력이 보통임'
                        }
                    },
                    crystal: {
                        name: '크리스탈', 
                        health: 70, 
                        speed: 1.2, 
                        damage: 35, 
                        color: '#4361ee', 
                        size: 45, 
                        shootInterval: 3500, 
                        points: 350, 
                        crystalShield: true, 
                        crystalCooldown: 15000, 
                        lastCrystal: 0, 
                        crystalDuration: 5000, 
                        isCrystalShielded: false, // 크리스탈 방패
                        description: '크리스탈 방패를 생성하여 일정 시간 동안 무적이 되는 능력을 가진 적.',
                        dexInfo: {
                            category: '특수',
                            difficulty: '★★★☆☆',
                            abilities: ['크리스탈 방패', '일시적 무적'],
                            strategy: '크리스탈 방패 상태일 때는 공격이 통하지 않습니다. 방패가 끝날 때까지 기다리거나 다른 적을 공격하세요.',
                            weakness: '크리스탈 방패 쿨다운이 매우 길고 일반 상태에서는 보통임'
                        }
                    },

                    plasma: {
                        name: '플라즈마', 
                        health: 48, 
                        speed: 2.1, 
                        damage: 28, 
                        color: '#06ffa5', 
                        size: 34, 
                        shootInterval: 1900, 
                        points: 270, 
                        plasmaChain: true, 
                        plasmaChainCount: 4, 
                        plasmaChainRange: 150, 
                        lastPlasma: 0, // 플라즈마 체인
                        description: '플라즈마 체인과 폭발 능력을 가진 특수 적. 연쇄 공격으로 위험합니다.',
                        dexInfo: {
                            category: '특수',
                            difficulty: '★★★☆☆',
                            abilities: ['플라즈마 체인', '플라즈마 폭발'],
                            strategy: '플라즈마 체인으로 연쇄 공격을 할 수 있습니다. 체인 범위를 벗어나거나 체인을 끊어주세요.',
                            weakness: '체력이 보통이고 체인 공격 후 공격까지 시간이 필요'
                        }
                    },
                    nebula: {
                        name: '네뷸라', 
                        health: 65, 
                        speed: 1.6, 
                        damage: 32, 
                        color: '#ff9e00', 
                        size: 42, 
                        shootInterval: 2800, 
                        points: 340, 
                        nebulaCloud: true, 
                        nebulaCooldown: 12000, 
                        lastNebula: 0, 
                        nebulaRadius: 180, 
                        nebulaDamage: 8, // 네뷸라 구름
                        description: '네뷸라 구름을 생성하여 지속적인 데미지를 주는 능력을 가진 적.',
                        dexInfo: {
                            category: '특수',
                            difficulty: '★★★☆☆',
                            abilities: ['네뷸라 구름', '지속 데미지'],
                            strategy: '네뷸라 구름으로 지속적인 데미지를 줍니다. 구름 범위를 벗어나거나 구름이 사라질 때까지 기다리세요.',
                            weakness: '네뷸라 구름 쿨다운이 길고 일반 상태에서는 보통임'
                        }
                    },
                    // === 신규 보스 5종 ===
                    boss_delta: {
                        name: '델타 보스', health: 350, speed: 1.7, damage: 30, color: '#22223b', size: 80, shootInterval: 2000, points: 1200, blackholeCooldown: 9000, lastBlackhole: 0, blackholeRadius: 180 // 블랙홀 생성
                    },
                    boss_epsilon: {
                        name: '엡실론 보스', health: 320, speed: 2.2, damage: 22, color: '#fbbf24', size: 75, shootInterval: 1800, points: 1100, cloneThreshold: 0.5, clones: 3, hasCloned: false // 분신 생성
                    },
                    boss_zeta: {
                        name: '제타 보스', health: 300, speed: 2.5, damage: 28, color: '#06d6a0', size: 78, shootInterval: 1700, points: 1300, timeWarpCooldown: 8000, lastTimeWarp: 0 // 시간 왜곡
                    },
                    boss_eta: {
                        name: '에타 보스', health: 400, speed: 1.3, damage: 40, color: '#ff006e', size: 90, shootInterval: 3000, points: 1500, laserCooldown: 7000, lastLaser: 0, laserDuration: 1200 // 레이저 발사
                    },
                    boss_theta: {
                        name: '쎄타 보스', health: 370, speed: 1.8, damage: 26, color: '#3a86ff', size: 85, shootInterval: 2100, points: 1250, reflectAllCooldown: 10000, lastReflectAll: 0, reflectAllDuration: 2000 // 발사체 반사
                    },
                    // === 추가 적 2종 ===
                    juggernaut: {
                        name: '저거너트', health: 800, speed: 1.2, damage: 8, color: '#444444', size: 60, shootInterval: 3000, points: 600, description: '공격력은 약하지만 엄청난 체력을 자랑하는 거대 적.'
                    },
                    // 참신한 하늘 몹 (탄막)
                    skyblaster: {
                        name: '스카이블래스터',
                        health: 90,
                        speed: 3.2,
                        damage: 14,
                        color: '#00bfff',
                        size: 36,
                        shootInterval: 1400,
                        points: 350,
                        flies: true,
                        multishot: 6, // 한 번에 6발 퍼뜨림
                        spread: Math.PI / 2, // 90도 범위로 퍼짐
                        description: '하늘을 날며 한 번에 여러 발의 총알을 퍼뜨리는 참신한 탄막 몹.'
                    },
                    melee: {
                        name: '근접 공격',
                        health: 0,
                        speed: 0,
                        damage: 0,
                        color: '#f59e42',
                        size: 0,
                        shootInterval: 0,
                        points: 0,
                        description: '근접 공격 무기'
                    }
                };

                // 보상 옵션 정의
                this.REWARD_OPTIONS = [
                    { text: '+100 최대 체력', type: 'maxHealth', value: 100 },
                    { text: '+50 현재 체력', type: 'currentHealth', value: 50 },
                    { text: '+5 공격력', type: 'damage', value: 5 },
                    { text: '+1 이동 속도', type: 'speed', value: 1 },
                    { text: '+1 다중 발사', type: 'multishot', value: 1 },
                    { text: '회전 칼날', type: 'orbiting_knife', value: 1 }, // 보상으로 회전 칼날 추가
                    { text: '관통 사격', type: 'piercing_shot', value: 1 }, // 보상으로 관통 사격 추가
                    { text: '폭발 사격', type: 'explosive_shot', value: 1 }, // 보상으로 폭발 사격 추가
                    { text: '도탄 사격', type: 'ricochet_shot', value: 1 }, // 보상으로 도탄 사격 추가
                    { text: '유도 사격', type: 'homing_shot', value: 1 }, // 보상으로 유도 사격 추가
                    { text: '분열 사격', type: 'split_shot', value: 1 }, // 보상으로 분열 사격 추가
                    { text: '생명력 흡수', type: 'life_steal', value: 0.02 }, // 생명력 흡수 추가 (2%)
                    { text: '치명타 확률', type: 'crit_chance', value: 0.05 }, // 치명타 확률 추가 (5%)
                    { text: '재사용 대기시간 감소', type: 'cooldown_reduction', value: 0.05 }, // 재사용 대기시간 감소 (5%)
                    { text: '방어력', type: 'armor', value: 5 }, // 방어력 추가 (5)
                    { text: '시간 정지', type: 'time_stop', value: 3000 }, // 시간 정지 아이템
                    { text: '탄약 재생', type: 'ammo_regen', value: 10 } // 탄약 재생 아이템
                ];
                
                // 이벤트 리스너 설정
                this.setupEventListeners();
                this.xp = 0;

                // GlassCombatArena 생성자 내부에 추가
                this.upgrades = { gun: 0, melee: 0, health: 0, speed: 0, cooldown: 0 };
                this.scoreMilestones = [1000, 2000, 3000, 5000, 8000, 12000, 18000, 25000, 35000, 50000];
                this.nextMilestoneIndex = 0;

                // 1. SHOP_ITEMS를 JS에 명확히 정의 (GlassCombatArena 클래스 내 constructor에 추가)
                this.SHOP_ITEMS = [
                    { text: '+100 최대 체력', type: 'maxHealth', value: 100, basePrice: 1000, purchaseCount: 0 },
                    { text: '+50 현재 체력', type: 'currentHealth', value: 50, basePrice: 700, purchaseCount: 0 },
                    { text: '+5 공격력', type: 'damage', value: 5, basePrice: 1200, purchaseCount: 0 },
                    { text: '+1 이동 속도', type: 'speed', value: 1, basePrice: 900, purchaseCount: 0 },
                    { text: '+1 다중 발사', type: 'multishot', value: 1, basePrice: 1500, purchaseCount: 0 },
                    { text: '회전 칼날', type: 'orbiting_knife', value: 1, basePrice: 2000, purchaseCount: 0 },
                    { text: '관통 사격', type: 'piercing_shot', value: 1, basePrice: 1800, purchaseCount: 0 },
                    { text: '폭발 사격', type: 'explosive_shot', value: 1, basePrice: 1800, purchaseCount: 0 },
                    { text: '도탄 사격', type: 'ricochet_shot', value: 1, basePrice: 1800, purchaseCount: 0 },
                    { text: '유도 사격', type: 'homing_shot', value: 1, basePrice: 1800, purchaseCount: 0 },
                    { text: '분열 사격', type: 'split_shot', value: 1, basePrice: 1800, purchaseCount: 0 },
                    { text: '흡혈', type: 'life_steal', value: 0.05, basePrice: 2200, purchaseCount: 0 },
                    { text: '치명타 확률', type: 'crit_chance', value: 0.05, basePrice: 2000, purchaseCount: 0 },
                    { text: '재사용 대기시간 감소', type: 'cooldown_reduction', value: 0.05, basePrice: 2000, purchaseCount: 0 },
                    { text: '방어력', type: 'armor', value: 5, basePrice: 2000, purchaseCount: 0 },
                    { text: '탄약 자동 회복', type: 'ammo_regen', value: 1, basePrice: 1800, purchaseCount: 0 }
                ];


            }
            
            // 캔버스 크기를 창 크기에 맞게 조정
            resizeCanvas = () => {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }
            
            // 이벤트 리스너 설정 (키보드, 마우스, 창 크기 조정)
            setupEventListeners = () => {
                // 키보드 입력 처리
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    if (e.key === ' ') e.preventDefault(); // 스페이스바 기본 동작 방지 (스크롤)
                    if (e.key.toLowerCase() === 'e') this.tryDash();
                    if (e.key === '1') this.currentWeapon = 'gun';
                    if (e.key === '2') this.currentWeapon = 'melee';
                    if (e.key.toLowerCase() === 'r') this.reload(); // R키로 재장전
                    
                    // 플레이어2 키 입력 처리 (멀티플레이 모드일 때만)
                    if (this.gameState.player2 && this.gameState.multiplayerMode) {
                        // 플레이어2 키 매핑: WASD -> IJKL, 스페이스 -> 엔터, R -> T
                        const player2KeyMap = {
                            'i': 'w', 'j': 'a', 'k': 's', 'l': 'd',
                            'enter': ' ', 't': 'r'
                        };
                        
                        const mappedKey = player2KeyMap[e.key.toLowerCase()];
                        if (mappedKey) {
                            this.gameState.player2.keys[mappedKey] = true;
                        }
                        
                        // 플레이어2 발사 (O키)
                        if (e.key.toLowerCase() === 'o' && this.gameState.gameStatus === 'playing' && this.gameState.multiplayerMode) {
                            this.shootPlayer2();
                        }
                        
                        // 플레이어2 재장전 (T키)
                        if (e.key.toLowerCase() === 't') {
                            this.reloadPlayer2();
                        }
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                    
                    // 플레이어2 키 입력 처리
                    if (this.gameState.player2 && this.gameState.multiplayerMode) {
                        const player2KeyMap = {
                            'i': 'w', 'j': 'a', 'k': 's', 'l': 'd',
                            'enter': ' ', 't': 'r'
                        };
                        
                        const mappedKey = player2KeyMap[e.key.toLowerCase()];
                        if (mappedKey) {
                            this.gameState.player2.keys[mappedKey] = false;
                        }
                    }
                });
                
                // 마우스 입력 처리
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouse.x = e.clientX - rect.left;
                    this.mouse.y = e.clientY - rect.top;
                });
                
                this.canvas.addEventListener('click', (e) => {
                    if (this.gameState.gameStatus === 'playing') {
                        this.shoot(); // 게임 플레이 중일 때만 발사
                    } else if (e.button === 0 && this.gameState.gameStatus === 'start') {
                        // 시작 화면에서 클릭 시 시작 버튼 클릭과 동일하게 처리 (선택 사항)
                        // document.getElementById('startButton').click();
                    } else if (e.button === 0 && this.gameState.gameStatus === 'game-over') {
                        // 게임 오버 화면에서 클릭 시 재시작 (선택 사항)
                        // this.resetGame();
                    }
                });
                
                // 창 크기 조정 시 캔버스 크기 재조정
                window.addEventListener('resize', this.resizeCanvas);

                // 시작 버튼 클릭 이벤트
                document.getElementById('startButton').addEventListener('click', this.startGame);
                
                // 적 도감 버튼 클릭 이벤트
                document.getElementById('enemyDexHUDButton').addEventListener('click', () => {
                    this.showEnemyDex();
                });
                
                // 적 도감 닫기 버튼
                document.getElementById('closeEnemyDexButton').addEventListener('click', () => {
                    this.hideEnemyDex();
                });
            }

            // 시작 화면 표시 (캔버스 블러 처리)
            showStartScreen = () => {
                this.canvas.style.filter = 'blur(10px)'; // 캔버스 블러 처리
                this.canvas.style.display = 'block'; // 캔버스 보이게
                document.querySelector('.hud').style.display = 'none'; // HUD 숨김
                document.getElementById('startScreen').style.display = 'flex'; // 시작 화면 표시
                document.getElementById('rewardSelectionScreen').style.display = 'none'; // 보상 화면 숨김
            }

            // 테스팅 존 시작
            startTestZone = () => {
                this.canvas.style.filter = 'blur(0px)'; // 캔버스 블러 제거
                document.getElementById('introScreen').style.display = 'none'; // 인트로 화면 숨김
                document.querySelector('.hud').style.display = 'flex'; // HUD 표시
                document.getElementById('rewardSelectionScreen').style.display = 'none'; // 보상 화면 숨김

                // 게임 상태 초기화 (테스팅 존용)
                this.gameState = {
                    player: {
                        x: this.canvas.width / 2, y: this.canvas.height / 2,
                        width: 40, height: 40,
                        vx: 0, vy: 0,
                        health: 150, maxHealth: 150,
                        ammo: 30, maxAmmo: 30,
                        speed: 5, jumpPower: 15,
                        onGround: false, facing: 0,
                        expression: this.getRandomExpression(),
                        color: '#6366f1',
                        baseDamage: 10,
                        multishot: 1,
                        rapidFireTime: 0,
                        damageReductionFactor: 1,
                        shieldBoostEndTime: 0,
                        healthRegenEndTime: 0,
                        lastRegenTick: 0,
                        magnetEndTime: 0,
                        magnetRadius: 200,
                        lastHitById: null,
                        type: 'player',
                        orbitingKnives: [],
                        piercingShot: 0,
                        explosiveShot: 0,
                        ricochetLevel: 0,
                        homingLevel: 0,
                        splitLevel: 0,
                        lifeStealPercent: 0,
                        critChance: 0,
                        critMultiplier: 1.5,
                        cooldownReduction: 0,
                        armor: 0,
                        timeStopEndTime: 0,
                        ammoRegenEndTime: 0,
                        lastAmmoRegenTick: 0,
                        ammoRegenAmount: 0,
                        dashCooldown: 0,
                        dashEndTime: 0,
                        isDashing: false,
                        reloadTime: 1500,
                        isReloading: false,
                        machineGunMode: false,
                        machineGunPenalty: false,
                        reloadPenalty: 0,
                        gunRecoil: 0,
                        gunRecoilTarget: 0,
                    },
                    enemies: [],
                    projectiles: [],
                    items: [],
                    particles: [],
                    floatingTexts: [],
                    allies: [],
                    score: 0,
                    wave: 1,
                    gameStatus: 'playing',
                    message: '',
                    messageTimer: 0,
                    playerSlowedEndTime: 0,
                    timeSlowEndTime: 0,
                    timeSlowEffect: 1
                };
                
                // 보스 시스템 초기화
                this.bossSystem = {
                    isActive: false,
                    currentBoss: null,
                    spawnLock: false
                };
                
                // 게임 모드 설정 (테스팅 존)
                this.gameMode = 'testzone';
                
                // 테스팅 존 UI 버튼을 HUD에 추가
                this.addTestZoneButtonToHUD();
                
                this.gameLoop(); // 게임 루프 시작
                this.updateHUD(); // HUD 초기 업데이트
                this.hideMessage(); // 메시지 숨기기

                // 퀘스트 초기화
                this.questSystem.activeQuests = [];
                for (let i = 0; i < 3; i++) {
                    this.questSystem.activeQuests.push(this.generateQuest());
                }
                this.updateQuestUI();

                this.currentWeapon = 'gun';
                this.upgrades = { gun: 0, melee: 0, health: 0, speed: 0, cooldown: 0 };
            }

            // 멀티플레이 게임 시작 메서드
            startMultiplayerGame = (mode, config) => {
                this.canvas.style.filter = 'blur(0px)';
                document.getElementById('startScreen').style.display = 'none';
                document.querySelector('.hud').style.display = 'flex';
                document.getElementById('rewardSelectionScreen').style.display = 'none';

                // 게임 상태 초기화
                this.gameState = {
                    player: {
                        x: this.canvas.width / 2, y: this.canvas.height / 2,
                        width: 40, height: 40,
                        vx: 0, vy: 0,
                        health: 150, maxHealth: 150,
                        ammo: 30, maxAmmo: 30,
                        speed: 5, jumpPower: 15,
                        onGround: false, facing: 0,
                        expression: this.getRandomExpression(),
                        color: config.player1Color || config.leaderColor || '#6366f1',
                        baseDamage: 10,
                        multishot: 1,
                        rapidFireTime: 0,
                        damageReductionFactor: 1,
                        shieldBoostEndTime: 0,
                        healthRegenEndTime: 0,
                        lastRegenTick: 0,
                        magnetEndTime: 0,
                        magnetRadius: 200,
                        lastHitById: null,
                        type: 'player',
                        orbitingKnives: [],
                        piercingShot: 0,
                        explosiveShot: 0,
                        ricochetLevel: 0,
                        homingLevel: 0,
                        splitLevel: 0,
                        lifeStealPercent: 0,
                        critChance: 0,
                        critMultiplier: 1.5,
                        cooldownReduction: 0,
                        armor: 0,
                        timeStopEndTime: 0,
                        ammoRegenEndTime: 0,
                        lastAmmoRegenTick: 0,
                        ammoRegenAmount: 0,
                        dashCooldown: 0,
                        dashEndTime: 0,
                        isDashing: false,
                        reloadTime: 1500,
                        isReloading: false,
                        machineGunMode: false,
                        machineGunPenalty: false,
                        reloadPenalty: 0,
                        gunRecoil: 0,
                        gunRecoilTarget: 0,
                    },
                    player2: this.createPlayer2(config),
                    multiplayerMode: mode,
                    multiplayerConfig: config,
                    // 부활 시스템 초기화
                    player1Dead: false,
                    player2Dead: false,
                    lastDeathWave: 0,
                    revivalWaveCount: 0,
                    enemies: [],
                    projectiles: [],
                    items: [],
                    particles: [],
                    floatingTexts: [],
                    allies: [],
                    score: 0,
                    wave: 1,
                    gameStatus: 'playing',
                    message: '',
                    messageTimer: 0,
                    playerSlowedEndTime: 0,
                    timeSlowEndTime: 0,
                    timeSlowEffect: 1
                };
                
                // 보스 시스템 초기화
                this.bossSystem = {
                    isActive: false,
                    currentBoss: null,
                    spawnLock: false
                };
                
                // 게임 모드 설정
                this.gameMode = 'multiplayer';
                
                // 초기 웨이브 생성
                this.spawnInitialWave();
                
                // 게임 루프 시작
                this.gameLoop();
                this.updateHUD();
                this.hideMessage();
                
                // 퀘스트 초기화
                this.questSystem.activeQuests = [];
                for (let i = 0; i < 3; i++) {
                    this.questSystem.activeQuests.push(this.generateQuest());
                }
                this.updateQuestUI();
                
                this.currentWeapon = 'gun';
                this.upgrades = { gun: 0, melee: 0, health: 0, speed: 0, cooldown: 0 };
                
                // 멀티플레이 모드별 메시지 표시
                if (mode === 'leader') {
                    this.showMessage('리더 시스템 시작!', `${config.leaderName}이 ${config.followerName}을 이끕니다!`, 2000);
                } else if (mode === 'hybrid') {
                    const hybridPlayerName = config.hybridPlayer === 'player1' ? config.player1Name : config.player2Name;
                    this.showMessage('하이브리드 시스템 시작!', `${hybridPlayerName}이 자동 조준을 사용합니다!`, 2000);
                }
            };

            // 플레이어2 생성 메서드
            createPlayer2 = (config) => {
                const player2 = {
                    x: this.canvas.width / 2 + 50,
                    y: this.canvas.height / 2,
                    width: 40,
                    height: 40,
                    vx: 0,
                    vy: 0,
                    health: 150,
                    maxHealth: 150,
                    ammo: 30,
                    maxAmmo: 30,
                    speed: 5,
                    jumpPower: 15,
                    onGround: false,
                    facing: 0,
                    expression: this.getRandomExpression(),
                    color: config.player2Color || config.followerColor || '#ef4444',
                    baseDamage: 10,
                    multishot: 1,
                    rapidFireTime: 0,
                    damageReductionFactor: 1,
                    shieldBoostEndTime: 0,
                    healthRegenEndTime: 0,
                    lastRegenTick: 0,
                    magnetEndTime: 0,
                    magnetRadius: 200,
                    lastHitById: null,
                    type: 'player2',
                    orbitingKnives: [],
                    piercingShot: 0,
                    explosiveShot: 0,
                    ricochetLevel: 0,
                    homingLevel: 0,
                    splitLevel: 0,
                    lifeStealPercent: 0,
                    critChance: 0,
                    critMultiplier: 1.5,
                    cooldownReduction: 0,
                    armor: 0,
                    timeStopEndTime: 0,
                    ammoRegenEndTime: 0,
                    lastAmmoRegenTick: 0,
                    ammoRegenAmount: 0,
                    dashCooldown: 0,
                    dashEndTime: 0,
                    isDashing: false,
                    reloadTime: 1500,
                    isReloading: false,
                    machineGunMode: false,
                    machineGunPenalty: false,
                    reloadPenalty: 0,
                    gunRecoil: 0,
                    gunRecoilTarget: 0,
                    // 플레이어2 전용 속성들
                    keys: {}, // 플레이어2 키 입력
                    lastShot: 0, // 마지막 발사 시간
                    autoAimTarget: null, // 자동 조준 타겟
                    followTarget: null, // 따라갈 타겟 (리더 시스템용)
                };
                
                return player2;
            };

            // 플레이어2 발사 메서드
            shootPlayer2 = () => {
                const player2 = this.gameState.player2;
                if (!player2 || player2.ammo <= 0 || this.gameState.player2Dead) return;
                
                // 자동 재장전: 탄약이 없으면 자동으로 재장전
                if (player2.ammo <= 0 && !player2.isReloading) {
                    this.reloadPlayer2();
                    return;
                }
                
                if (player2.isReloading) return;
                
                const now = Date.now();
                if (now - player2.lastShot < 200) return; // 발사 속도 제한
                
                player2.lastShot = now;
                player2.ammo--;
                
                // 조준 방향 결정
                let angle = player2.facing;
                
                if (this.gameState.multiplayerMode === 'leader') {
                    // 리더 시스템: 플레이어1의 조준 방향을 따라감
                    angle = this.gameState.player.facing;
                } else if (this.gameState.multiplayerMode === 'hybrid') {
                    // 하이브리드 시스템: 자동 조준
                    const nearestEnemy = this.findNearestEnemy(player2);
                    if (nearestEnemy) {
                        angle = Math.atan2(nearestEnemy.y - player2.y, nearestEnemy.x - player2.x);
                    }
                }
                
                // 발사체 생성
                const projectile = {
                    id: Date.now() + Math.random(),
                    x: player2.x + Math.cos(angle) * 25,
                    y: player2.y + Math.sin(angle) * 25,
                    vx: Math.cos(angle) * 8,
                    vy: Math.sin(angle) * 8,
                    radius: 3,
                    damage: player2.baseDamage || 10,
                    life: 80,
                    color: player2.color || '#ff6b6b',
                    ownerId: 'player2',
                    pierceCount: player2.piercingShot || 0,
                    explosiveRadius: player2.explosiveShot || 0,
                    bounceCount: 0,
                    isHoming: player2.homingLevel > 0,
                    homingStrength: player2.homingLevel * 0.05 || 0,
                    splitCount: player2.splitLevel || 0,
                    hitEnemies: [],
                    isCritical: Math.random() < (player2.critChance || 0)
                };
                
                console.log('플레이어2 발사체 생성:', projectile);
                
                this.gameState.projectiles.push(projectile);
                
                // 다중 발사 처리
                if (player2.multishot > 1) {
                    for (let i = 1; i < player2.multishot; i++) {
                        const spreadAngle = angle + (i - (player2.multishot - 1) / 2) * 0.2;
                        const spreadProjectile = {
                            ...projectile,
                            id: Date.now() + Math.random(),
                            x: player2.x + Math.cos(spreadAngle) * 25,
                            y: player2.y + Math.sin(spreadAngle) * 25,
                            vx: Math.cos(spreadAngle) * 8,
                            vy: Math.sin(spreadAngle) * 8
                        };
                        this.gameState.projectiles.push(spreadProjectile);
                    }
                }
                
                // 분열 사격 처리
                if (player2.splitLevel > 0) {
                    for (let i = 0; i < player2.splitLevel; i++) {
                        const splitAngle = angle + (i + 1) * (Math.PI / (player2.splitLevel + 1));
                        const splitProjectile = {
                            ...projectile,
                            id: Date.now() + Math.random(),
                            x: player2.x + Math.cos(splitAngle) * 25,
                            y: player2.y + Math.sin(splitAngle) * 25,
                            vx: Math.cos(splitAngle) * 8,
                            vy: Math.sin(splitAngle) * 8
                        };
                        this.gameState.projectiles.push(splitProjectile);
                    }
                }
            };

            // 가장 가까운 적 찾기
            findNearestEnemy = (player) => {
                let nearestEnemy = null;
                let nearestDistance = Infinity;
                
                this.gameState.enemies.forEach(enemy => {
                    const distance = Math.sqrt((enemy.x - player.x) ** 2 + (enemy.y - player.y) ** 2);
                    if (distance < nearestDistance) {
                        nearestDistance = distance;
                        nearestEnemy = enemy;
                    }
                });
                
                return nearestEnemy;
            };

            // 플레이어2 재장전 메서드
            reloadPlayer2 = () => {
                const player2 = this.gameState.player2;
                if (!player2 || player2.isReloading || player2.ammo >= player2.maxAmmo) return;
                
                player2.isReloading = true;
                const reloadTime = player2.reloadTime + player2.reloadPenalty;
                
                setTimeout(() => {
                    if (player2) {
                        player2.ammo = player2.maxAmmo;
                        player2.isReloading = false;
                    }
                }, reloadTime);
            };

            // 플레이어 사망 처리 메서드
            handlePlayerDeath = (playerType) => {
                if (playerType === 'player1') {
                    this.gameState.player1Dead = true;
                    this.gameState.player.health = 0;
                    this.showMessage('플레이어1 사망!', '플레이어2가 5웨이브를 클리어하면 부활합니다!', 3000);
                } else if (playerType === 'player2') {
                    this.gameState.player2Dead = true;
                    this.gameState.player2.health = 0;
                    this.showMessage('플레이어2 사망!', '플레이어1이 5웨이브를 클리어하면 부활합니다!', 3000);
                }
                
                this.gameState.lastDeathWave = this.gameState.wave;
                
                // 두 플레이어 모두 죽었는지 확인
                if (this.gameState.player1Dead && this.gameState.player2Dead) {
                    this.gameOver();
                }
            };

            // 플레이어 부활 메서드
            revivePlayer = (playerType) => {
                if (playerType === 'player1') {
                    this.gameState.player1Dead = false;
                    this.gameState.player.health = this.gameState.player.maxHealth * 0.5; // 50% 체력으로 부활
                    this.gameState.player.ammo = this.gameState.player.maxAmmo;
                    this.showMessage('플레이어1 부활!', '50% 체력으로 부활했습니다!', 3000);
                } else if (playerType === 'player2') {
                    this.gameState.player2Dead = false;
                    this.gameState.player2.health = this.gameState.player2.maxHealth * 0.5; // 50% 체력으로 부활
                    this.gameState.player2.ammo = this.gameState.player2.maxAmmo;
                    this.gameState.player2.isReloading = false; // 재장전 상태 초기화
                    this.gameState.player2.gunRecoil = 0; // 반동 초기화
                    this.gameState.player2.gunRecoilTarget = 0; // 반동 타겟 초기화
                    this.showMessage('플레이어2 부활!', '50% 체력으로 부활했습니다!', 3000);
                }
                
                this.gameState.revivalWaveCount = 0; // 부활 카운트 리셋
            };

            // 게임 시작
            startGame = () => {
                this.canvas.style.filter = 'blur(0px)'; // 캔버스 블러 제거
                document.getElementById('startScreen').style.display = 'none'; // 시작 화면 숨김
                document.querySelector('.hud').style.display = 'flex'; // HUD 표시 (flex로 변경)
                document.getElementById('rewardSelectionScreen').style.display = 'none'; // 보상 화면 숨김

                // 게임 상태 초기화 (resetGame과 유사)
                this.gameState = {
                    player: {
                        x: this.canvas.width / 2, y: this.canvas.height / 2,
                        width: 40, height: 40,
                        vx: 0, vy: 0,
                        health: 150, maxHealth: 150, // 기본값 100으로 변경
                        ammo: 30, maxAmmo: 30, // 기본값 100으로 변경
                        speed: 5, jumpPower: 15,
                        onGround: false, facing: 0,
                        expression: this.getRandomExpression(),
                        color: '#6366f1',
                        baseDamage: 10, // 기본값 10으로 변경
                        multishot: 1,
                        rapidFireTime: 0,
                        damageReductionFactor: 1,
                        shieldBoostEndTime: 0,
                        healthRegenEndTime: 0,
                        lastRegenTick: 0,
                        magnetEndTime: 0,
                        magnetRadius: 200,
                        lastHitById: null, // 초기화
                        type: 'player', // 플레이어 타입
                        orbitingKnives: [], // 회전 칼날 초기화
                        piercingShot: 0, // 관통 사격 초기화
                        explosiveShot: 0, // 폭발 사격 초기화
                        ricochetLevel: 0, // 도탄 사격 초기화
                        homingLevel: 0, // 유도 사격 초기화
                        splitLevel: 0, // 분열 사격 초기화
                        lifeStealPercent: 0, // 생명력 흡수 초기화
                        critChance: 0, // 치명타 확률 초기화
                        critMultiplier: 1.5, // 치명타 배율 초기화
                        cooldownReduction: 0, // 재사용 대기시간 감소 초기화
                        armor: 0, // 방어력 초기화
                        timeStopEndTime: 0, // 시간 정지 초기화
                        ammoRegenEndTime: 0, // 탄약 재생 초기화
                        lastAmmoRegenTick: 0, // 마지막 탄약 재생 틱 초기화
                        ammoRegenAmount: 0, // 탄약 재생량 초기화
                        dashCooldown: 0, // 마지막 대시 시각
                        dashEndTime: 0, // 대시 종료 시각
                        isDashing: false, // 대시 중 여부
                        reloadTime: 1500, // 기본 재장전 시간(ms)
                        isReloading: false,
                        machineGunMode: false, // 기관단총 패시브
                        machineGunPenalty: false, // 기관단총 패널티
                        reloadPenalty: 0, // 패시브로 인한 추가 재장전 시간(ms)
                        gunRecoil: 0,
                        gunRecoilTarget: 0,
                    },
                    enemies: [],
                    projectiles: [],
                    items: [],
                    particles: [],
                    floatingTexts: [],
                    allies: [], // 아군 배열 초기화
                    score: 0,
                    wave: 1,
                    gameStatus: 'playing',
                    message: '',
                    messageTimer: 0,
                    playerSlowedEndTime: 0,
                    timeSlowEndTime: 0,
                    timeSlowEffect: 1
                };
                
                this.spawnInitialWave(); // 초기 웨이브 생성
                this.gameLoop(); // 게임 루프 시작
                this.updateHUD(); // HUD 초기 업데이트
                this.hideMessage(); // 메시지 숨기기

                // === startGame 함수 내부에 추가 ===
                this.currentWeapon = 'gun'; // 게임 시작 시 무기 초기화
                this.upgrades = { gun: 0, melee: 0, health: 0, speed: 0, cooldown: 0 };
                
                // 보스 시스템 초기화
                this.bossSystem = {
                    isActive: false,
                    currentBoss: null,
                    spawnLock: false
                };
                
                // 게임 모드 설정 (솔로 플레이)
                this.gameMode = 'solo';
            }
            
            // 무작위 표정 반환
            getRandomExpression = () => {
                if (this.EXPRESSIONS && this.EXPRESSIONS.length > 0) {
                    return this.EXPRESSIONS[Math.floor(Math.random() * this.EXPRESSIONS.length)];
                }
                return ':)'; // 표정 배열이 비어있는 경우를 위한 기본 표정
            }
            
            // 현재 웨이브에 따라 적 타입 결정 (보스 제거)
            getEnemyTypeForWave = (wave) => {
                // 일반 웨이브 적 생성 로직
                if (wave <= 2) {
                    return 'basic';
                } else if (wave <= 5) {
                    const rand = Math.random();
                    if (rand < 0.4) return 'basic';
                    else if (rand < 0.7) return 'fast';
                    else return 'jumper';
                } else if (wave <= 8) {
                    const rand = Math.random();
                    if (rand < 0.2) return 'basic';
                    else if (rand < 0.35) return 'fast';
                    else if (rand < 0.5) return 'tank';
                    else if (rand < 0.65) return 'assassin';
                    else if (rand < 0.75) return 'jumper';
                    else if (rand < 0.85) return 'teleporter';
                    else return 'drone';
                } else if (wave <= 12) {
                    const rand = Math.random();
                    if (rand < 0.1) return 'basic';
                    else if (rand < 0.18) return 'fast';
                    else if (rand < 0.26) return 'tank';
                    else if (rand < 0.34) return 'sniper';
                    else if (rand < 0.42) return 'assassin';
                    else if (rand < 0.50) return 'heavy';
                    else if (rand < 0.58) return 'bomber';
                    else if (rand < 0.66) return 'jumper';
                    else if (rand < 0.74) return 'teleporter';
                    else if (rand < 0.82) return 'drone';
                    else if (rand < 0.90) return 'spitter';
                    else return 'berserker';
                } else if (wave <= 15) {
                    const rand = Math.random();
                    if (rand < 0.05) return 'basic';
                    else if (rand < 0.10) return 'fast';
                    else if (rand < 0.15) return 'tank';
                    else if (rand < 0.20) return 'sniper';
                    else if (rand < 0.25) return 'assassin';
                    else if (rand < 0.30) return 'heavy';
                    else if (rand < 0.35) return 'bomber';
                    else if (rand < 0.40) return 'guardian';
                    else if (rand < 0.45) return 'ghost';
                    else if (rand < 0.50) return 'medic';
                    else if (rand < 0.55) return 'summoner';
                    else if (rand < 0.60) return 'jumper';
                    else if (rand < 0.65) return 'shielded';
                    else if (rand < 0.70) return 'teleporter';
                    else if (rand < 0.75) return 'drone';
                    else if (rand < 0.80) return 'spitter';
                    else if (rand < 0.85) return 'berserker';
                    else if (rand < 0.88) return 'mirror';
                    else if (rand < 0.90) return 'leech';
                    else if (rand < 0.92) return 'mine';
                    else if (rand < 0.94) return 'freezer';
                    else if (rand < 0.96) return 'reflector';
                    else if (rand < 0.98) return 'healer';
                    else if (rand < 0.99) return 'portal';
                    else return 'exploder';
                } else {
                    // 15웨이브 이상: 신규 적 확률 대폭 증가
                    const rand = Math.random();
                    if (rand < 0.03) return 'basic';
                    else if (rand < 0.06) return 'fast';
                    else if (rand < 0.09) return 'tank';
                    else if (rand < 0.12) return 'sniper';
                    else if (rand < 0.15) return 'assassin';
                    else if (rand < 0.18) return 'heavy';
                    else if (rand < 0.21) return 'bomber';
                    else if (rand < 0.24) return 'guardian';
                    else if (rand < 0.27) return 'ghost';
                    else if (rand < 0.30) return 'medic';
                    else if (rand < 0.33) return 'summoner';
                    else if (rand < 0.36) return 'jumper';
                    else if (rand < 0.39) return 'shielded';
                    else if (rand < 0.42) return 'teleporter';
                    else if (rand < 0.45) return 'drone';
                    else if (rand < 0.48) return 'spitter';
                    else if (rand < 0.51) return 'berserker';
                    else if (rand < 0.58) return 'mirror';
                    else if (rand < 0.63) return 'leech';
                    else if (rand < 0.68) return 'mine';
                    else if (rand < 0.73) return 'freezer';
                    else if (rand < 0.78) return 'reflector';
                    else if (rand < 0.83) return 'healer';
                    else if (rand < 0.88) return 'portal';
                    else if (rand < 0.93) return 'exploder';
                    else if (rand < 0.96) return 'magnet';
                    else return 'curse';
                }
            }
            
            // 보스 생성 함수
            createBoss = (bossType) => {
                const x = this.canvas.width / 2;
                const y = this.canvas.height / 2 - 100; // 화면 중앙에서 약간 위쪽에 생성
                let bossData = { ...this.ENEMY_TYPES[bossType] };
                
                // 보스 스케일링: 웨이브가 오를수록 강해짐
                const scale = 1 + (this.gameState.wave / 10);
                bossData.health = Math.floor(bossData.health * scale);
                bossData.maxHealth = bossData.health;
                bossData.speed = bossData.speed * (1 + (this.gameState.wave / 20));
                bossData.damage = Math.floor(bossData.damage * scale);
                bossData.points = Math.floor(bossData.points * scale);
                
                // 보스 스킬 쿨타임 초기화
                bossData.lastMissile = 0;
                bossData.lastTeleport = 0;
                bossData.lastExplosion = 0;
                bossData.lastSummon = 0;
                bossData.lastShield = 0;
                bossData.lastBlackhole = 0;
                bossData.isInvincible = false;
                bossData.invincibleEndTime = 0;
                
                return {
                    id: Date.now() + Math.random(),
                    type: bossType,
                    x: x, y: y,
                    width: bossData.size, height: bossData.size,
                    vx: 0, vy: 0,
                    health: bossData.health, maxHealth: bossData.health,
                    ammo: 20, maxAmmo: 20,
                    speed: bossData.speed,
                    damage: bossData.damage,
                    jumpPower: 10,
                    onGround: false,
                    facing: 0,
                    expression: this.getRandomExpression(),
                    color: bossData.color,
                    lastShot: 0,
                    shootInterval: bossData.shootInterval,
                    points: bossData.points,
                    // 보스 전용 속성
                    lastMissile: 0,
                    lastTeleport: 0,
                    lastExplosion: 0,
                    lastSummon: 0,
                    lastShield: 0,
                    lastBlackhole: 0,
                    isInvincible: false,
                    invincibleEndTime: 0,
                    shieldDuration: bossData.shieldDuration || 0,
                    summonCount: bossData.summonCount || 0,
                    summonType: bossData.summonType || 'basic',
                    healAmount: bossData.healAmount || 0,
                    healCooldown: bossData.healCooldown || 0,
                    lastHeal: 0,
                    barrageCooldown: bossData.barrageCooldown || 0,
                    lastBarrage: 0,
                    dashCooldown: bossData.dashCooldown || 0,
                    lastDash: 0,
                    dashCount: bossData.dashCount || 0,
                    dashDuration: bossData.dashDuration || 0,
                    isDashing: false,
                    shockwaveCooldown: bossData.shockwaveCooldown || 0,
                    lastShockwave: 0,
                    laserCooldown: bossData.laserCooldown || 0,
                    lastLaser: 0,
                    laserDuration: bossData.laserDuration || 0,
                    speedBuffCooldown: bossData.speedBuffCooldown || 0,
                    lastSpeedBuff: 0,
                    speedBuffDuration: bossData.speedBuffDuration || 0,
                    isSpeedBuffed: false,
                    blackholeRadius: bossData.blackholeRadius || 0,
                    slowCooldown: bossData.slowCooldown || 0,
                    lastSlow: 0,
                    slowDuration: bossData.slowDuration || 0,
                    cloneCooldown: bossData.cloneCooldown || 0,
                    lastClone: 0,
                    clones: bossData.clones || 0,
                    hasCloned: false,
                    reflectCooldown: bossData.reflectCooldown || 0,
                    lastReflect: 0,
                    reflectDuration: bossData.reflectDuration || 0,
                    isReflecting: false,
                    drainCooldown: bossData.drainCooldown || 0,
                    lastDrain: 0,
                    drainAmount: bossData.drainAmount || 0,
                    timeWarpCooldown: bossData.timeWarpCooldown || 0,
                    lastTimeWarp: 0,
                    timeWarpDuration: bossData.timeWarpDuration || 0,
                    isTimeWarp: false,
                    rapidFireCooldown: bossData.rapidFireCooldown || 0,
                    lastRapidFire: 0,
                    rapidFireDuration: bossData.rapidFireDuration || 0,
                    isRapidFire: false,
                    randomMoveCooldown: bossData.randomMoveCooldown || 0,
                    lastRandomMove: 0,
                    jumpCount: bossData.jumpCount || 0,
                    jumpPower: bossData.jumpPower || 0,
                    armorBuffCooldown: bossData.armorBuffCooldown || 0,
                    lastArmorBuff: 0,
                    armorBuffDuration: bossData.armorBuffDuration || 0,
                    isArmorBuffed: false,
                    reflectAllCooldown: bossData.reflectAllCooldown || 0,
                    lastReflectAll: 0,
                    reflectAllDuration: bossData.reflectAllDuration || 0,
                    ricochetCooldown: bossData.ricochetCooldown || 0,
                    lastRicochet: 0,
                    ricochetCount: bossData.ricochetCount || 0,
                    trackCooldown: bossData.trackCooldown || 0,
                    lastTrack: 0,
                    trackDuration: bossData.trackDuration || 0,
                    isTracking: false
                };
            }
            
            // 적 객체 생성 (보스 제거)
            createEnemy = (enemyType = null) => {
                const side = Math.random() < 0.5 ? 'left' : 'right';
                const x = side === 'left' ? -50 : this.canvas.width + 50;
                const y = Math.random() * (this.canvas.height - 200);
                let type = enemyType || this.getEnemyTypeForWave(this.gameState.wave);
                let enemyData = { ...this.ENEMY_TYPES[type] };
                
                // 스케일링: 웨이브가 오를수록 체력/공격력/속도 증가
                const scale = 1 + (this.gameState.wave - 1) * 0.12; // 20% 완화
                enemyData.health = Math.floor(enemyData.health * scale * 0.8);
                enemyData.maxHealth = enemyData.health;
                enemyData.speed = enemyData.speed * (1 + (this.gameState.wave - 1) * 0.04); // 20% 완화
                enemyData.damage = Math.floor(enemyData.damage * scale * 0.8);
                enemyData.points = Math.floor(enemyData.points * scale);
                
                // 신규 적 등장 메시지
                const newTypes = [
                    'mirror','leech','mine','freezer','reflector','healer','portal','exploder','magnet','curse'
                ];
                if (newTypes.includes(type)) {
                    this.showMessage(`${this.ENEMY_TYPES[type].name} 등장!`, '새로운 위협이 나타났습니다!', 3000);
                }

                // 적 객체 반환
                return {
                    id: Date.now() + Math.random(), // 고유 ID
                    type: type, // 적 타입
                    x: x, y: y, // 위치
                    width: enemyData.size, height: enemyData.size, // 크기
                    vx: 0, vy: 0, // 속도
                    health: enemyData.health, maxHealth: enemyData.health, // 체력 (maxHealth도 동일하게 설정)
                    ammo: 20, maxAmmo: 20, // 탄약 (적은 고정값)
                    speed: enemyData.speed, // 이동 속도
                    damage: enemyData.damage, // 공격력
                    jumpPower: 10, // 점프력 (적은 고정값)
                    onGround: false, // 지면 접촉 여부
                    facing: 0, // 바라보는 방향
                    expression: this.getRandomExpression(), // 표정
                    color: enemyData.color, // 색상
                    lastShot: 0, // 마지막 발사 시간
                    shootInterval: enemyData.shootInterval, // 발사 간격
                    points: enemyData.points, // 처치 시 획득 점수
                    // 새로운 적 전용 속성 초기화
                    isInvincible: enemyData.isInvincible || false,
                    invincibilityDuration: enemyData.invincibilityDuration || 0,
                    invincibleEndTime: 0,
                    healAmount: enemyData.healAmount || 0,
                    healRadius: enemyData.healRadius || 0,
                    summonCooldown: enemyData.summonCooldown || 0, // 알파 보스
                    lastSummon: enemyData.lastSummon || 0, // 알파 보스
                    summonCount: enemyData.summonCount || 0, // 알파 보스
                    summonType: enemyData.summonType || 'basic', // 알파 보스
                    shieldCooldown: enemyData.shieldCooldown || 0, // 베타 보스
                    lastShield: enemyData.lastShield || 0, // 베타 보스
                    shieldDuration: enemyData.shieldDuration || 0, // 베타 보스
                    burstProjectiles: enemyData.burstProjectiles || 0, // 베타 보스
                    burstDamage: enemyData.burstDamage || 0, // 베타 보스
                    teleportStrikeCooldown: enemyData.teleportStrikeCooldown || 0, // 감마 보스
                    lastTeleportStrike: enemyData.lastTeleportStrike || 0, // 감마 보스
                    teleportRange: enemyData.teleportRange || 0, // 감마 보스
                    jumpCooldown: enemyData.jumpCooldown || 0,
                    lastJump: enemyData.lastJump || 0,
                    flies: enemyData.flies || false, // 드론
                    slowEffect: enemyData.slowEffect || 0, // 침뱉는병
                    slowDuration: enemyData.slowDuration || 0,
                    rageThreshold: enemyData.rageThreshold || 0, // 광전사
                    rageSpeedBoost: enemyData.rageSpeedBoost || 1,
                    rageDamageBoost: enemyData.rageDamageBoost || 1,
                    isRaging: false, // 광전사 상태
                    // 새로운 적 10종 스킬 쿨다운 초기화
                    lastTimeReverse: 0, // 타임키퍼
                    lastTimeAccel: 0, // 타임키퍼
                    lastGravity: 0, // 그래비티
                    lastAntiGravity: 0, // 그래비티
                    lastEcho: 0, // 에코
                    lastSonicWave: 0, // 에코
                    lastVortex: 0, // 보르텍스
                    lastWhirlwind: 0, // 보르텍스
                    lastPrism: 0, // 프리즘
                    lastLaser: 0, // 프리즘
                    lastQuantum: 0, // 퀀텀
                    lastQuantumSplit: 0, // 퀀텀
                    lastCrystal: 0, // 크리스탈
                    lastCrystalShard: 0, // 크리스탈
                    lastPlasma: 0, // 플라즈마
                    lastPlasmaExplosion: 0, // 플라즈마
                    lastNebula: 0, // 네뷸라
                    lastStarExplosion: 0 // 네뷸라
                };
            }

            // 아군 드론 생성
            spawnAlly = (x, y) => {
                this.gameState.allies.push({
                    id: Date.now() + Math.random(),
                    type: 'ally',
                    x: x, y: y,
                    width: 25, height: 25,
                    vx: 0, vy: 0,
                    health: 70, maxHealth: 70,
                    speed: 5,
                    damage: 10, // 25 -> 10
                    color: '#90ee90',
                    lastShot: 0,
                    shootInterval: 600,
                    onGround: false,
                    facing: 0,
                    expression: this.getRandomExpression(),
                    flies: true
                });
            }
            
            // 아이템 객체 생성
            createItem = (x, y) => {
                const itemType = this.ITEM_TYPES[Math.floor(Math.random() * this.ITEM_TYPES.length)]; // 무작위 아이템 타입 선택
                return {
                    id: Date.now() + Math.random(), // 고유 ID
                    x: x, y: y, // 위치
                    width: 20, height: 20, // 크기
                    vx: (Math.random() - 0.5) * 4, // 수평 초기 속도 (무작위)
                    vy: -Math.random() * 8 - 5, // 위로 튀어나오는 초기 속도 (무작위)
                    onGround: false, // 지면 접촉 여부
                    type: itemType.type, // 아이템 타입
                    effect: itemType.effect, // 아이템 효과량
                    color: itemType.color, // 아이템 색상
                    emoji: itemType.emoji, // 아이템 이모지
                    bobOffset: Math.random() * Math.PI * 2, // 떠다니는 애니메이션 오프셋
                    collected: false, // 수집 여부
                    duration: itemType.duration || 0, // 아이템 지속 시간 (새로운 아이템용)
                    tickInterval: itemType.tickInterval || 0 // 체력 재생 등 주기적 효과용
                };
            }
            
            // 플레이어 발사 로직
            shoot = () => {
                const player = this.gameState.player;
                if (player.isReloading || this.gameState.player1Dead) return;
                if (this.currentWeapon === 'gun') {
                    if (player.ammo <= 0) {
                        this.reload();
                        return;
                    }
                    const now = Date.now();
                    let shootInterval = 200;
                    if (player.machineGunMode) shootInterval = 60;
                    if (player.rapidFireTime && now < player.rapidFireTime) shootInterval = 100;
                    shootInterval *= (1 - player.cooldownReduction);
                    if (player.lastShot && now - player.lastShot < shootInterval) return;
                    const startX = player.x + player.width / 2;
                    const startY = player.y + player.height / 2;
                    const angle = Math.atan2(this.mouse.y - startY, this.mouse.x - startX);
                    let speed = player.machineGunMode ? 16 : 12;
                    let damage = player.baseDamage;
                    let isCritical = false;
                    if (Math.random() < player.critChance) {
                        damage *= player.critMultiplier;
                        isCritical = true;
                    }
                    if (player.machineGunMode) damage *= 0.5;
                    if (player.machineGunPenalty) damage *= 0.5;
                    if (player.homingLevel >= 3 && player.homingPenalty) damage *= 0.95;
                    const multishot = player.multishot;
                    const actualMultishot = Math.min(multishot, 4);
                    for (let i = 0; i < actualMultishot; i++) {
                        const spreadAngle = angle + (i - (actualMultishot - 1) / 2) * 0.2;
                        let baseLife = 120;
                        let ricochetBonus = player.ricochetLevel ? player.ricochetLevel * 30 : 0;
                        let projectileLife = baseLife + ricochetBonus;
                        this.gameState.projectiles.push({
                            id: Date.now() + Math.random() + i,
                            x: startX, y: startY,
                            vx: Math.cos(spreadAngle) * speed,
                            vy: Math.sin(spreadAngle) * speed,
                            radius: player.machineGunMode ? 2 : 3,
                            damage: damage,
                            life: projectileLife,
                            color: player.machineGunMode ? '#aaa' : (player.rapidFireTime && now < player.rapidFireTime ? '#ff6b00' : '#fbbf24'),
                            ownerId: 'player',
                            pierceCount: player.piercingShot,
                            explosiveRadius: player.explosiveShot > 0 ? (80 + player.explosiveShot * 20) : 0,
                            bounceCount: player.ricochetLevel,
                            isHoming: player.homingLevel > 0,
                            homingStrength: player.homingLevel > 0 ? (0.05 + player.homingLevel * 0.01) : 0,
                            splitCount: player.splitLevel,
                            isCritical: isCritical,
                            hitEnemies: []
                        });
                    }
                    // 기관단총 패널티: 4발당 탄약 1 소모
                    if (player.machineGunMode) {
                        player.ammo -= 0.25;
                        if (player.ammo < 0) player.ammo = 0;
                    } else {
                        player.ammo--;
                    }
                    // 총 반동 효과 추가
                    player.gunRecoilTarget = 15; // 반동 목표값 설정
                    
                    player.lastShot = now;
                    this.updateHUD();
                } else if (this.currentWeapon === 'melee') {
                    const range = 70;
                    const damage = player.baseDamage * 4;
                    let hit = false;
                    this.gameState.enemies.forEach(enemy => {
                        const dx = (enemy.x + enemy.width/2) - (player.x + player.width/2);
                        const dy = (enemy.y + enemy.height/2) - (player.y + player.height/2);
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < range) {
                            enemy.health = Math.max(0, enemy.health - damage);
                            this.createFloatingText(enemy.x + enemy.width/2, enemy.y, `-${damage}`, 'orange');
                            this.createHitParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                            if (enemy.health <= 0) {
                                this.addScore(enemy.points || 100);
                                if (Math.random() < 0.4) this.gameState.items.push(this.createItem(enemy.x, enemy.y));
                                
                                // 보스가 죽으면 시스템 리셋
                                if (enemy.type && enemy.type.startsWith('boss')) {
                                    if (this.bossSystem && this.bossSystem.currentBoss && this.bossSystem.currentBoss.id === enemy.id) {
                                        this.bossSystem.currentBoss = null;
                                    }
                                    this.checkBossWaveComplete(); // ← 먼저 호출
                                    this.resetBossSystem();
                                }
                                
                                this.gameState.enemies = this.gameState.enemies.filter(e => e !== enemy);
                            }
                            hit = true;
                        }
                    });
                    if (hit) this.showMessage('칼 공격!', '', 600);
                }
            }

            tryDash = () => {
                const player = this.gameState.player;
                const now = Date.now();
                // 쿨타임 1초 (1000ms)
                if (player.isDashing) return;
                if (now - player.dashCooldown < 1000) return;

                player.isDashing = true;
                player.dashCooldown = now;

                // 대시 방향: 바라보는 방향(facing)으로 빠르게 이동
                const dashPower = 25;
                player.vx += Math.cos(player.facing) * dashPower;
                player.vy += Math.sin(player.facing) * dashPower;

                // 0.2초 후 무적 해제
                setTimeout(() => {
                    player.isDashing = false;
                }, 200);
            };

            // 퀘스트 생성
            generateQuest = () => {
                const questType = this.questSystem.questTypes[Math.floor(Math.random() * this.questSystem.questTypes.length)];
                let target = 0;
                
                switch (questType.type) {
                    case 'wave':
                        target = this.gameState.wave + Math.floor(Math.random() * 5) + 3; // 현재 웨이브 + 3~7
                        break;
                    case 'score':
                        target = this.gameState.score + Math.floor(Math.random() * 2000) + 1000; // 현재 점수 + 1000~3000
                        break;
                    case 'boss_kill':
                        target = Math.floor(Math.random() * 3) + 1; // 1~3마리
                        break;
                    case 'enemy_kill':
                        target = Math.floor(Math.random() * 20) + 10; // 10~30마리
                        break;
                    case 'item_collect':
                        target = Math.floor(Math.random() * 10) + 5; // 5~15개
                        break;
                }
                
                return {
                    id: Date.now() + Math.random(),
                    type: questType.type,
                    name: questType.name,
                    description: questType.description.replace('{target}', target),
                    target: target,
                    current: 0,
                    rewards: questType.rewards,
                    completed: false
                };
            };

            // 퀘스트 진행도 업데이트
            updateQuestProgress = (type, amount = 1) => {
                this.questSystem.activeQuests.forEach(quest => {
                    if (quest.type === type && !quest.completed) {
                        quest.current += amount;
                        if (quest.current >= quest.target) {
                            this.completeQuest(quest);
                        }
                    }
                });
            };

            // 퀘스트 완료
            completeQuest = (quest) => {
                quest.completed = true;
                quest.current = quest.target;
                
                // 보상 지급
                if (quest.rewards.score) {
                    this.gameState.score += quest.rewards.score;
                }
                if (quest.rewards.health) {
                    this.gameState.player.health = Math.min(this.gameState.player.maxHealth, this.gameState.player.health + quest.rewards.health);
                }
                if (quest.rewards.ammo) {
                    this.gameState.player.ammo = Math.min(this.gameState.player.maxAmmo, this.gameState.player.ammo + quest.rewards.ammo);
                }
                
                // 완료된 퀘스트 이동
                this.questSystem.completedQuests.push(quest);
                this.questSystem.activeQuests = this.questSystem.activeQuests.filter(q => q.id !== quest.id);
                
                // 완료 메시지 표시
                this.showMessage(`퀘스트 완료!`, `${quest.name}: ${quest.rewards.score}점 획득!`, 3000);
                
                // 새로운 퀘스트 생성
                if (this.questSystem.activeQuests.length < 3) {
                    this.questSystem.activeQuests.push(this.generateQuest());
                }
                
                this.updateQuestUI();
            };

            // 퀘스트 UI 업데이트
            updateQuestUI = () => {
                const questList = document.getElementById('questList');
                if (!questList) return;
                
                let questHTML = '';
                this.questSystem.activeQuests.forEach(quest => {
                    const progress = Math.min(100, (quest.current / quest.target) * 100);
                    const status = quest.completed ? '✅' : '⏳';
                    questHTML += `
                        <div style="margin-bottom: 10px; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 5px;">
                            <div style="font-weight: bold; color: ${quest.completed ? '#4ade80' : '#fbbf24'};">${status} ${quest.name}</div>
                            <div style="font-size: 12px; margin: 5px 0;">${quest.description}</div>
                            <div style="font-size: 11px; color: #a1a1aa;">진행도: ${quest.current}/${quest.target} (${progress.toFixed(1)}%)</div>
                            <div style="width: 100%; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; margin-top: 5px;">
                                <div style="width: ${progress}%; height: 100%; background: ${quest.completed ? '#4ade80' : '#fbbf24'}; border-radius: 2px; transition: width 0.3s;"></div>
                            </div>
                        </div>
                    `;
                });
                
                if (this.questSystem.activeQuests.length === 0) {
                    questHTML = '<div style="color: #a1a1aa; text-align: center; padding: 20px;">활성 퀘스트가 없습니다</div>';
                }
                
                questList.innerHTML = questHTML;
            };

            reload = () => {
                const player = this.gameState.player;
                if (player.isReloading) return;
                if (player.ammo >= player.maxAmmo) return; // 이미 가득 찬 경우 재장전 안함
                
                player.isReloading = true;
                player.gunRecoilTarget = 18;
                let reloadTime = player.reloadTime + player.reloadPenalty;
                this.showMessage('재장전 중...', '', reloadTime);
                
                // 재장전 중에는 발사 불가
                setTimeout(() => {
                    player.ammo = player.maxAmmo;
                    player.isReloading = false;
                    player.gunRecoilTarget = 0;
                    this.updateHUD();
                    this.showMessage('재장전 완료!', '', 1000);
                }, reloadTime);
            }
            
            // 수류탄 투척 로직
            throwGrenade = () => {
                const player = this.gameState.player;
                const now = Date.now();
                // 수류탄 쿨타임 (예시: 2초)
                if (player.lastGrenade && now - player.lastGrenade < 2000) return;

                const startX = player.x + player.width / 2;
                const startY = player.y + player.height / 2;
                const angle = Math.atan2(this.mouse.y - startY, this.mouse.x - startX);
                const speed = 10; // 수류탄 투척 속도
                const grenadeLife = 60; // 수류탄 수명 (프레임)
                const explosionDelay = 40; // 폭발까지의 딜레이 (프레임)

                this.gameState.projectiles.push({
                    id: Date.now() + Math.random(),
                    x: startX, y: startY,
                    vx: (Math.cos(angle) * speed) * this.gameState.timeSlowEffect, // 시간 둔화 영향 받음
                    vy: (Math.sin(angle) * speed) * this.gameState.timeSlowEffect, // 시간 둔화 영향 받음
                    radius: 8, // 수류탄 크기
                    damage: 0, // 직접 데미지 없음 (폭발 데미지)
                    life: grenadeLife,
                    color: '#6b7280',
                    ownerId: 'player',
                    isGrenade: true, // 수류탄임을 나타내는 플래그
                    explosionRadius: 150, // 폭발 범위
                    explosionDamage: 70, // 폭발 데미지
                    explosionDelay: explosionDelay // 폭발 딜레이
                });
                player.lastGrenade = now;
            }
            
            // 웨이브 생성 (새로운 보스 시스템)
            spawnInitialWave = () => {
                if (typeof bossRushMode !== 'undefined' && bossRushMode) {
                    const bossTypes = [
                        'boss_alpha','boss_beta','boss_gamma','boss_delta','boss_epsilon','boss_zeta','boss_eta','boss_theta'
                    ];
                    const bossType = bossTypes[Math.floor(Math.random() * bossTypes.length)];
                    const bossData = this.ENEMY_TYPES[bossType];
                    this.showMessage(`${bossData.name} 등장!`, '보스 러시!', 2000);
                    this.gameState.enemies.push(this.createEnemy(bossType));
                    return;
                }

                if (typeof bossRushMode !== 'undefined' && bossRushMode) {
                    // 보스 러시 모드: 매 웨이브마다 보스만 등장
                    const bossTypes = [
                        'boss_alpha','boss_beta','boss_gamma','boss_delta','boss_epsilon','boss_zeta','boss_eta','boss_theta'
                    ];
                    const bossType = bossTypes[Math.floor(Math.random() * bossTypes.length)];
                    const bossData = this.ENEMY_TYPES[bossType];
                    this.showMessage(`${bossData.name} 등장!`, '보스 러시!', 2000);
                    this.gameState.enemies.push(this.createEnemy(bossType));
                    return;
                }
                if (this.gameState.gameStatus !== 'spawning') return;
                
                // 테스팅 존에서는 자동 소환 안함
                if (this.gameMode === 'testzone') return;
                
                // 보스 웨이브 체크 (10의 배수)
                if (this.gameState.wave % 10 === 0) {
                    this.spawnBossWave();
                } else {
                    this.spawnNormalWave();
                }
            }
            
            // 보스 웨이브 생성
            spawnBossWave = () => {
                // 이미 보스가 활성화되어 있으면 스킵
                if (!this.bossSystem || this.bossSystem.isActive || this.bossSystem.spawnLock) {
                    return;
                }
                
                // 보스 스폰 락 설정
                this.bossSystem.spawnLock = true;
                this.bossSystem.isActive = true;
                
                // 보스 타입 선택
                const bossTypes = ['boss_alpha', 'boss_beta', 'boss_gamma', 'boss_delta', 'boss_epsilon', 'boss_zeta', 'boss_eta', 'boss_theta'];
                const bossType = bossTypes[Math.floor(Math.random() * bossTypes.length)];
                
                // 보스 생성
                const boss = this.createBoss(bossType);
                this.bossSystem.currentBoss = boss;
                this.gameState.enemies.push(boss);
                
                // 보스 등장 메시지
                const bossData = this.ENEMY_TYPES[bossType];
                this.showMessage(`${bossData.name} 등장!`, '강력한 보스가 나타났습니다!', 2000);
                
                console.log(`보스 웨이브 ${this.gameState.wave} 시작: ${bossData.name}`);
                console.log(`보스 생성됨: ${bossData.name}, 위치: (${boss.x}, ${boss.y}), 체력: ${boss.health}`);
                console.log(`현재 적 수: ${this.gameState.enemies.length}`);
            }
            
            // 일반 웨이브 생성
            spawnNormalWave = () => {
                // 적 수 결정 (더 많이 스폰)
                let enemyCount;
                if (this.gameState.wave === 1) {
                    enemyCount = 5;
                } else if (this.gameState.wave === 2) {
                    enemyCount = 7;
                } else if (this.gameState.wave === 3) {
                    enemyCount = 9;
                } else if (this.gameState.wave <= 10) {
                    enemyCount = Math.min(12, 9 + (this.gameState.wave - 3));
                } else if (this.gameState.wave <= 15) {
                    enemyCount = Math.min(15, 12 + (this.gameState.wave - 10));
                } else {
                    enemyCount = Math.min(18, 15 + (this.gameState.wave - 15));
                }
                
                // 적 생성
                for (let i = 0; i < enemyCount; i++) {
                    setTimeout(() => {
                        let type = undefined;
                        if (this.gameState.wave >= 2 && Math.random() < 0.2) type = 'fast';
                        if (this.gameState.wave >= 3 && Math.random() < 0.15) type = 'tank';
                        if (this.gameState.wave >= 4 && Math.random() < 0.1) type = 'sniper';
                        if (this.gameState.wave >= 5 && Math.random() < 0.1) type = 'bomber';
                        if (this.gameState.wave >= 6 && Math.random() < 0.08) type = 'guardian';
                        if (this.gameState.wave >= 7 && Math.random() < 0.08) type = 'assassin';
                        if (this.gameState.wave >= 8 && Math.random() < 0.08) type = 'heavy';
                        if (this.gameState.wave >= 9 && Math.random() < 0.06) type = 'ghost';
                        if (this.gameState.wave >= 10 && Math.random() < 0.06) type = 'medic';
                        if (this.gameState.wave >= 11 && Math.random() < 0.06) type = 'summoner';
                        if (this.gameState.wave >= 12 && Math.random() < 0.06) type = 'jumper';
                        if (this.gameState.wave >= 13 && Math.random() < 0.06) type = 'shielded';
                        if (this.gameState.wave >= 14 && Math.random() < 0.06) type = 'teleporter';
                        if (this.gameState.wave >= 15 && Math.random() < 0.06) type = 'drone';
                        if (this.gameState.wave >= 15 && Math.random() < 0.06) type = 'spitter';
                        if (this.gameState.wave >= 15 && Math.random() < 0.06) type = 'berserker';
                        if (this.gameState.wave >= 15 && Math.random() < 0.05) type = 'leech';
                        if (this.gameState.wave >= 15 && Math.random() < 0.05) type = 'mine';
                        if (this.gameState.wave >= 15 && Math.random() < 0.05) type = 'freezer';
                        if (this.gameState.wave >= 15 && Math.random() < 0.05) type = 'reflector';
                        if (this.gameState.wave >= 16 && Math.random() < 0.05) type = 'healer';
                        if (this.gameState.wave >= 16 && Math.random() < 0.05) type = 'portal';
                        if (this.gameState.wave >= 16 && Math.random() < 0.05) type = 'exploder';
                        if (this.gameState.wave >= 16 && Math.random() < 0.05) type = 'magnet';
                        if (this.gameState.wave >= 20 && Math.random() < 0.05) type = 'curse';
                        if (this.gameState.wave >= 20 && Math.random() < 0.05) type = 'floater';
                        if (this.gameState.wave >= 16 && Math.random() < 0.05) type = 'phaser';
                        if (this.gameState.wave >= 16 && Math.random() < 0.04) type = 'ninja';
                        if (this.gameState.wave >= 17 && Math.random() < 0.04) type = 'sniper';
                        if (this.gameState.wave >= 18 && Math.random() < 0.04) type = 'berserker';
                        if (this.gameState.wave >= 19 && Math.random() < 0.04) type = 'summoner';
                        if (this.gameState.wave >= 20 && Math.random() < 0.04) type = 'guardian';
                        if (this.gameState.wave >= 16 && Math.random() < 0.04) type = 'assassin';
                        if (this.gameState.wave >= 17 && Math.random() < 0.04) type = 'heavy';
                        if (this.gameState.wave >= 18 && Math.random() < 0.04) type = 'bomber';
                        if (this.gameState.wave >= 19 && Math.random() < 0.04) type = 'medic';
                        if (this.gameState.wave >= 20 && Math.random() < 0.04) type = 'drone';
                        if (this.gameState.wave >= 16 && Math.random() < 0.03) type = 'timekeeper';
                        if (this.gameState.wave >= 17 && Math.random() < 0.03) type = 'gravity';
                        if (this.gameState.wave >= 18 && Math.random() < 0.03) type = 'echo';
                        if (this.gameState.wave >= 19 && Math.random() < 0.03) type = 'vortex';
                        if (this.gameState.wave >= 20 && Math.random() < 0.03) type = 'prism';
                        if (this.gameState.wave >= 16 && Math.random() < 0.03) type = 'quantum';
                        if (this.gameState.wave >= 17 && Math.random() < 0.03) type = 'crystal';
                        if (this.gameState.wave >= 18 && Math.random() < 0.03) type = 'plasma';
                        if (this.gameState.wave >= 19 && Math.random() < 0.03) type = 'nebula';
                        this.gameState.enemies.push(this.createEnemy(type));
                    }, i * 500);
                }
                
                // 아이템 생성
                const totalItemCount = Math.min(6, Math.floor(this.gameState.wave / 2) + 3);
                let ammoItemCount = 0;
                if (this.gameState.wave >= 3) {
                    ammoItemCount = 1;
                }
                
                for (let i = 0; i < totalItemCount; i++) {
                    setTimeout(() => {
                        let itemToCreate;
                        if (Math.random() < 0.06) { 
                            itemToCreate = this.ITEM_TYPES.find(item => item.type === 'ally_summon');
                        } else if (ammoItemCount > 0 && Math.random() < 0.5) {
                            itemToCreate = this.ITEM_TYPES.find(item => item.type === 'ammo');
                            ammoItemCount--;
                        } else if (Math.random() < 0.15) {
                            itemToCreate = this.ITEM_TYPES.find(item => item.type === 'multishot');
                        } else if (Math.random() < 0.1) {
                            itemToCreate = this.ITEM_TYPES.find(item => item.type === 'health');
                        } else {
                            const nonSpecialItems = this.ITEM_TYPES.filter(item => item.type !== 'ammo' && item.type !== 'ally_summon' && item.type !== 'multishot' && item.type !== 'health');
                            itemToCreate = nonSpecialItems[Math.floor(Math.random() * nonSpecialItems.length)];
                        }
                        
                        const item = this.createItem(
                            Math.random() * (this.canvas.width - 40) + 20,
                            Math.random() * (this.canvas.height - 200) + 50
                        );
                        
                        item.type = itemToCreate.type;
                        item.effect = itemToCreate.effect;
                        item.color = itemToCreate.color;
                        item.emoji = itemToCreate.emoji;
                        item.duration = itemToCreate.duration || 0;
                        item.tickInterval = itemToCreate.tickInterval || 0;
                        
                        this.gameState.items.push(item);
                    }, i * 3000);
                }
                
                console.log(`일반 웨이브 ${this.gameState.wave} 시작: ${enemyCount}마리`);
            }
            
            // 캐릭터 (플레이어 및 적) 상태 업데이트 (새로운 적 AI 로직 추가)
            updateCharacter = (character) => {
                const now = Date.now();
                // player 변수를 함수 시작 부분에서 정의하여 모든 조건문에서 접근 가능하도록 함
                const player = this.gameState.player; 

                // 플레이어 둔화 효과 해제
                if (character === player) { // character === this.gameState.player 대신 player 사용
                    if (now > this.gameState.playerSlowedEndTime) {
                        character.speed = 5; // 기본 속도로 복귀
                    }
                    // 체력 재생 효과
                    if (now < character.healthRegenEndTime && now - character.lastRegenTick > character.tickInterval) {
                        character.health = Math.min(character.maxHealth, character.health + character.effect);
                        this.createFloatingText(character.x + character.width / 2, character.y, `+${character.effect}`, 'lime');
                        character.lastRegenTick = now;
                    }
                    // 탄약 재생 효과
                    if (now < character.ammoRegenEndTime && now - character.lastAmmoRegenTick > character.tickInterval) {
                        character.ammo = Math.min(character.maxAmmo, character.ammo + character.ammoRegenAmount);
                        this.createFloatingText(character.x + character.width / 2, character.y + 20, `+${character.ammoRegenAmount} 탄약`, 'yellow');
                        character.lastAmmoRegenTick = now;
                    }
                }

                // 중력 적용 (드론은 중력 무시)
                if (!character.onGround && !character.flies) {
                    character.vy += this.GRAVITY;
                }
                
                // 지면 충돌 처리 (드론은 지면 충돌 없음)
                if (!character.flies && character.y + character.height > this.canvas.height - this.GROUND_Y) {
                    character.y = this.canvas.height - this.GROUND_Y - character.height;
                    character.vy = 0;
                    character.onGround = true;
                } else if (!character.flies) {
                    character.onGround = false;
                }
                
                // 위치 업데이트 (시간 정지 효과 적용)
                if (this.gameState.timeSlowEffect > 0) { // 시간이 완전히 멈추지 않았을 때만 이동
                    character.x += character.vx * this.gameState.timeSlowEffect;
                    character.y += character.vy * this.gameState.timeSlowEffect;
                }
                
                // 마찰 적용
                character.vx *= this.FRICTION;
                
                // 화면 경계 제한
                character.x = Math.max(0, Math.min(this.canvas.width - character.width, character.x));
                // 드론은 Y축도 화면 경계 제한 (상단)
                if (character.flies) {
                    character.y = Math.max(50, Math.min(this.canvas.height - this.GROUND_Y - character.height, character.y));
                }

                // 플레이어 입력 처리
                if (character === player) { // character === this.gameState.player 대신 player 사용
                    // 플레이어1이 죽어있으면 입력 처리 안함
                    if (this.gameState.player1Dead) return;
                    
                    const currentSpeed = character.speed * (now > this.gameState.playerSlowedEndTime ? 1 : this.gameState.playerSlowEffect || 1);
                    
                    // 키보드 입력 처리
                    if (this.keys['a']) character.vx -= currentSpeed;
                    if (this.keys['d']) character.vx += currentSpeed;
                    if ((this.keys['w'] || this.keys[' ']) && character.onGround) {
                        character.vy = -character.jumpPower;
                        character.onGround = false;
                    }
                    
                    // 모바일 터치 컨트롤 처리
                    if (this.mobileMode) {
                        // 이동 조이스틱
                        if (this.touchControls.joystick.active) {
                            const joystickX = this.touchControls.joystick.x / 50;
                            const joystickY = this.touchControls.joystick.y / 50;
                            character.vx += joystickX * currentSpeed * 0.5; // 속도 0.1 → 0.5로 증가
                            character.vy += joystickY * currentSpeed * 0.5;
                        }
                        // 조준 조이스틱
                        if (this.touchControls.aimJoystick && (this.touchControls.aimJoystick.x !== 0 || this.touchControls.aimJoystick.y !== 0)) {
                            character.facing = Math.atan2(this.touchControls.aimJoystick.y, this.touchControls.aimJoystick.x);
                        } else {
                            // 마우스/터치 방향으로 플레이어 바라보게 설정 (조이스틱이 비활성일 때만)
                            const dx = this.mouse.x - (character.x + character.width / 2);
                            const dy = this.mouse.y - (character.y + character.height / 2);
                            character.facing = Math.atan2(dy, dx);
                        }
                        // 점프 버튼
                        if (this.touchControls.jumpButton.pressed && character.onGround) {
                            character.vy = -character.jumpPower;
                            character.onGround = false;
                        }
                    }
                    
                    // 마우스/터치 방향으로 플레이어 바라보게 설정
                    const dx = this.mouse.x - (character.x + character.width / 2);
                    const dy = this.mouse.y - (character.y + character.height / 2);
                    character.facing = Math.atan2(dy, dx);
                    
                    // gunRecoil 보간 (부드럽게 복귀)
                    character.gunRecoil += (character.gunRecoilTarget - character.gunRecoil) * 0.6;
                    if (Math.abs(character.gunRecoil - character.gunRecoilTarget) < 0.5) character.gunRecoil = character.gunRecoilTarget;
                } else if (character.type === 'player2') {
                    // 플레이어2가 죽어있으면 입력 처리 안함
                    if (this.gameState.player2Dead) return;
                    
                    // 플레이어2 입력 처리
                    const currentSpeed = character.speed * (now > this.gameState.playerSlowedEndTime ? 1 : this.gameState.playerSlowEffect || 1);
                    if (character.keys['a']) character.vx -= currentSpeed;
                    if (character.keys['d']) character.vx += currentSpeed;
                    if ((character.keys['w'] || character.keys[' ']) && character.onGround) {
                        character.vy = -character.jumpPower;
                        character.onGround = false;
                    }
                    
                    // 조준 방향 결정
                    if (this.gameState.multiplayerMode === 'leader') {
                        // 리더 시스템: 플레이어1의 조준 방향을 따라감
                        character.facing = this.gameState.player.facing;
                    } else if (this.gameState.multiplayerMode === 'hybrid') {
                        // 하이브리드 시스템: 자동 조준
                        const nearestEnemy = this.findNearestEnemy(character);
                        if (nearestEnemy) {
                            character.facing = Math.atan2(nearestEnemy.y - character.y, nearestEnemy.x - character.x);
                        }
                    }
                    
                                    // gunRecoil 보간
                character.gunRecoil += (character.gunRecoilTarget - character.gunRecoil) * 0.6;
                if (Math.abs(character.gunRecoil - character.gunRecoilTarget) < 0.5) character.gunRecoil = character.gunRecoilTarget;
                } else if (character.type === 'ally') {
                    // 아군 AI: 가장 가까운 적을 찾아 이동하고 공격
                    let closestEnemy = null;
                    let minDistance = Infinity;

                    this.gameState.enemies.forEach(enemy => {
                        const dx = enemy.x - character.x;
                        const dy = enemy.y - character.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestEnemy = enemy;
                        }
                    });

                    if (closestEnemy) {
                        const dx = closestEnemy.x - character.x;
                        const dy = closestEnemy.y - character.y;
                        const angle = Math.atan2(dy, dx);
                        character.facing = angle;

                        // 적에게 접근 (너무 가까워지면 멈춤)
                        if (minDistance > 100) { // 적과 100px 이상 떨어져 있으면 이동
                            character.vx += Math.cos(angle) * 0.5 * character.speed * this.gameState.timeSlowEffect;
                            character.vy += Math.sin(angle) * 0.5 * character.speed * this.gameState.timeSlowEffect;
                        } else { // 적과 가까워지면 속도 줄임
                            character.vx *= 0.9 * this.gameState.timeSlowEffect;
                            character.vy *= 0.9 * this.gameState.timeSlowEffect;
                        }

                        // 공격
                        if (this.gameState.timeSlowEffect === 0) {
                            // 시간 정지 중에는 쿨타임을 강제로 갱신
                            character.lastShot = now;
                        } else if (now - character.lastShot > character.shootInterval * this.gameState.timeSlowEffect) {
                            this.gameState.projectiles.push({
                                id: Date.now() + Math.random(),
                                x: character.x + character.width / 2,
                                y: character.y + character.height / 2,
                                vx: Math.cos(angle) * 7,
                                vy: Math.sin(angle) * 7,
                                radius: 3,
                                damage: character.damage,
                                life: 80,
                                color: character.color,
                                ownerId: character.id,
                                pierceCount: 0,
                                explosiveRadius: 0,
                                bounceCount: 0,
                                isHoming: false,
                                homingStrength: 0,
                                splitCount: 0,
                                hitEnemies: []
                            });
                            character.lastShot = now;
                        }
                    } else {
                        // 적이 없으면 플레이어 따라다님
                        const dx = player.x - character.x; // player 변수 사용
                        const dy = player.y - character.y; // player 변수 사용
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance > 50) { // 플레이어와 50px 이상 떨어져 있으면 이동
                            const angle = Math.atan2(dy, dx);
                            character.vx += Math.cos(angle) * 0.3 * character.speed * this.gameState.timeSlowEffect;
                            character.vy += Math.sin(angle) * 0.3 * character.speed * this.gameState.timeSlowEffect;
                        } else {
                            character.vx *= 0.9 * this.gameState.timeSlowEffect;
                            character.vy *= 0.9 * this.gameState.timeSlowEffect;
                        }
                    }

                } else {
                    // 적 AI 동작 (시간 정지 효과 적용)
                    if (this.gameState.timeSlowEffect === 0) return; // 시간이 완전히 정지했으면 적은 움직이지 않음

                    // 타겟 플레이어 선택 (가장 가까운 플레이어를 타겟으로 함)
                    let targetPlayer = player;
                    let targetDistance = Math.sqrt(
                        Math.pow((player.x + player.width / 2) - (character.x + character.width / 2), 2) +
                        Math.pow((player.y + player.height / 2) - (character.y + character.height / 2), 2)
                    );
                    
                    // 멀티플레이 모드에서 플레이어2가 살아있다면 거리 비교
                    if (this.gameState.player2 && this.gameState.multiplayerMode && !this.gameState.player2Dead) {
                        const player2Distance = Math.sqrt(
                            Math.pow((this.gameState.player2.x + this.gameState.player2.width / 2) - (character.x + character.width / 2), 2) +
                            Math.pow((this.gameState.player2.y + this.gameState.player2.height / 2) - (character.y + character.height / 2), 2)
                        );
                        
                        if (player2Distance < targetDistance) {
                            targetPlayer = this.gameState.player2;
                            targetDistance = player2Distance;
                        }
                    }
                    
                    const dx = (targetPlayer.x + targetPlayer.width / 2) - (character.x + character.width / 2);
                    const dy = (targetPlayer.y + targetPlayer.height / 2) - (character.y + character.height / 2);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // === 보스 스킬 ===
                    if (character.type === 'boss') {
                        // 1. 미사일 난사 (여러 방향으로 탄환 퍼붓기)
                        if (now - character.lastMissile > character.missileCooldown) {
                            const missileCount = 12 + Math.floor(this.gameState.wave/5);
                            for (let i = 0; i < missileCount; i++) {
                                const angle = (Math.PI * 2) * (i / missileCount);
                                this.gameState.projectiles.push({
                                    id: Date.now() + Math.random(),
                                    x: character.x + character.width / 2,
                                    y: character.y + character.height / 2,
                                    vx: Math.cos(angle) * 8,
                                    vy: Math.sin(angle) * 8,
                                    radius: 6,
                                    damage: Math.floor(character.damage * 0.7),
                                    life: 90,
                                    color: character.color,
                                    ownerId: character.id
                                });
                            }
                            this.createFloatingText(character.x + character.width/2, character.y-20, '미사일 난사!', 'orange');
                            character.lastMissile = now;
                        }
                        // 2. 순간이동 (플레이어 근처로) - 쿨다운 증가
                        if (now - character.lastTeleport > (character.teleportCooldown || 15000)) {
                            const newX = targetPlayer.x + (Math.random() - 0.5) * 150;
                            const newY = targetPlayer.y + (Math.random() - 0.5) * 150;
                            character.x = Math.max(0, Math.min(this.canvas.width - character.width, newX));
                            character.y = Math.max(50, Math.min(this.canvas.height - this.GROUND_Y - character.height, newY));
                            this.createCollectParticles(character.x, character.y, character.color);
                            this.createFloatingText(character.x + character.width/2, character.y-20, '순간이동!', 'cyan');
                            character.lastTeleport = now;
                        }
                        // 3. 광역 폭발
                        if (now - character.lastExplosion > character.explosionCooldown) {
                            this.createExplosion(character.x + character.width/2, character.y + character.height/2, 120 + this.gameState.wave*2, Math.floor(character.damage * 1.2), character.id);
                            this.createFloatingText(character.x + character.width/2, character.y-20, '광역 폭발!', 'red');
                            character.lastExplosion = now;
                        }
                        // 4. 소환 (일반 적)
                        if (now - character.lastSummon > character.summonCooldown) {
                            const summonCount = 2 + Math.floor(this.gameState.wave/10);
                            for (let i = 0; i < summonCount; i++) {
                                const spawnX = character.x + (Math.random() - 0.5) * 120;
                                const spawnY = character.y + (Math.random() - 0.5) * 120;
                                const summonedEnemy = this.createEnemy();
                                summonedEnemy.x = Math.max(0, Math.min(this.canvas.width - summonedEnemy.width, spawnX));
                                summonedEnemy.y = Math.max(50, Math.min(this.canvas.height - this.GROUND_Y - summonedEnemy.height, spawnY));
                                this.gameState.enemies.push(summonedEnemy);
                            }
                            this.createFloatingText(character.x + character.width/2, character.y-20, '소환!', 'yellow');
                            character.lastSummon = now;
                        }
                        // 5. 쉴드 (무적)
                        if (!character.isInvincible && now - character.lastShield > character.shieldCooldown) {
                            character.isInvincible = true;
                            character.invincibleEndTime = now + character.shieldDuration;
                            character.lastShield = now;
                            this.createFloatingText(character.x + character.width/2, character.y-20, '쉴드!', 'lightblue');
                        }
                        if (character.isInvincible && now > character.invincibleEndTime) {
                            character.isInvincible = false;
                        }
                        // 6. 블랙홀 (플레이어를 끌어당김)
                        if (now - character.lastBlackhole > character.blackholeCooldown) {
                            // 블랙홀 효과: 플레이어를 보스 쪽으로 순간적으로 끌어당김
                            const dx = (character.x + character.width/2) - (targetPlayer.x + targetPlayer.width/2);
                            const dy = (character.y + character.height/2) - (targetPlayer.y + targetPlayer.height/2);
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist < 600) {
                                targetPlayer.vx += dx/dist * 30;
                                targetPlayer.vy += dy/dist * 30;
                                this.createFloatingText(targetPlayer.x + targetPlayer.width/2, targetPlayer.y-20, '블랙홀!', 'purple');
                            }
                            this.createFloatingText(character.x + character.width/2, character.y-20, '블랙홀!', 'purple');
                            character.lastBlackhole = now;
                        }
                    }

                    // 일반 보스 AI 이동/공격
                    if (distance > 10) {
                        character.vx += (dx > 0 ? 1 : -1) * 0.3 * this.gameState.timeSlowEffect;
                        character.facing = Math.atan2(dy, dx);
                    }
                    // 기본 발사 (플레이어 향해) - 새로운 적 10종은 제외
                    const newEnemyTypes = ['timekeeper', 'gravity', 'echo', 'vortex', 'prism', 'quantum', 'crystal', 'plasma', 'nebula'];
                    if (!newEnemyTypes.includes(character.type) && distance < 700 && now - character.lastShot > character.shootInterval * this.gameState.timeSlowEffect) {
                        const angle = Math.atan2(dy, dx);
                        this.gameState.projectiles.push({
                            id: Date.now() + Math.random(),
                            x: character.x + character.width / 2,
                            y: character.y + character.height / 2,
                            vx: Math.cos(angle) * 7,
                            vy: Math.sin(angle) * 7,
                            radius: 3,
                            damage: character.damage,
                            life: 80,
                            color: character.color,
                            ownerId: character.id,
                            pierceCount: 0,
                            explosiveRadius: 0,
                            bounceCount: 0,
                            isHoming: false,
                            homingStrength: 0,
                            splitCount: 0,
                            hitEnemies: []
                        });
                        character.lastShot = now;
                    }
                }

                // === 적별 고유 스킬/AI 구현 ===
                
                // 거리 계산 (모든 적 AI에서 사용)
                const dx = (player.x + player.width/2) - (character.x + character.width/2);
                const dy = (player.y + player.height/2) - (character.y + character.height/2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // 소환사: 주기적으로 적 소환
                if (character.type === 'summoner' && now - character.lastSummon > (character.summonCooldown || 8000)) {
                    const summonCount = character.summonCount || 1;
                    for (let i = 0; i < summonCount; i++) {
                        const spawnX = character.x + (Math.random() - 0.5) * 80;
                        const spawnY = character.y + (Math.random() - 0.5) * 80;
                        const summonedEnemy = this.createEnemy(character.summonType || 'basic');
                        summonedEnemy.x = Math.max(0, Math.min(this.canvas.width - summonedEnemy.width, spawnX));
                        summonedEnemy.y = Math.max(50, Math.min(this.canvas.height - this.GROUND_Y - summonedEnemy.height, spawnY));
                        this.gameState.enemies.push(summonedEnemy);
                    }
                    this.createFloatingText(character.x + character.width/2, character.y-20, '소환!', 'yellow');
                    character.lastSummon = now;
                }

                // 유령: 무적 상태 토글
                if (character.type === 'ghost' && now - character.lastInvincibility > (character.invincibilityCooldown || 3000)) {
                    character.isInvincible = !character.isInvincible;
                    character.lastInvincibility = now;
                    this.createFloatingText(character.x + character.width/2, character.y-20, character.isInvincible ? '무적!' : '취약!', character.isInvincible ? 'white' : 'red');
                }

                // 순간이동병: 순간이동
                if (character.type === 'teleporter' && now - character.lastTeleport > (character.teleportCooldown || 4000)) {
                    const newX = player.x + (Math.random() - 0.5) * 200;
                    const newY = player.y + (Math.random() - 0.5) * 200;
                    character.x = Math.max(0, Math.min(this.canvas.width - character.width, newX));
                    character.y = Math.max(50, Math.min(this.canvas.height - this.GROUND_Y - character.height, newY));
                    this.createCollectParticles(character.x, character.y, character.color);
                    this.createFloatingText(character.x + character.width/2, character.y-20, '순간이동!', 'cyan');
                    character.lastTeleport = now;
                }

                // 슬라임병: 느려지는 탄환 발사
                if (character.type === 'spitter' && distance < 600 && now - character.lastShot > character.shootInterval * this.gameState.timeSlowEffect) {
                    const angle = Math.atan2(dy, dx);
                    this.gameState.projectiles.push({
                        id: Date.now() + Math.random(),
                        x: character.x + character.width / 2,
                        y: character.y + character.height / 2,
                        vx: Math.cos(angle) * 6,
                        vy: Math.sin(angle) * 6,
                        radius: 4,
                        damage: character.damage,
                        life: 100,
                        color: character.color,
                        ownerId: character.id,
                        slowEffect: character.slowEffect || 0.5,
                        slowDuration: character.slowDuration || 3000
                    });
                    character.lastShot = now;
                }

                // 흡혈적: 플레이어에 닿으면 체력 흡수
                if (character.type === 'leech' && player) {
                    const dx = (player.x + player.width/2) - (character.x + character.width/2);
                    const dy = (player.y + player.height/2) - (character.y + character.height/2);
                    const touchDistance = Math.sqrt(dx*dx + dy*dy);
                    if (touchDistance < 30 && now - character.lastLeech > 1000) {
                        const leechAmount = character.leechAmount || 10;
                        player.health = Math.max(0, player.health - leechAmount);
                        character.health = Math.min(character.maxHealth, character.health + leechAmount);
                        this.createFloatingText(player.x + player.width/2, player.y-20, `-${leechAmount} 흡혈`, 'red');
                        this.createFloatingText(character.x + character.width/2, character.y-20, `+${leechAmount} 흡수`, 'green');
                        character.lastLeech = now;
                    }
                }

                // 지뢰 적: 플레이어 근처에서 폭발
                if (character.type === 'mine' && player) {
                    const dx = (player.x + player.width/2) - (character.x + character.width/2);
                    const dy = (player.y + player.height/2) - (character.y + character.height/2);
                    const mineDistance = Math.sqrt(dx*dx + dy*dy);
                    if (mineDistance < (character.explodeRadius || 60)) {
                        this.createExplosion(character.x + character.width/2, character.y + character.height/2, 80, character.damage, character.id);
                        this.createFloatingText(character.x + character.width/2, character.y-20, '폭발!', 'orange');
                        this.gameState.enemies = this.gameState.enemies.filter(e => e !== character);
                        return;
                    }
                }

                // 빙결 적: 플레이어를 얼림
                if (character.type === 'freezer' && distance < 600 && now - character.lastFreeze > (character.freezeCooldown || 5000)) {
                    player.speed *= 0.3;
                    this.createFloatingText(player.x + player.width/2, player.y-20, '빙결!', 'lightblue');
                    setTimeout(() => {
                        player.speed = this.ENEMY_TYPES[player.type]?.speed || 5;
                    }, character.freezeDuration || 2000);
                    character.lastFreeze = now;
                }

                // 반사 적: 탄환 반사
                if (character.type === 'reflector' && Math.random() < (character.reflectChance || 0.3)) {
                    // 탄환 반사 로직은 발사체 충돌 처리에서 구현
                }

                // 힐러 적: 주변 적 회복
                if (character.type === 'healer' && now - character.lastHeal > (character.healCooldown || 4000)) {
                    this.gameState.enemies.forEach(enemy => {
                        if (enemy !== character) {
                            const dx = (enemy.x + enemy.width/2) - (character.x + character.width/2);
                            const dy = (enemy.y + enemy.height/2) - (character.y + character.height/2);
                            const healDistance = Math.sqrt(dx*dx + dy*dy);
                            if (healDistance < (character.healRadius || 120)) {
                                enemy.health = Math.min(enemy.maxHealth, enemy.health + (character.healAmount || 15));
                                this.createFloatingText(enemy.x + enemy.width/2, enemy.y-20, `+${character.healAmount || 15}`, 'green');
                            }
                        }
                    });
                    this.createFloatingText(character.x + character.width/2, character.y-20, '치유!', 'green');
                    character.lastHeal = now;
                }

                // 포탈 적: 순간이동
                if (character.type === 'portal' && now - character.lastTeleport > (character.teleportCooldown || 3000)) {
                    const newX = player.x + (Math.random() - 0.5) * 150;
                    const newY = player.y + (Math.random() - 0.5) * 150;
                    character.x = Math.max(0, Math.min(this.canvas.width - character.width, newX));
                    character.y = Math.max(50, Math.min(this.canvas.height - this.GROUND_Y - character.height, newY));
                    this.createCollectParticles(character.x, character.y, character.color);
                    this.createFloatingText(character.x + character.width/2, character.y-20, '포탈!', 'purple');
                    character.lastTeleport = now;
                }

                // 폭발 적: 죽을 때 폭발 (적 사망 처리에서 구현)

                // 자석 적: 유도 탄환 발사
                if (character.type === 'magnet' && distance < 600 && now - character.lastShot > character.shootInterval * this.gameState.timeSlowEffect) {
                    const angle = Math.atan2(dy, dx);
                    this.gameState.projectiles.push({
                        id: Date.now() + Math.random(),
                        x: character.x + character.width / 2,
                        y: character.y + character.height / 2,
                        vx: Math.cos(angle) * 5,
                        vy: Math.sin(angle) * 5,
                        radius: 3,
                        damage: character.damage,
                        life: 120,
                        color: character.color,
                        ownerId: character.id,
                        isHoming: true,
                        homingStrength: 0.1
                    });
                    character.lastShot = now;
                }

                // 저주 적: 저주 효과
                if (character.type === 'curse' && distance < 600 && now - character.lastCurse > (character.curseCooldown || 6000)) {
                    player.damageReductionFactor = 0.7;
                    this.createFloatingText(player.x + player.width/2, player.y-20, '저주!', 'purple');
                    setTimeout(() => {
                        player.damageReductionFactor = 1;
                    }, character.curseDuration || 2500);
                    character.lastCurse = now;
                }

                // 플로터: 자유로운 움직임
                if (character.type === 'floater') {
                    if (now - character.lastDirectionChange > 2000) {
                        character.floatDirection = Math.random() * Math.PI * 2;
                        character.lastDirectionChange = now;
                    }
                    character.vx += Math.cos(character.floatDirection) * 0.5;
                    character.vy += Math.sin(character.floatDirection) * 0.5;
                }

                // 페이저: 페이즈 스킬
                if (character.type === 'phaser' && now - character.lastPhase > (character.phaseCooldown || 8000)) {
                    character.isPhasing = true;
                    character.globalAlpha = 0.3;
                    this.createFloatingText(character.x + character.width/2, character.y-20, '페이즈!', 'cyan');
                    setTimeout(() => {
                        character.isPhasing = false;
                        character.globalAlpha = 1;
                    }, character.phaseDuration || 2000);
                    character.lastPhase = now;
                }

                // === 새로운 적 10종 AI 로직 ===
                
                // 닌자: 은신 모드
                if (character.type === 'ninja' && now - character.lastStealth > (character.stealthCooldown || 5000)) {
                    character.isStealthed = true;
                    character.globalAlpha = 0.2;
                    this.createFloatingText(character.x + character.width/2, character.y-20, '은신!', 'gray');
                    setTimeout(() => {
                        character.isStealthed = false;
                        character.globalAlpha = 1;
                    }, character.stealthDuration || 2000);
                    character.lastStealth = now;
                }

                // 스나이퍼: 장거리 공격
                if (character.type === 'sniper' && distance < (character.range || 400) && now - character.lastShot > character.shootInterval * this.gameState.timeSlowEffect) {
                    const angle = Math.atan2(dy, dx);
                    this.gameState.projectiles.push({
                        id: Date.now() + Math.random(),
                        x: character.x + character.width / 2,
                        y: character.y + character.height / 2,
                        vx: Math.cos(angle) * 12,
                        vy: Math.sin(angle) * 12,
                        radius: 2,
                        damage: character.damage,
                        life: 150,
                        color: character.color,
                        ownerId: character.id
                    });
                    character.lastShot = now;
                }

                // 광전사: 분노 모드
                if (character.type === 'berserker' && character.health < character.maxHealth * (character.rageThreshold || 0.3) && !character.isRaging) {
                    character.isRaging = true;
                    character.speed *= character.rageSpeedBoost || 1.5;
                    character.damage *= character.rageDamageBoost || 1.8;
                    this.createFloatingText(character.x + character.width/2, character.y-20, '분노!', 'red');
                }

                // 소환사: 소환 능력
                if (character.type === 'summoner' && now - character.lastSummon > (character.summonCooldown || 8000)) {
                    for (let i = 0; i < (character.summonCount || 2); i++) {
                        const spawnX = character.x + (Math.random() - 0.5) * 100;
                        const spawnY = character.y + (Math.random() - 0.5) * 100;
                        const summonedEnemy = this.createEnemy(character.summonType || 'basic');
                        summonedEnemy.x = Math.max(0, Math.min(this.canvas.width - summonedEnemy.width, spawnX));
                        summonedEnemy.y = Math.max(50, Math.min(this.canvas.height - this.GROUND_Y - summonedEnemy.height, spawnY));
                        this.gameState.enemies.push(summonedEnemy);
                    }
                    this.createFloatingText(character.x + character.width/2, character.y-20, '소환!', 'yellow');
                    character.lastSummon = now;
                }

                // 가디언: 방패 모드
                if (character.type === 'guardian' && now - character.lastShield > (character.shieldCooldown || 6000)) {
                    character.isShielded = true;
                    character.damageReductionFactor = 0.3;
                    this.createFloatingText(character.x + character.width/2, character.y-20, '방패!', 'lightblue');
                    setTimeout(() => {
                        character.isShielded = false;
                        character.damageReductionFactor = 1;
                    }, character.shieldDuration || 3000);
                    character.lastShield = now;
                }

                // 어쌔신: 뒤치기 공격
                if (character.type === 'assassin' && distance < 50 && now - character.lastBackstab > 2000) {
                    const backstabDamage = character.damage * (character.backstabMultiplier || 2.0);
                    player.health = Math.max(0, player.health - backstabDamage);
                    this.createFloatingText(player.x + player.width/2, player.y-20, `-${backstabDamage} 뒤치기!`, 'red');
                    character.lastBackstab = now;
                }

                // 헤비: 중화기 공격
                if (character.type === 'heavy' && distance < 600 && now - character.lastShot > character.shootInterval * this.gameState.timeSlowEffect) {
                    const angle = Math.atan2(dy, dx);
                    this.gameState.projectiles.push({
                        id: Date.now() + Math.random(),
                        x: character.x + character.width / 2,
                        y: character.y + character.height / 2,
                        vx: Math.cos(angle) * 4,
                        vy: Math.sin(angle) * 4,
                        radius: 8,
                        damage: character.damage,
                        life: 100,
                        color: character.color,
                        ownerId: character.id,
                        splashDamage: true,
                        splashRadius: character.splashRadius || 60
                    });
                    character.lastShot = now;
                }

                // 폭격기: 폭발성 탄환
                if (character.type === 'bomber' && distance < 600 && now - character.lastShot > character.shootInterval * this.gameState.timeSlowEffect) {
                    const angle = Math.atan2(dy, dx);
                    this.gameState.projectiles.push({
                        id: Date.now() + Math.random(),
                        x: character.x + character.width / 2,
                        y: character.y + character.height / 2,
                        vx: Math.cos(angle) * 6,
                        vy: Math.sin(angle) * 6,
                        radius: 5,
                        damage: character.damage,
                        life: 120,
                        color: character.color,
                        ownerId: character.id,
                        explosiveRadius: character.explosionRadius || 50
                    });
                    character.lastShot = now;
                }

                // 메딕: 치료 능력
                if (character.type === 'medic' && now - character.lastHeal > (character.healCooldown || 10000)) {
                    this.gameState.enemies.forEach(enemy => {
                        if (enemy !== character) {
                            const dx = (enemy.x + enemy.width/2) - (character.x + character.width/2);
                            const dy = (enemy.y + enemy.height/2) - (character.y + character.height/2);
                            const healDistance = Math.sqrt(dx*dx + dy*dy);
                            if (healDistance < (character.healRadius || 150)) {
                                enemy.health = Math.min(enemy.maxHealth, enemy.health + (character.healAmount || 20));
                                this.createFloatingText(enemy.x + enemy.width/2, enemy.y-20, `+${character.healAmount || 20}`, 'green');
                            }
                        }
                    });
                    this.createFloatingText(character.x + character.width/2, character.y-20, '치유!', 'green');
                    character.lastHeal = now;
                }

                // 드론: 호버 모드
                if (character.type === 'drone' && now - character.lastHover > (character.hoverCooldown || 4000)) {
                    character.isHovering = true;
                    character.speed *= 0.5;
                    this.createFloatingText(character.x + character.width/2, character.y-20, '호버!', 'cyan');
                    setTimeout(() => {
                        character.isHovering = false;
                        character.speed = this.ENEMY_TYPES.drone.speed;
                    }, character.hoverDuration || 2000);
                    character.lastHover = now;
                }

                // === 새로운 적 10종 AI 로직 (스킬 2개씩) ===
                
                // 타임키퍼: 스킬1 - 시간 역행, 스킬2 - 시간 가속
                if (character.type === 'timekeeper') {
                    // 스킬1: 시간 역행 (6초 쿨)
                    if (now - character.lastTimeReverse > 6000) {
                        this.gameState.timeSlowEffect = 0.3; // 시간을 느리게
                        this.createFloatingText(character.x + character.width/2, character.y-20, '시간 역행!', '#ff6b9d');
                        setTimeout(() => {
                            this.gameState.timeSlowEffect = 1;
                        }, 3000);
                        character.lastTimeReverse = now;
                    }
                    // 스킬2: 시간 가속 (8초 쿨)
                    if (now - character.lastTimeAccel > (character.timeAccelCooldown || 8000)) {
                        this.gameState.timeSlowEffect = 2.0; // 시간을 빠르게
                        this.createFloatingText(character.x + character.width/2, character.y-20, '시간 가속!', '#ff6b9d');
                        setTimeout(() => {
                            this.gameState.timeSlowEffect = 1;
                        }, 2000);
                        character.lastTimeAccel = now;
                    }
                }

                // 그래비티: 스킬1 - 중력장, 스킬2 - 반중력
                if (character.type === 'gravity') {
                    // 스킬1: 중력장 (8초 쿨)
                    if (now - character.lastGravity > (character.gravityCooldown || 8000)) {
                        const dx = (character.x + character.width/2) - (player.x + player.width/2);
                        const dy = (character.y + character.height/2) - (player.y + player.height/2);
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < 200) {
                            player.vx += (dx/dist) * 0.8;
                            player.vy += (dy/dist) * 0.8;
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, '중력장!', '#9d4edd');
                        character.lastGravity = now;
                    }
                    // 스킬2: 반중력 (6초 쿨)
                    if (now - character.lastAntiGravity > (character.antiGravityCooldown || 6000)) {
                        const dx = (character.x + character.width/2) - (player.x + player.width/2);
                        const dy = (character.y + character.height/2) - (player.y + player.height/2);
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < 150) {
                            player.vx -= (dx/dist) * 1.2;
                            player.vy -= (dy/dist) * 1.2;
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, '반중력!', '#9d4edd');
                        character.lastAntiGravity = now;
                    }
                }

                // 에코: 스킬1 - 에코 발사, 스킬2 - 음파 공격
                if (character.type === 'echo') {
                    const dx = (player.x + player.width/2) - (character.x + character.width/2);
                    const dy = (player.y + player.height/2) - (character.y + character.height/2);
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    // 스킬1: 에코 발사 (발사 간격)
                    if (distance < 600 && now - character.lastEcho > character.shootInterval * this.gameState.timeSlowEffect) {
                        const angle = Math.atan2(dy, dx);
                        for (let i = 0; i < 3; i++) {
                            setTimeout(() => {
                                this.gameState.projectiles.push({
                                    id: Date.now() + Math.random(),
                                    x: character.x + character.width / 2,
                                    y: character.y + character.height / 2,
                                    vx: Math.cos(angle) * 7,
                                    vy: Math.sin(angle) * 7,
                                    radius: 4,
                                    damage: character.damage,
                                    life: 100,
                                    color: character.color,
                                    ownerId: character.id
                                });
                            }, i * 500);
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, '에코!', '#4cc9f0');
                        character.lastEcho = now;
                    }
                    // 스킬2: 음파 공격 (10초 쿨)
                    if (now - character.lastSonicWave > (character.sonicWaveCooldown || 10000)) {
                        const angle = Math.atan2(dy, dx);
                        for (let i = 0; i < 8; i++) {
                            const spreadAngle = angle + (i - 4) * 0.3;
                            this.gameState.projectiles.push({
                                id: Date.now() + Math.random(),
                                x: character.x + character.width / 2,
                                y: character.y + character.height / 2,
                                vx: Math.cos(spreadAngle) * 6,
                                vy: Math.sin(spreadAngle) * 6,
                                radius: 5,
                                damage: character.damage * 1.5,
                                life: 120,
                                color: character.color,
                                ownerId: character.id
                            });
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, '음파!', '#4cc9f0');
                        character.lastSonicWave = now;
                    }
                }

                // 보르텍스: 스킬1 - 소용돌이, 스킬2 - 회오리
                if (character.type === 'vortex') {
                    // 스킬1: 소용돌이 (10초 쿨)
                    if (now - character.lastVortex > (character.vortexCooldown || 10000)) {
                        const dx = (character.x + character.width/2) - (player.x + player.width/2);
                        const dy = (character.y + character.height/2) - (player.y + player.height/2);
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < 250) {
                            player.vx += (dx/dist) * 2.0;
                            player.vy += (dy/dist) * 2.0;
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, '보르텍스!', '#7209b7');
                        character.lastVortex = now;
                    }
                    // 스킬2: 회오리 (7초 쿨)
                    if (now - character.lastWhirlwind > (character.whirlwindCooldown || 7000)) {
                        const dx = (player.x + player.width/2) - (character.x + character.width/2);
                        const dy = (player.y + player.height/2) - (character.y + character.height/2);
                        const angle = Math.atan2(dy, dx);
                        for (let i = 0; i < 12; i++) {
                            const spinAngle = angle + (i * Math.PI / 6);
                            this.gameState.projectiles.push({
                                id: Date.now() + Math.random(),
                                x: character.x + character.width / 2,
                                y: character.y + character.height / 2,
                                vx: Math.cos(spinAngle) * 5,
                                vy: Math.sin(spinAngle) * 5,
                                radius: 4,
                                damage: character.damage,
                                life: 80,
                                color: character.color,
                                ownerId: character.id
                            });
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, '회오리!', '#7209b7');
                        character.lastWhirlwind = now;
                    }
                }

                // 프리즘: 스킬1 - 프리즘 분산, 스킬2 - 레이저
                if (character.type === 'prism') {
                    const dx = (player.x + player.width/2) - (character.x + character.width/2);
                    const dy = (player.y + player.height/2) - (character.y + character.height/2);
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    // 스킬1: 프리즘 분산 (발사 간격)
                    if (distance < 600 && now - character.lastPrism > character.shootInterval * this.gameState.timeSlowEffect) {
                        const angle = Math.atan2(dy, dx);
                        for (let i = 0; i < 5; i++) {
                            const spreadAngle = angle - Math.PI/3 + (Math.PI/3 * i / 2);
                            this.gameState.projectiles.push({
                                id: Date.now() + Math.random(),
                                x: character.x + character.width / 2,
                                y: character.y + character.height / 2,
                                vx: Math.cos(spreadAngle) * 6,
                                vy: Math.sin(spreadAngle) * 6,
                                radius: 3,
                                damage: character.damage,
                                life: 90,
                                color: character.color,
                                ownerId: character.id
                            });
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, '프리즘!', '#f72585');
                        character.lastPrism = now;
                    }
                    // 스킬2: 레이저 (8초 쿨)
                    if (now - character.lastLaser > (character.laserCooldown || 8000)) {
                        const angle = Math.atan2(dy, dx);
                        this.gameState.projectiles.push({
                            id: Date.now() + Math.random(),
                            x: character.x + character.width / 2,
                            y: character.y + character.height / 2,
                            vx: Math.cos(angle) * 12,
                            vy: Math.sin(angle) * 12,
                            radius: 2,
                            damage: character.damage * 2,
                            life: 150,
                            color: character.color,
                            ownerId: character.id
                        });
                        this.createFloatingText(character.x + character.width/2, character.y-20, '레이저!', '#f72585');
                        character.lastLaser = now;
                    }
                }

                // 퀀텀: 스킬1 - 양자 순간이동, 스킬2 - 양자 분열
                if (character.type === 'quantum') {
                    // 스킬1: 양자 순간이동 (6초 쿨)
                    if (now - character.lastQuantum > (character.quantumCooldown || 6000)) {
                        const newX = character.x + (Math.random() - 0.5) * 300;
                        const newY = character.y + (Math.random() - 0.5) * 300;
                        character.x = Math.max(0, Math.min(this.canvas.width - character.width, newX));
                        character.y = Math.max(50, Math.min(this.canvas.height - this.GROUND_Y - character.height, newY));
                        this.createCollectParticles(character.x, character.y, character.color);
                        this.createFloatingText(character.x + character.width/2, character.y-20, '퀀텀!', '#3a0ca3');
                        character.lastQuantum = now;
                    }
                    // 스킬2: 양자 분열 (12초 쿨)
                    if (now - character.lastQuantumSplit > (character.quantumSplitCooldown || 12000)) {
                        const dx = (player.x + player.width/2) - (character.x + character.width/2);
                        const dy = (player.y + player.height/2) - (character.y + character.height/2);
                        const angle = Math.atan2(dy, dx);
                        for (let i = 0; i < 3; i++) {
                            const splitAngle = angle + (i - 1) * 0.5;
                            this.gameState.projectiles.push({
                                id: Date.now() + Math.random(),
                                x: character.x + character.width / 2,
                                y: character.y + character.height / 2,
                                vx: Math.cos(splitAngle) * 8,
                                vy: Math.sin(splitAngle) * 8,
                                radius: 4,
                                damage: character.damage * 1.3,
                                life: 100,
                                color: character.color,
                                ownerId: character.id
                            });
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, '양자 분열!', '#3a0ca3');
                        character.lastQuantumSplit = now;
                    }
                }

                // 크리스탈: 스킬1 - 크리스탈 방패, 스킬2 - 크리스탈 파편
                if (character.type === 'crystal') {
                    // 스킬1: 크리스탈 방패 (15초 쿨)
                    if (now - character.lastCrystal > (character.crystalCooldown || 15000)) {
                        character.isCrystalShielded = true;
                        character.damageReductionFactor = 0.2; // 80% 데미지 감소
                        this.createFloatingText(character.x + character.width/2, character.y-20, '크리스탈!', '#4361ee');
                        setTimeout(() => {
                            character.isCrystalShielded = false;
                            character.damageReductionFactor = 1;
                        }, 5000);
                        character.lastCrystal = now;
                    }
                    // 스킬2: 크리스탈 파편 (10초 쿨)
                    if (now - character.lastCrystalShard > (character.crystalShardCooldown || 10000)) {
                        const dx = (player.x + player.width/2) - (character.x + character.width/2);
                        const dy = (player.y + player.height/2) - (character.y + character.height/2);
                        const angle = Math.atan2(dy, dx);
                        for (let i = 0; i < 6; i++) {
                            const shardAngle = angle + (i - 3) * 0.4;
                            this.gameState.projectiles.push({
                                id: Date.now() + Math.random(),
                                x: character.x + character.width / 2,
                                y: character.y + character.height / 2,
                                vx: Math.cos(shardAngle) * 7,
                                vy: Math.sin(shardAngle) * 7,
                                radius: 3,
                                damage: character.damage * 1.2,
                                life: 110,
                                color: character.color,
                                ownerId: character.id
                            });
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, '크리스탈 파편!', '#4361ee');
                        character.lastCrystalShard = now;
                    }
                }



                // 플라즈마: 스킬1 - 플라즈마 체인, 스킬2 - 플라즈마 폭발
                if (character.type === 'plasma') {
                    const dx = (player.x + player.width/2) - (character.x + character.width/2);
                    const dy = (player.y + player.height/2) - (character.y + character.height/2);
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    // 스킬1: 플라즈마 체인 (발사 간격)
                    if (distance < 600 && now - character.lastPlasma > character.shootInterval * this.gameState.timeSlowEffect) {
                        const angle = Math.atan2(dy, dx);
                        for (let i = 0; i < 4; i++) {
                            const chainAngle = angle + (i - 2) * 0.3;
                            this.gameState.projectiles.push({
                                id: Date.now() + Math.random(),
                                x: character.x + character.width / 2,
                                y: character.y + character.height / 2,
                                vx: Math.cos(chainAngle) * 8,
                                vy: Math.sin(chainAngle) * 8,
                                radius: 5,
                                damage: character.damage,
                                life: 120,
                                color: character.color,
                                ownerId: character.id
                            });
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, '플라즈마!', '#06ffa5');
                        character.lastPlasma = now;
                    }
                    // 스킬2: 플라즈마 폭발 (12초 쿨)
                    if (now - character.lastPlasmaExplosion > (character.plasmaExplosionCooldown || 12000)) {
                        this.createExplosion(character.x + character.width/2, character.y + character.height/2, 120, character.damage * 2, character.id);
                        this.createFloatingText(character.x + character.width/2, character.y-20, '플라즈마 폭발!', '#06ffa5');
                        character.lastPlasmaExplosion = now;
                    }
                }

                // 네뷸라: 스킬1 - 네뷸라 구름, 스킬2 - 별 폭발
                if (character.type === 'nebula') {
                    // 스킬1: 네뷸라 구름 (12초 쿨)
                    if (now - character.lastNebula > (character.nebulaCooldown || 12000)) {
                        const dx = (character.x + character.width/2) - (player.x + player.width/2);
                        const dy = (character.y + character.height/2) - (player.y + player.height/2);
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < 180) {
                            player.health = Math.max(0, player.health - 8);
                            this.createFloatingText(player.x + player.width/2, player.y-20, '-8', '#ff9e00');
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, '네뷸라!', '#ff9e00');
                        character.lastNebula = now;
                    }
                    // 스킬2: 별 폭발 (8초 쿨)
                    if (now - character.lastStarExplosion > (character.starExplosionCooldown || 8000)) {
                        const dx = (player.x + player.width/2) - (character.x + character.width/2);
                        const dy = (player.y + player.height/2) - (character.y + character.height/2);
                        const angle = Math.atan2(dy, dx);
                        for (let i = 0; i < 10; i++) {
                            const starAngle = angle + (i * Math.PI / 5);
                            this.gameState.projectiles.push({
                                id: Date.now() + Math.random(),
                                x: character.x + character.width / 2,
                                y: character.y + character.height / 2,
                                vx: Math.cos(starAngle) * 6,
                                vy: Math.sin(starAngle) * 6,
                                radius: 4,
                                damage: character.damage * 1.4,
                                life: 100,
                                color: character.color,
                                ownerId: character.id
                            });
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, '별 폭발!', '#ff9e00');
                        character.lastStarExplosion = now;
                    }
                }
                // ...

                // === 각 보스별 고유 스킬 ===
                if (character.type === 'boss_alpha') {
                    // 1. 미니언 소환
                    if (now - character.lastSummon > character.summonCooldown) {
                        for (let i = 0; i < character.summonCount; i++) {
                            const spawnX = character.x + (Math.random() - 0.5) * 100;
                            const spawnY = character.y + (Math.random() - 0.5) * 100;
                            const summonedEnemy = this.createEnemy(character.summonType);
                            summonedEnemy.x = spawnX;
                            summonedEnemy.y = spawnY;
                            this.gameState.enemies.push(summonedEnemy);
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, '미니언 소환!', 'yellow');
                        character.lastSummon = now;
                    }
                    // 2. 연속 돌진
                    if (now - character.lastDash > character.dashCooldown) {
                        character.isDashing = true;
                        let dashIdx = 0;
                        const dash = () => {
                            if (dashIdx < character.dashCount) {
                                const angle = Math.atan2(player.y - character.y, player.x - character.x);
                                character.vx += Math.cos(angle) * 30;
                                character.vy += Math.sin(angle) * 30;
                                this.createFloatingText(character.x + character.width/2, character.y-20, '돌진!', 'orange');
                                dashIdx++;
                                setTimeout(dash, character.dashDuration);
                            } else {
                                character.isDashing = false;
                            }
                        };
                        dash();
                        character.lastDash = now;
                    }
                    // 3. 광역 충격파
                    if (now - character.lastShockwave > character.shockwaveCooldown) {
                        this.createExplosion(character.x + character.width/2, character.y + character.height/2, 180, character.damage * 1.5, character.id);
                        this.createFloatingText(character.x + character.width/2, character.y-20, '충격파!', 'red');
                        character.lastShockwave = now;
                    }
                }
                if (character.type === 'boss_beta') {
                    // 1. 쉴드(무적)
                    if (!character.isInvincible && now - character.lastShield > character.shieldCooldown) {
                        character.isInvincible = true;
                        character.invincibleEndTime = now + character.shieldDuration;
                        character.lastShield = now;
                        this.createFloatingText(character.x + character.width/2, character.y-20, '쉴드!', 'lightblue');
                    }
                    if (character.isInvincible && now > character.invincibleEndTime) {
                        character.isInvincible = false;
                    }
                    // 2. 탄막 발사
                    if (now - character.lastBarrage > character.barrageCooldown) {
                        const count = 18;
                        for (let i = 0; i < count; i++) {
                            const angle = (Math.PI * 2) * (i / count);
                            this.gameState.projectiles.push({
                                id: Date.now() + Math.random(),
                                x: character.x + character.width / 2,
                                y: character.y + character.height / 2,
                                vx: Math.cos(angle) * 7,
                                vy: Math.sin(angle) * 7,
                                radius: 5,
                                damage: character.damage * 0.7,
                                life: 90,
                                color: character.color,
                                ownerId: character.id
                            });
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, '탄막!', 'cyan');
                        character.lastBarrage = now;
                    }
                    // 3. 체력 회복
                    if (now - character.lastHeal > character.healCooldown) {
                        character.health = Math.min(character.maxHealth, character.health + character.healAmount);
                        this.createFloatingText(character.x + character.width/2, character.y-20, `+${character.healAmount} 회복!`, 'green');
                        character.lastHeal = now;
                    }
                }
                if (character.type === 'boss_gamma') {
                    // 1. 순간이동
                    if (now - character.lastTeleport > character.teleportCooldown) {
                        const newX = player.x + (Math.random() - 0.5) * character.teleportRange;
                        const newY = player.y + (Math.random() - 0.5) * character.teleportRange;
                        character.x = Math.max(0, Math.min(this.canvas.width - character.width, newX));
                        character.y = Math.max(50, Math.min(this.canvas.height - this.GROUND_Y - character.height, newY));
                        this.createCollectParticles(character.x, character.y, character.color);
                        this.createFloatingText(character.x + character.width/2, character.y-20, '순간이동!', 'orange');
                        character.lastTeleport = now;
                    }
                    // 2. 레이저
                    if (now - character.lastLaser > character.laserCooldown) {
                        // 플레이어 방향으로 강력한 레이저(직선상 폭발)
                        const angle = Math.atan2(player.y - character.y, player.x - character.x);
                        for (let d = 60; d < 400; d += 40) {
                            const lx = character.x + character.width/2 + Math.cos(angle) * d;
                            const ly = character.y + character.height/2 + Math.sin(angle) * d;
                            this.createExplosion(lx, ly, 40, character.damage * 1.2, character.id);
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, '레이저!', 'red');
                        character.lastLaser = now;
                    }
                    // 3. 속도 버프
                    if (!character.isSpeedBuffed && now - character.lastSpeedBuff > character.speedBuffCooldown) {
                        character.speed *= 2;
                        character.isSpeedBuffed = true;
                        this.createFloatingText(character.x + character.width/2, character.y-20, '속도 버프!', 'lime');
                        setTimeout(() => {
                            character.speed /= 2;
                            character.isSpeedBuffed = false;
                        }, character.speedBuffDuration);
                        character.lastSpeedBuff = now;
                    }
                }
                if (character.type === 'boss_delta') {
                    // 1. 블랙홀 (쿨다운 증가, 효과 감소)
                    if (now - character.lastBlackhole > (character.blackholeCooldown || 15000)) {
                        const dx = (character.x + character.width/2) - (player.x + player.width/2);
                        const dy = (character.y + character.height/2) - (player.y + player.height/2);
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < 600) {
                            player.vx += dx/dist * 15; // 효과 감소
                            player.vy += dy/dist * 15;
                            if (!character.lastBlackholeEffect || now - character.lastBlackholeEffect > 2000) {
                                this.createFloatingText(player.x + player.width/2, player.y-20, '블랙홀!', 'purple');
                                character.lastBlackholeEffect = now;
                            }
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, '블랙홀!', 'purple');
                        character.lastBlackhole = now;
                    }
                    // 2. 광역 폭발 (데미지 감소)
                    if (now - character.lastExplosion > (character.explosionCooldown || 12000)) {
                        this.createExplosion(character.x + character.width/2, character.y + character.height/2, 100, character.damage * 0.8, character.id);
                        this.createFloatingText(character.x + character.width/2, character.y-20, '광역 폭발!', 'red');
                        character.lastExplosion = now;
                    }
                    // 3. 플레이어 둔화 (효과 감소, 중복 방지)
                    if (now - character.lastSlow > (character.slowCooldown || 10000)) {
                        if (!player.isSlowed) {
                            player.isSlowed = true;
                            player.originalSpeed = player.speed;
                            player.speed = Math.max(2, player.speed * 0.7); // 둔화 효과 감소
                            this.createFloatingText(player.x + player.width/2, player.y-20, '둔화!', 'blue');
                            setTimeout(() => { 
                                player.speed = player.originalSpeed || 5; 
                                player.isSlowed = false;
                            }, character.slowDuration || 3000);
                        }
                        character.lastSlow = now;
                    }
                }
                if (character.type === 'boss_epsilon') {
                    // 1. 분신 생성
                    if (!character.hasCloned && now - character.lastClone > character.cloneCooldown) {
                        for (let i = 0; i < character.clones; i++) {
                            const clone = this.createEnemy('boss_epsilon');
                            clone.health = Math.floor(character.health * 0.3);
                            clone.x = character.x + (Math.random() - 0.5) * 120;
                            clone.y = character.y + (Math.random() - 0.5) * 120;
                            this.gameState.enemies.push(clone);
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, '분신!', 'yellow');
                        character.hasCloned = true;
                        character.lastClone = now;
                    }
                    // 2. 탄환 반사
                    if (!character.isReflecting && now - character.lastReflect > character.reflectCooldown) {
                        character.isReflecting = true;
                        this.createFloatingText(character.x + character.width/2, character.y-20, '탄환 반사!', 'cyan');
                        setTimeout(() => { character.isReflecting = false; }, character.reflectDuration);
                        character.lastReflect = now;
                    }
                    // 3. 체력 흡수
                    if (now - character.lastDrain > character.drainCooldown) {
                        player.health = Math.max(0, player.health - character.drainAmount);
                        character.health = Math.min(character.maxHealth, character.health + character.drainAmount);
                        this.createFloatingText(player.x + player.width/2, player.y-20, `-${character.drainAmount} 흡수!`, 'purple');
                        this.createFloatingText(character.x + character.width/2, character.y-20, `+${character.drainAmount} 흡수!`, 'purple');
                        character.lastDrain = now;
                    }
                }
                if (character.type === 'boss_zeta') {
                    // 1. 시간 왜곡(슬로우) - 쿨다운 증가
                    if (!character.isTimeWarp && now - character.lastTimeWarp > (character.timeWarpCooldown || 12000)) {
                        this.gameState.timeSlowEffect = 0.6; // 효과 감소
                        character.isTimeWarp = true;
                        this.createFloatingText(character.x + character.width/2, character.y-20, '시간 왜곡!', 'blue');
                        setTimeout(() => {
                            this.gameState.timeSlowEffect = 1;
                            character.isTimeWarp = false;
                        }, character.timeWarpDuration || 2000);
                        character.lastTimeWarp = now;
                    }
                    // 2. 연발 사격 - 데미지 감소
                    if (!character.isRapidFire && now - character.lastRapidFire > (character.rapidFireCooldown || 10000)) {
                        character.isRapidFire = true;
                        this.createFloatingText(character.x + character.width/2, character.y-20, '연발 사격!', 'orange');
                        let shots = 0;
                        const rapid = () => {
                            if (shots < 8) { // 발사 수 감소
                                const angle = Math.atan2(player.y - character.y, player.x - character.x) + (Math.random()-0.5)*0.3;
                                this.gameState.projectiles.push({
                                    id: Date.now() + Math.random(),
                                    x: character.x + character.width / 2,
                                    y: character.y + character.height / 2,
                                    vx: Math.cos(angle) * 10, // 속도 감소
                                    vy: Math.sin(angle) * 10,
                                    radius: 4, // 크기 감소
                                    damage: character.damage * 0.5, // 데미지 감소
                                    life: 80,
                                    color: character.color,
                                    ownerId: character.id
                                });
                                shots++;
                                setTimeout(rapid, 120); // 발사 간격 증가
                            } else {
                                character.isRapidFire = false;
                            }
                        };
                        rapid();
                        character.lastRapidFire = now;
                    }
                    // 3. 랜덤 위치 이동 - 쿨다운 증가
                    if (now - character.lastRandomMove > (character.randomMoveCooldown || 15000)) {
                        character.x = Math.random() * (this.canvas.width - character.width);
                        character.y = Math.random() * (this.canvas.height - this.GROUND_Y - character.height);
                        this.createCollectParticles(character.x, character.y, character.color);
                        this.createFloatingText(character.x + character.width/2, character.y-20, '순간이동!', 'cyan');
                        character.lastRandomMove = now;
                    }
                }
                if (character.type === 'boss_eta') {
                    // 1. 레이저 (데미지 감소, 쿨다운 증가)
                    if (now - character.lastLaser > (character.laserCooldown || 12000)) {
                        const angle = Math.atan2(player.y - character.y, player.x - character.x);
                        for (let d = 60; d < 300; d += 50) { // 범위 감소
                            const lx = character.x + character.width/2 + Math.cos(angle) * d;
                            const ly = character.y + character.height/2 + Math.sin(angle) * d;
                            this.createExplosion(lx, ly, 30, character.damage * 0.8, character.id); // 데미지 감소
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, '레이저!', 'red');
                        character.lastLaser = now;
                    }
                    // 2. 연속 점프 (점프 수 감소)
                    if (now - character.lastJump > (character.jumpCooldown || 10000)) {
                        let jumpIdx = 0;
                        const jump = () => {
                            if (jumpIdx < (character.jumpCount || 2)) { // 점프 수 감소
                                character.vy = -(character.jumpPower || 20);
                                this.createFloatingText(character.x + character.width/2, character.y-20, '점프!', 'lime');
                                jumpIdx++;
                                setTimeout(jump, 500); // 간격 증가
                            }
                        };
                        jump();
                        character.lastJump = now;
                    }
                    // 3. 방어력 증가 (효과 감소)
                    if (!character.isArmorBuffed && now - character.lastArmorBuff > (character.armorBuffCooldown || 15000)) {
                        character.armor = (character.armor || 0) + 10; // 방어력 감소
                        character.isArmorBuffed = true;
                        this.createFloatingText(character.x + character.width/2, character.y-20, '방어력 증가!', 'blue');
                        setTimeout(() => {
                            character.armor = (character.armor || 0) - 10;
                            character.isArmorBuffed = false;
                        }, character.armorBuffDuration || 3000);
                        character.lastArmorBuff = now;
                    }
                }
                if (character.type === 'boss_theta') {
                    // 1. 발사체 반사 (강화)
                    if (!character.isReflecting && now - character.lastReflectAll > (character.reflectAllCooldown || 8000)) {
                        character.isReflecting = true;
                        this.createFloatingText(character.x + character.width/2, character.y-20, '발사체 반사!', 'cyan');
                        setTimeout(() => { character.isReflecting = false; }, character.reflectAllDuration || 3000);
                        character.lastReflectAll = now;
                    }
                    // 2. 도탄 탄환 (강화)
                    if (now - character.lastRicochet > (character.ricochetCooldown || 6000)) {
                        for (let i = 0; i < (character.ricochetCount || 6); i++) {
                            const angle = (Math.PI * 2) * (i / (character.ricochetCount || 6));
                            this.gameState.projectiles.push({
                                id: Date.now() + Math.random(),
                                x: character.x + character.width / 2,
                                y: character.y + character.height / 2,
                                vx: Math.cos(angle) * 12,
                                vy: Math.sin(angle) * 12,
                                radius: 6,
                                damage: character.damage * 0.8,
                                life: 150,
                                color: character.color,
                                ownerId: character.id,
                                bounceCount: 5
                            });
                        }
                        this.createFloatingText(character.x + character.width/2, character.y-20, '도탄 탄환!', 'orange');
                        character.lastRicochet = now;
                    }
                    // 3. 플레이어 위치 추적 (강화)
                    if (!character.isTracking && now - character.lastTrack > (character.trackCooldown || 10000)) {
                        character.isTracking = true;
                        this.createFloatingText(character.x + character.width/2, character.y-20, '위치 추적!', 'purple');
                        // 추적 중에는 플레이어를 향해 빠르게 이동
                        const trackInterval = setInterval(() => {
                            if (!character.isTracking) {
                                clearInterval(trackInterval);
                                return;
                            }
                            const dx = player.x - character.x;
                            const dy = player.y - character.y;
                            const angle = Math.atan2(dy, dx);
                            character.vx += Math.cos(angle) * 2;
                            character.vy += Math.sin(angle) * 2;
                        }, 100);
                        setTimeout(() => { 
                            character.isTracking = false;
                            clearInterval(trackInterval);
                        }, character.trackDuration || 4000);
                        character.lastTrack = now;
                    }
                    // 4. 새로운 능력: 시간 역행 (플레이어의 능력을 일시적으로 되돌림)
                    if (now - character.lastTimeReverse > (character.timeReverseCooldown || 20000)) {
                        this.createFloatingText(character.x + character.width/2, character.y-20, '시간 역행!', 'purple');
                        // 플레이어의 능력을 일시적으로 되돌림
                        const originalSpeed = player.speed;
                        const originalDamage = player.baseDamage;
                        player.speed = Math.max(2, player.speed * 0.5);
                        player.baseDamage = Math.max(5, player.baseDamage * 0.7);
                        this.createFloatingText(player.x + player.width/2, player.y-20, '능력 약화!', 'red');
                        setTimeout(() => {
                            player.speed = originalSpeed;
                            player.baseDamage = originalDamage;
                            this.createFloatingText(player.x + player.width/2, player.y-20, '능력 회복!', 'green');
                        }, 5000);
                        character.lastTimeReverse = now;
                    }
                }
            }
            
            // 발사체 상태 업데이트 및 충돌 감지 (유령 무적 상태 처리 추가)
            updateProjectiles = () => {
                // Homing logic: adjust velocity of homing projectiles
                for (let i = 0; i < this.gameState.projectiles.length; i++) {
                    const p = this.gameState.projectiles[i];
                    if (p.isHoming) {
                        let nearest = null, minDist = 99999;
                        for (const enemy of this.gameState.enemies) {
                            const dx = enemy.x + enemy.width/2 - p.x;
                            const dy = enemy.y + enemy.height/2 - p.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist < minDist) { minDist = dist; nearest = enemy; }
                        }
                        // Homing parameters
                        const maxTurn = (p.homingStrength || 0.08) * Math.PI; // 최대 회전 각도 (라디안)
                        const speed = Math.sqrt(p.vx*p.vx + p.vy*p.vy) || 8;
                        if (nearest) {
                            const dx = nearest.x + nearest.width/2 - p.x;
                            const dy = nearest.y + nearest.height/2 - p.y;
                            const targetAngle = Math.atan2(dy, dx);
                            let currentAngle = Math.atan2(p.vy, p.vx);
                            let delta = targetAngle - currentAngle;
                            // -PI ~ PI로 보정
                            while (delta > Math.PI) delta -= 2*Math.PI;
                            while (delta < -Math.PI) delta += 2*Math.PI;
                            // 회전 각도 제한
                            if (Math.abs(delta) > maxTurn) delta = maxTurn * Math.sign(delta);
                            const newAngle = currentAngle + delta;
                            p.vx = Math.cos(newAngle) * speed;
                            p.vy = Math.sin(newAngle) * speed;
                        } else {
                            // 적이 없으면 기존 방향/속도 유지 (정지하지 않음)
                            // 아무것도 하지 않음
                        }
                    }
                }
                const projectilesToRemove = new Set();
                const player = this.gameState.player;
                // 1. 발사체 이동/수명
                for (let i = 0; i < this.gameState.projectiles.length; i++) {
                    const p = this.gameState.projectiles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life--;
                    if (
                        p.x < -100 || p.x > this.canvas.width + 100 ||
                        p.y < -100 || p.y > this.canvas.height + 100 ||
                        p.life <= 0
                    ) {
                        projectilesToRemove.add(i);
                        continue;
                    }
                }
                // 2. 플레이어 발사체 → 적 충돌
                for (let i = 0; i < this.gameState.projectiles.length; i++) {
                    const p = this.gameState.projectiles[i];
                    if (p.ownerId === 'player' || p.ownerId === 'player2') {
                        if (p.ownerId === 'player2') {
                            console.log('플레이어2 발사체 충돌 체크:', p);
                        }
                        for (let j = 0; j < this.gameState.enemies.length; j++) {
                            const enemy = this.gameState.enemies[j];
                            if (!enemy) continue;
                            const dx = p.x - (enemy.x + enemy.width / 2);
                            const dy = p.y - (enemy.y + enemy.height / 2);
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < (p.radius || 0) + (enemy.width || 0) / 2) {
                                // 유령/보스 쉴드 무적 체크
                                if (enemy.type === 'ghost' && enemy.isInvincible) continue;
                                if (enemy.type === 'boss_beta' && enemy.isInvincible) continue;
                                
                                // 반사 적 반사 체크
                                if (enemy.type === 'reflector' && Math.random() < (enemy.reflectChance || 0.3)) {
                                    // 탄환을 반사시킴 (90% 데미지로)
                                    const reflectedDamage = Math.floor(p.damage * 0.9);
                                    const angle = Math.atan2(p.vy, p.vx);
                                    const reflectedAngle = angle + Math.PI + (Math.random() - 0.5) * Math.PI / 2;
                                    
                                    this.gameState.projectiles.push({
                                        id: Date.now() + Math.random(),
                                        x: enemy.x + enemy.width / 2,
                                        y: enemy.y + enemy.height / 2,
                                        vx: Math.cos(reflectedAngle) * 6,
                                        vy: Math.sin(reflectedAngle) * 6,
                                        radius: p.radius,
                                        damage: reflectedDamage,
                                        life: 60,
                                        color: '#ff6b6b',
                                        ownerId: 'enemy',
                                        pierceCount: 0,
                                        explosiveRadius: 0,
                                        bounceCount: 0,
                                        isHoming: false,
                                        homingStrength: 0,
                                        splitCount: 0,
                                        hitEnemies: []
                                    });
                                    
                                    this.createFloatingText(enemy.x + enemy.width / 2, enemy.y, '반사!', 'orange');
                                    projectilesToRemove.add(i);
                                    continue;
                                }
                                
                                enemy.health -= p.damage;
                                // 치명타 시각적 피드백
                                if (p.isCritical) {
                                    this.createFloatingText(enemy.x + enemy.width / 2, enemy.y, `-${p.damage} 치명타!`, '#ff0000'); // 빨간색으로 치명타 표시
                                    this.createFloatingText(enemy.x + enemy.width / 2, enemy.y - 20, '💥', '#ff0000'); // 치명타 이모지
                                } else {
                                    this.createFloatingText(enemy.x + enemy.width / 2, enemy.y, `-${p.damage}`, 'white');
                                }
                                this.createHitParticles(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                                // 폭발 사격
                                if (p.explosiveRadius && p.explosiveRadius > 0) {
                                    this.createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, p.explosiveRadius, p.damage, p.ownerId);
                                }
                                // 분열 사격
                                if (p.splitCount && p.splitCount > 0) {
                                    this.createSplitProjectiles(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, p.damage, p.ownerId, p.radius, p.splitCount);
                                }
                                if (enemy.health <= 0) {
                                    this.addScore(enemy.points || 100);
                                    if (Math.random() < 0.4) this.gameState.items.push(this.createItem(enemy.x, enemy.y));
                                    // 폭발 적 사망 시 폭발
                                    if (enemy.type === 'exploder') {
                                        this.createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2, enemy.explodeRadius || 70, enemy.damage, enemy.id);
                                        this.createFloatingText(enemy.x + enemy.width/2, enemy.y-20, '폭발!', 'orange');
                                    }
                                    // === 보스 사망 처리 추가 ===
                                    if (enemy.type && enemy.type.startsWith('boss')) {
                                        if (this.bossSystem && this.bossSystem.currentBoss && this.bossSystem.currentBoss.id === enemy.id) {
                                            this.bossSystem.currentBoss = null;
                                        }
                                        this.checkBossWaveComplete(); // ← 먼저 호출
                                        this.resetBossSystem();
                                    }
                                    // =========================
                                    this.gameState.enemies = this.gameState.enemies.filter(e => e !== enemy);
                                }
                                projectilesToRemove.add(i);
                                break;
                            }
                        }
                    }
                }
                // 3. 적 발사체 → 플레이어 충돌
                for (let i = 0; i < this.gameState.projectiles.length; i++) {
                    const p = this.gameState.projectiles[i];
                    // Only enemy bullets (not player, player2, ally, or any player-owned projectiles) can hit the player
                    if (p.ownerId && p.ownerId !== 'player' && p.ownerId !== 'player2' && p.ownerId !== 'ally') {
                        // 플레이어1 충돌 체크
                        const dx = p.x - (player.x + player.width / 2);
                        const dy = p.y - (player.y + player.height / 2);
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < (p.radius || 0) + (player.width || 0) / 2) {
                            // 무적 체크
                            if (Date.now() < player.invincibleEndTime) {
                                this.createFloatingText(player.x + player.width / 2, player.y, `무적!`, 'gold');
                            } else {
                                let actualDamage = p.damage;
                                actualDamage = Math.max(0, actualDamage - player.armor);
                                if (Date.now() < player.shieldBoostEndTime) {
                                    actualDamage *= player.damageReductionFactor;
                                    this.createFloatingText(player.x + player.width / 2, player.y, `-${actualDamage.toFixed(0)} (쉴드)`, 'lightblue');
                                } else {
                                    this.createFloatingText(player.x + player.width / 2, player.y, `-${actualDamage.toFixed(0)}`, 'red');
                                }
                                player.health -= actualDamage;
                                this.createHitParticles(player.x + player.width / 2, player.y + player.height / 2);
                                player.lastHitById = p.ownerId;
                                
                                // 슬라임병 느려지는 효과
                                if (p.slowEffect && p.slowDuration) {
                                    player.speed *= p.slowEffect;
                                    this.createFloatingText(player.x + player.width / 2, player.y - 30, '느려짐!', 'lightblue');
                                    setTimeout(() => {
                                        player.speed = this.ENEMY_TYPES[player.type]?.speed || 5;
                                    }, p.slowDuration);
                                }
                                
                                if (player.health <= 0) {
                                    if (this.gameState.multiplayerMode) {
                                        this.handlePlayerDeath('player1');
                                    } else {
                                        this.gameOver();
                                    }
                                }
                            }
                            projectilesToRemove.add(i);
                        }
                        
                        // 플레이어2 충돌 체크 (멀티플레이 모드일 때만)
                        if (this.gameState.player2 && this.gameState.multiplayerMode && !this.gameState.player2Dead) {
                            const dx2 = p.x - (this.gameState.player2.x + this.gameState.player2.width / 2);
                            const dy2 = p.y - (this.gameState.player2.y + this.gameState.player2.height / 2);
                            const dist2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                            if (dist2 < (p.radius || 0) + (this.gameState.player2.width || 0) / 2) {
                                // 무적 체크
                                if (Date.now() < this.gameState.player2.invincibleEndTime) {
                                    this.createFloatingText(this.gameState.player2.x + this.gameState.player2.width / 2, this.gameState.player2.y, `무적!`, 'gold');
                                } else {
                                    let actualDamage = p.damage;
                                    actualDamage = Math.max(0, actualDamage - this.gameState.player2.armor);
                                    if (Date.now() < this.gameState.player2.shieldBoostEndTime) {
                                        actualDamage *= this.gameState.player2.damageReductionFactor;
                                        this.createFloatingText(this.gameState.player2.x + this.gameState.player2.width / 2, this.gameState.player2.y, `-${actualDamage.toFixed(0)} (쉴드)`, 'lightblue');
                                    } else {
                                        this.createFloatingText(this.gameState.player2.x + this.gameState.player2.width / 2, this.gameState.player2.y, `-${actualDamage.toFixed(0)}`, 'red');
                                    }
                                    this.gameState.player2.health -= actualDamage;
                                    this.createHitParticles(this.gameState.player2.x + this.gameState.player2.width / 2, this.gameState.player2.y + this.gameState.player2.height / 2);
                                    this.gameState.player2.lastHitById = p.ownerId;
                                    
                                    // 슬라임병 느려지는 효과
                                    if (p.slowEffect && p.slowDuration) {
                                        this.gameState.player2.speed *= p.slowEffect;
                                        this.createFloatingText(this.gameState.player2.x + this.gameState.player2.width / 2, this.gameState.player2.y - 30, '느려짐!', 'lightblue');
                                        setTimeout(() => {
                                            this.gameState.player2.speed = 5;
                                        }, p.slowDuration);
                                    }
                                    
                                    if (this.gameState.player2.health <= 0) {
                                        this.handlePlayerDeath('player2');
                                    }
                                }
                                projectilesToRemove.add(i);
                            }
                        }
                    }
                }
                // 4. 발사체끼리 충돌(플레이어 vs 적)
                for (let i = 0; i < this.gameState.projectiles.length; i++) {
                    const p1 = this.gameState.projectiles[i];
                    if (p1.ownerId === 'player' || p1.ownerId === 'player2') {
                        for (let j = 0; j < this.gameState.projectiles.length; j++) {
                            if (i === j) continue;
                            const p2 = this.gameState.projectiles[j];
                            if (p2.ownerId && p2.ownerId !== 'player' && p2.ownerId !== 'ally') {
                                const dx = p1.x - p2.x;
                                const dy = p1.y - p2.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist < (p1.radius || 0) + (p2.radius || 0)) {
                                    projectilesToRemove.add(i);
                                    projectilesToRemove.add(j);
                                }
                            }
                        }
                    }
                }
                // 실제로 제거
                this.gameState.projectiles = this.gameState.projectiles.filter((_, idx) => !projectilesToRemove.has(idx));
            };

            // 분열 사격 (Split Shot) 시 작은 발사체 생성
            createSplitProjectiles = (x, y, baseDamage, ownerId, parentRadius, splitLevel) => {
                const numSplits = 3 + splitLevel; // 레벨에 따라 분열되는 작은 탄환 수 증가
                const splitSpeed = 5; // 작은 탄환 속도
                const splitDamage = baseDamage * 0.5; // 작은 탄환 데미지 (원본의 절반)
                const splitRadius = parentRadius / 1.5; // 작은 탄환 반지름

                for (let i = 0; i < numSplits; i++) {
                    const splitAngle = Math.random() * Math.PI * 2; // 무작위 방향
                    this.gameState.projectiles.push({
                        id: Date.now() + Math.random(),
                        x: x,
                        y: y,
                        vx: Math.cos(splitAngle) * splitSpeed,
                        vy: Math.sin(splitAngle) * splitSpeed,
                        radius: 3, // 기존 7에서 4로 하향
                        damage: splitDamage,
                        life: 60, // 짧은 수명
                        color: '#9932cc', // 분열 사격 색상
                        ownerId: ownerId,
                        pierceCount: 0,
                        explosiveRadius: 0,
                        bounceCount: 0,
                        isHoming: false,
                        homingStrength: 0,
                        splitCount: 0, // 분열된 탄환은 다시 분열하지 않음
                        hitEnemies: []
                    });
                }
            }

            // 폭발 효과 생성 (수류탄 폭발에만 사용됨)
            createExplosion = (x, y, radius, damage, ownerId) => { // ownerId 추가
                // 파티클 생성
                for (let i = 0; i < 30; i++) {
                    this.gameState.particles.push({
                        x: x, y: y,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        life: 40, maxLife: 40,
                        color: '#ff4500', // 주황색 폭발 색상
                        size: Math.random() * 5 + 2
                    });
                }

                // 플레이어에게 범위 피해 적용 (수류탄 폭발에만 해당)
                const player = this.gameState.player;
                let dx = x - (player.x + player.width / 2);
                let dy = y - (player.y + player.height / 2);
                let distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < radius + player.width / 2) {
                    // 플레이어 무적 상태 체크
                    if (Date.now() < player.invincibleEndTime) {
                        this.createFloatingText(player.x + player.width / 2, player.y, `무적!`, 'gold');
                    } else {
                        // 플레이어가 발사한 수류탄 폭발에는 피해를 입지 않도록
                        if (ownerId === 'player') {
                            this.createFloatingText(player.x + player.width / 2, player.y, `회피!`, 'cyan');
                            // 수류탄 폭발에 의한 사망은 기록하지 않음
                            return; 
                        }

                        let actualDamage = damage;
                        // 방어력 적용
                        actualDamage = Math.max(0, actualDamage - this.gameState.player.armor);
                        if (Date.now() < player.shieldBoostEndTime) {
                            actualDamage *= player.damageReductionFactor;
                            this.createFloatingText(player.x + player.width / 2, player.y, `-${actualDamage.toFixed(0)} (쉴드)`, 'lightblue');
                        } else {
                            this.createFloatingText(player.x + player.width / 2, player.y, `-${actualDamage.toFixed(0)}`, 'red'); // 데미지 텍스트
                        }
                        player.health -= actualDamage;
                        this.createHitParticles(player.x + player.width / 2, player.y + player.height / 2);
                        
                        // 폭발로 인한 피해일 경우 마지막 피해자 ID 저장 (수류탄이 아닌 다른 폭발에 대비)
                        this.gameState.player.lastHitById = ownerId;

                        if (player.health <= 0) {
                            if (this.gameState.multiplayerMode) {
                                this.handlePlayerDeath('player1');
                            } else {
                                this.gameOver();
                            }
                        }
                        
                        // 플레이어2 체력 체크 (멀티플레이 모드일 때만)
                        if (this.gameState.player2 && this.gameState.multiplayerMode && this.gameState.player2.health <= 0) {
                            this.handlePlayerDeath('player2');
                        }
                    }
                }

                // 적들에게 범위 피해 적용 (수류탄 폭발에만 해당)
                this.gameState.enemies.forEach(enemy => {
                    dx = x - (enemy.x + enemy.width / 2);
                    dy = y - (enemy.y + enemy.height / 2);
                    distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < radius + enemy.width / 2) {
                        // 유령 무적 상태 체크
                        if (enemy.type === 'ghost' && enemy.isInvincible) return;
                        // 베타 보스 쉴드 체크
                        if (enemy.type === 'boss_beta' && enemy.isInvincible) return;
                        // 방패병 방어 체크 (폭발은 전방/후방 상관없이 피해)
                        if (enemy.type === 'shielded') {
                            enemy.health -= damage * 0.5; // 방패병은 폭발 피해 50% 감소
                            this.createFloatingText(enemy.x + enemy.width / 2, enemy.y, `-${(damage * 0.5).toFixed(0)} (방어)`, 'orange');
                        } else {
                            enemy.health -= damage; // 적에게도 동일한 폭발 데미지
                            this.createFloatingText(enemy.x + enemy.width / 2, enemy.y, `-${damage}`, 'white');
                        }
                        this.createHitParticles(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                        if (enemy.health <= 0) {
                            // 적 처치 로직 (점수, 아이템 드롭 등)
                            this.addScore(enemy.points || 100);
                            if (Math.random() < 0.4) this.gameState.items.push(this.createItem(enemy.x, enemy.y));
                            

                            
                            this.gameState.enemies = this.gameState.enemies.filter(e => e.id !== enemy.id);
                        }
                    }
                });

                // 아군에게 범위 피해 적용
                this.gameState.allies.forEach(ally => {
                    dx = x - (ally.x + ally.width / 2);
                    dy = y - (ally.y + ally.height / 2);
                    distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < radius + ally.width / 2) {
                         // 아군이 발사한 수류탄 폭발에는 피해를 입지 않도록
                        if (ownerId === ally.id) {
                            this.createFloatingText(ally.x + ally.width / 2, ally.y, `회피!`, 'cyan');
                            return; 
                        }

                        ally.health -= damage;
                        this.createFloatingText(ally.x + ally.width / 2, ally.y, `-${damage}`, 'orange');
                        this.createHitParticles(ally.x + ally.width / 2, ally.y + ally.height / 2);
                        if (ally.health <= 0) {
                            this.gameState.allies = this.gameState.allies.filter(a => a.id !== ally.id);
                            this.createFloatingText(ally.x + ally.width / 2, ally.y, `사망!`, 'grey');
                        }
                    }
                });
            }
            
            // 아이템 상태 업데이트 및 플레이어 충돌 감지
            updateItems = () => {
                const player = this.gameState.player;
                const now = Date.now();

                // 자석 효과 적용
                if (now < player.magnetEndTime) {
                    this.gameState.items.forEach(item => {
                        const dx = (player.x + player.width / 2) - (item.x + item.width / 2);
                        const dy = (player.y + player.height / 2) - (item.y + item.height / 2);
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < player.magnetRadius) {
                            const force = 0.5; // 자석 힘
                            item.vx += (dx / distance) * force;
                            item.vy += (dy / distance) * force;
                        }
                    });
                }


                this.gameState.items = this.gameState.items.filter(item => {
                    if (item.collected) return false; // 이미 수집된 아이템은 제거
                    
                    // 중력 적용
                    if (!item.onGround) {
                        item.vy += this.GRAVITY;
                    }
                    
                    // 지면 충돌 처리 (바운스 효과)
                    if (item.y + item.height > this.canvas.height - this.GROUND_Y) {
                        item.y = this.canvas.height - this.GROUND_Y - item.height;
                        item.vy = -item.vy * 0.5; // 바운스 효과
                        if (Math.abs(item.vy) < 2) {
                            item.vy = 0;
                            item.onGround = true;
                        }
                    }
                    
                    // 위치 업데이트
                    item.x += item.vx;
                    item.y += item.vy;
                    
                    // 마찰 적용
                    item.vx *= 0.98;
                    
                    // 화면 경계 제한
                    item.x = Math.max(0, Math.min(this.canvas.width - item.width, item.x));
                    
                    // 지면에 있을 때만 떠다니는 애니메이션
                    if (item.onGround) {
                        item.y += Math.sin(Date.now() * 0.003 + item.bobOffset) * 1;
                    }
                    
                    // 플레이어와 충돌 체크
                    if (player.x < item.x + item.width &&
                        player.x + player.width > item.x &&
                        player.y < item.y + item.height &&
                        player.y + player.height > item.y) {
                        
                        this.collectItem(item); // 아이템 수집
                        return false; // 아이템 제거
                    }
                    
                    // 플레이어2와 충돌 체크 (멀티플레이 모드일 때만)
                    if (this.gameState.player2 && this.gameState.multiplayerMode) {
                        const player2 = this.gameState.player2;
                        if (player2.x < item.x + item.width &&
                            player2.x + player2.width > item.x &&
                            player2.y < item.y + item.height &&
                            player2.y + player2.height > item.y) {
                            
                            this.collectItemPlayer2(item); // 플레이어2 아이템 수집
                            return false; // 아이템 제거
                        }
                    }
                    
                    return true; // 아이템 유지
                });
            }
            
            // 플레이어2 아이템 수집 시 효과 적용
            collectItemPlayer2 = (item) => {
                const player2 = this.gameState.player2;
                const now = Date.now();
                
                switch (item.type) {
                    case 'health':
                        player2.health = Math.min(player2.maxHealth, player2.health + item.effect);
                        this.createFloatingText(player2.x + player2.width / 2, player2.y, `+${item.effect}`, 'green');
                        this.showMessage(`P2 +${item.effect} 체력!`, '', 1500);
                        break;
                    case 'ammo':
                        player2.ammo = Math.min(player2.maxAmmo, player2.ammo + item.effect);
                        this.createFloatingText(player2.x + player2.width / 2, player2.y, `+${item.effect}`, 'blue');
                        this.showMessage(`P2 +${item.effect} 탄약!`, '', 1500);
                        break;
                    case 'speed':
                        player2.speed = Math.min(10, player2.speed + item.effect);
                        this.showMessage(`P2 속도 증가!`, `+${item.effect}`, 1500);
                        break;
                    case 'shield':
                        player2.maxHealth += item.effect;
                        player2.health = Math.min(player2.maxHealth, player2.health + item.effect);
                        this.showMessage(`P2 방어막 강화!`, `+${item.effect} 최대 체력`, 1500);
                        break;
                    case 'damage':
                        player2.baseDamage = (player2.baseDamage || 25) + item.effect;
                        this.showMessage(`P2 공격력 증가!`, `+${item.effect} 데미지`, 1500);
                        break;
                    case 'multishot':
                        player2.multishot = Math.min(99, (player2.multishot || 1) + 1);
                        this.showMessage(`P2 다중 발사!`, `${player2.multishot}발 동시 발사`, 2000);
                        break;
                    case 'megahealth':
                        player2.health = Math.min(player2.maxHealth, player2.health + item.effect);
                        this.createFloatingText(player2.x + player2.width / 2, player2.y, `+${item.effect}`, 'lime');
                        this.showMessage(`P2 메가 힐링!`, `+${item.effect} 체력`, 2000);
                        break;
                    case 'rapid':
                        player2.rapidFireTime = (Date.now() + 10000);
                        this.showMessage(`P2 연발 모드!`, '10초간 빠른 발사', 2000);
                        break;
                    case 'invincibility':
                        player2.invincibleEndTime = now + item.effect;
                        this.showMessage(`P2 무적!`, `${item.effect / 1000}초간 무적`, 2000);
                        break;
                    case 'shield_boost':
                        player2.shieldBoostEndTime = now + item.duration;
                        player2.damageReductionFactor = item.effect;
                        this.showMessage(`P2 쉴드 강화!`, `받는 피해 ${item.effect * 100}% 감소`, 2000);
                        break;
                    case 'time_slow':
                        this.gameState.timeSlowEndTime = now + item.duration;
                        this.gameState.timeSlowEffect = item.effect;
                        this.showMessage(`P2 시간 둔화!`, `모든 적 느려짐`, 2000);
                        break;
                    case 'magnet':
                        player2.magnetEndTime = now + item.duration;
                        this.showMessage(`P2 자석!`, `아이템을 끌어당깁니다`, 2000);
                        break;
                    case 'health_regen':
                        player2.healthRegenEndTime = now + item.duration;
                        player2.lastRegenTick = now;
                        player2.effect = item.effect;
                        player2.tickInterval = item.tickInterval;
                        this.showMessage(`P2 체력 재생!`, `${item.duration / 1000}초간 체력 회복`, 2000);
                        break;
                    case 'ally_summon':
                        this.showMessage(`P2 아군 소환!`, `든든한 아군이 합류합니다!`, 2000);
                        this.spawnAlly(player2.x + (player2.width / 2), player2.y + (player2.height / 2));
                        break;
                    case 'orbiting_knife':
                        player2.orbitingKnives.push({
                            angle: Math.random() * Math.PI * 2,
                            radius: 60,
                            speed: 0.05,
                            damage: 15,
                            lastHit: 0,
                            cooldown: 200,
                            color: this.ITEM_TYPES.find(i => i.type === 'orbiting_knife').color,
                            emoji: this.ITEM_TYPES.find(i => i.type === 'orbiting_knife').emoji
                        });
                        this.showMessage(`P2 회전 칼날 획득!`, `플레이어 주위를 돕니다!`, 2000);
                        break;
                    case 'piercing_shot':
                        player2.piercingShot = Math.min(99, player2.piercingShot + item.effect);
                        this.showMessage(`P2 관통 사격!`, `탄환이 적을 관통합니다! (Lv.${player2.piercingShot})`, 2000);
                        break;
                    case 'explosive_shot':
                        player2.explosiveShot = Math.min(99, player2.explosiveShot + item.effect);
                        this.showMessage(`P2 폭발 사격!`, `탄환이 폭발합니다! (Lv.${player2.explosiveShot})`, 2000);
                        break;
                    case 'ricochet_shot':
                        player2.ricochetLevel = Math.min(99, player2.ricochetLevel + item.effect);
                        this.showMessage(`P2 도탄 사격!`, `탄환이 벽에서 튕겨 나갑니다! (Lv.${player2.ricochetLevel})`, 2000);
                        break;
                    case 'homing_shot':
                        player2.homingLevel = Math.min(99, player2.homingLevel + item.effect);
                        this.showMessage(`P2 유도 사격!`, `탄환이 적을 추적합니다! (Lv.${player2.homingLevel})`, 2000);
                        break;
                    case 'split_shot':
                        player2.splitLevel = Math.min(99, player2.splitLevel + item.effect);
                        this.showMessage(`P2 분열 사격!`, `탄환이 분열하여 추가 피해를 줍니다! (Lv.${player2.splitLevel})`, 2000);
                        break;
                    case 'life_steal':
                        player2.lifeStealPercent = Math.min(0.2, player2.lifeStealPercent + item.effect);
                        this.showMessage(`P2 생명력 흡수!`, `피해량의 ${(player2.lifeStealPercent * 100).toFixed(0)}% 체력 회복!`, 2000);
                        break;
                    case 'crit_chance':
                        player2.critChance = Math.min(0.5, player2.critChance + item.effect);
                        this.showMessage(`P2 치명타 확률!`, `치명타 확률 ${(player2.critChance * 100).toFixed(0)}%`, 2000);
                        break;
                    case 'cooldown_reduction':
                        player2.cooldownReduction = Math.min(0.5, player2.cooldownReduction + item.effect);
                        this.showMessage(`P2 재사용 대기시간 감소!`, `발사 속도 ${(player2.cooldownReduction * 100).toFixed(0)}% 증가!`, 2000);
                        break;
                    case 'armor':
                        player2.armor += item.effect;
                        this.showMessage(`P2 방어력!`, `피해량 ${item.effect} 감소!`, 2000);
                        break;
                    case 'time_stop':
                        this.gameState.timeStopEndTime = now + item.effect;
                        this.gameState.timeSlowEffect = 0;
                        this.showMessage(`P2 시간 정지!`, `${item.effect / 1000}초간 모든 적 정지!`, 2000);
                        break;
                    case 'ammo_regen':
                        player2.ammoRegenEndTime = now + item.duration;
                        player2.lastAmmoRegenTick = now;
                        player2.ammoRegenAmount = item.effect;
                        this.showMessage(`P2 탄약 재생!`, `${item.duration / 1000}초간 탄약 자동 회복!`, 2000);
                        break;
                    default:
                        break;
                }
            };

            // 아이템 수집 시 효과 적용
            collectItem = (item) => {
                const player = this.gameState.player;
                const now = Date.now();
                
                switch (item.type) {
                    case 'health':
                        player.health = Math.min(player.maxHealth, player.health + item.effect);
                        this.createFloatingText(player.x + player.width / 2, player.y, `+${item.effect}`, 'green'); // 체력 텍스트
                        this.showMessage(`+${item.effect} 체력!`, '', 1500);
                        break;
                    case 'ammo':
                        player.ammo = Math.min(player.maxAmmo, player.ammo + item.effect);
                        this.createFloatingText(player.x + player.width / 2, player.y, `+${item.effect}`, 'blue'); // 탄약 텍스트
                        this.showMessage(`+${item.effect} 탄약!`, '', 1500);
                        break;
                    case 'speed':
                        player.speed = Math.min(10, player.speed + item.effect);
                        this.showMessage(`속도 증가!`, `+${item.effect}`, 1500);
                        break;
                    case 'shield':
                        player.maxHealth += item.effect;
                        player.health = Math.min(player.maxHealth, player.health + item.effect); // 최대 체력 증가 시 현재 체력도 증가
                        this.showMessage(`방어막 강화!`, `+${item.effect} 최대 체력`, 1500);
                        break;
                    case 'damage':
                        player.baseDamage = (player.baseDamage || 25) + item.effect; // 기본 공격력 25로 수정 반영
                        this.showMessage(`공격력 증가!`, `+${item.effect} 데미지`, 1500);
                        break;
                    case 'multishot':
                        player.multishot = Math.min(99, (player.multishot || 1) + 1);
                        this.showMessage(`다중 발사!`, `${player.multishot}발 동시 발사`, 2000);
                        break;
                    case 'megahealth':
                        player.health = Math.min(player.maxHealth, player.health + item.effect);
                        this.createFloatingText(player.x + player.width / 2, player.y, `+${item.effect}`, 'lime'); // 메가 힐링 텍스트
                        this.showMessage(`메가 힐링!`, `+${item.effect} 체력`, 2000);
                        break;
                    case 'rapid':
                        player.rapidFireTime = (Date.now() + 10000); // 10초간 빠른 발사
                        this.showMessage(`연발 모드!`, '10초간 빠른 발사', 2000);
                        break;
                    case 'invincibility':
                        player.invincibleEndTime = now + item.effect;
                        this.showMessage(`무적!`, `${item.effect / 1000}초간 무적`, 2000);
                        break;
                    case 'grenade':
                        this.throwGrenade(); // 수류탄 투척
                        this.showMessage(`수류탄!`, `적들을 날려버리세요!`, 1500);
                        break;
                    case 'shield_boost':
                        player.shieldBoostEndTime = now + item.duration;
                        player.damageReductionFactor = item.effect;
                        this.showMessage(`쉴드 강화!`, `받는 피해 ${item.effect * 100}% 감소`, 2000);
                        break;
                    case 'time_slow':
                        this.gameState.timeSlowEndTime = now + item.duration;
                        this.gameState.timeSlowEffect = item.effect;
                        this.showMessage(`시간 둔화!`, `모든 적 느려짐`, 2000);
                        break;
                    case 'magnet':
                        player.magnetEndTime = now + item.duration;
                        this.showMessage(`자석!`, `아이템을 끌어당깁니다`, 2000);
                        break;
                    case 'health_regen':
                        player.healthRegenEndTime = now + item.duration;
                        player.lastRegenTick = now; // 첫 틱은 바로 적용
                        player.effect = item.effect; // 체력 재생량 저장
                        player.tickInterval = item.tickInterval; // 체력 재생 간격 저장
                        this.showMessage(`체력 재생!`, `${item.duration / 1000}초간 체력 회복`, 2000);
                        break;
                    case 'ally_summon':
                        this.showMessage(`아군 소환!`, `든든한 아군이 합류합니다!`, 2000);
                        this.spawnAlly(player.x + (player.width / 2), player.y + (player.height / 2)); // 플레이어 위치에 소환
                        break;
                    case 'orbiting_knife':
                        player.orbitingKnives.push({
                            angle: Math.random() * Math.PI * 2, // 초기 무작위 각도
                            radius: 60, // 플레이어로부터의 거리
                            speed: 0.05, // 각속도
                            damage: 15, // 칼날 공격력
                            lastHit: 0, // 마지막 공격 시간 (쿨다운용)
                            cooldown: 200, // 공격 쿨다운 (ms)
                            color: this.ITEM_TYPES.find(i => i.type === 'orbiting_knife').color, // 아이템 타입에서 색상 가져오기
                            emoji: this.ITEM_TYPES.find(i => i.type === 'orbiting_knife').emoji // 아이템 타입에서 이모지 가져오기
                        });
                        this.showMessage(`회전 칼날 획득!`, `플레이어 주위를 돕니다!`, 2000);
                        break;
                    case 'piercing_shot':
                        player.piercingShot = Math.min(99, player.piercingShot + item.effect);
                        this.showMessage(`관통 사격!`, `탄환이 적을 관통합니다! (Lv.${player.piercingShot})`, 2000);
                        break;
                    case 'explosive_shot':
                        player.explosiveShot = Math.min(99, player.explosiveShot + item.effect);
                        this.showMessage(`폭발 사격!`, `탄환이 폭발합니다! (Lv.${player.explosiveShot})`, 2000);
                        break;
                    case 'ricochet_shot':
                        player.ricochetLevel = Math.min(99, player.ricochetLevel + item.effect);
                        this.showMessage(`도탄 사격!`, `탄환이 벽에서 튕겨 나갑니다! (Lv.${player.ricochetLevel})`, 2000);
                        break;
                    case 'homing_shot':
                        player.homingLevel = Math.min(99, player.homingLevel + item.effect);
                        this.showMessage(`유도 사격!`, `탄환이 적을 추적합니다! (Lv.${player.homingLevel})`, 2000);
                        break;
                    case 'split_shot':
                        player.splitLevel = Math.min(99, player.splitLevel + item.effect);
                        this.showMessage(`분열 사격!`, `탄환이 분열하여 추가 피해를 줍니다! (Lv.${player.splitLevel})`, 2000);
                        break;
                    case 'life_steal':
                        player.lifeStealPercent = Math.min(0.2, player.lifeStealPercent + item.effect); // 최대 20%
                        this.showMessage(`생명력 흡수!`, `피해량의 ${(player.lifeStealPercent * 100).toFixed(0)}% 체력 회복!`, 2000);
                        break;
                    case 'crit_chance':
                        player.critChance = Math.min(0.5, player.critChance + item.effect); // 최대 50%
                        this.showMessage(`치명타 확률!`, `치명타 확률 ${(player.critChance * 100).toFixed(0)}%`, 2000);
                        break;
                    case 'cooldown_reduction':
                        player.cooldownReduction = Math.min(0.5, player.cooldownReduction + item.effect); // 최대 50%
                        this.showMessage(`재사용 대기시간 감소!`, `발사 속도 ${(player.cooldownReduction * 100).toFixed(0)}% 증가!`, 2000);
                        break;
                    case 'armor':
                        player.armor += item.effect;
                        this.showMessage(`방어력!`, `피해량 ${item.effect} 감소!`, 2000);
                        break;
                    case 'time_stop':
                        this.gameState.timeStopEndTime = now + item.effect;
                        this.gameState.timeSlowEffect = 0; // 모든 적 정지
                        this.showMessage(`시간 정지!`, `${item.effect / 1000}초간 모든 적 정지!`, 2000);
                        break;
                    case 'ammo_regen':
                        player.ammoRegenEndTime = now + item.duration;
                        player.lastAmmoRegenTick = now;
                        player.ammoRegenAmount = item.effect;
                        this.showMessage(`탄약 재생!`, `${item.duration / 1000}초간 탄약 자동 회복!`, 2000);
                        break;
                }
                
                this.createCollectParticles(item.x, item.y, item.color); // 아이템 수집 파티클 생성
                this.addScore(50); // 아이템 수집 시 점수 획득
                this.updateHUD(); // HUD 업데이트
            }
            
            // 피격 파티클 생성
            createHitParticles = (x, y) => {
                for (let i = 0; i < 6; i++) {
                    this.gameState.particles.push({
                        x: x, y: y,
                        vx: (Math.random() - 0.5) * 6, // 무작위 X 속도
                        vy: (Math.random() - 0.5) * 6, // 무작위 Y 속도
                        life: 30, maxLife: 30, // 수명
                        color: '#ff6b6b', // 색상 (빨간색)
                        size: Math.random() * 3 + 1 // 크기
                    });
                }
            }
            
            // 아이템 수집 파티클 생성
            createCollectParticles = (x, y, color) => {
                for (let i = 0; i < 8; i++) {
                    this.gameState.particles.push({
                        x: x, y: y,
                        vx: (Math.random() - 0.5) * 4, // 무작위 X 속도
                        vy: (Math.random() - 0.5) * 4, // 무작위 Y 속도
                        life: 40, maxLife: 40, // 수명
                        color: color, // 아이템 색상
                        size: Math.random() * 4 + 2 // 크기
                    });
                }
            }

            // 떠다니는 텍스트 생성 (체력 변화 등)
            createFloatingText = (x, y, text, color) => {
                this.gameState.floatingTexts.push({
                    x: x,
                    y: y,
                    text: text,
                    color: color,
                    life: 60, // 텍스트 수명 (프레임)
                    maxLife: 60,
                    vy: -1 // 위로 이동하는 속도
                });
            }
            
            // 파티클 상태 업데이트
            updateParticles = () => {
                this.gameState.particles = this.gameState.particles.filter(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vx *= 0.98; // 속도 감소 (마찰)
                    particle.vy *= 0.98; // 속도 감소 (마찰)
                    particle.life--; // 수명 감소
                    
                    return particle.life > 0; // 수명이 남은 파티클만 유지
                });
            }

            // 떠다니는 텍스트 상태 업데이트
            updateFloatingTexts = () => {
                this.gameState.floatingTexts = this.gameState.floatingTexts.filter(text => {
                    text.y += text.vy; // 위로 이동
                    text.life--; // 수명 감소
                    return text.life > 0; // 수명이 남은 텍스트만 유지
                });
            }
            
            // 웨이브 완료 체크 (새로운 보스 시스템)
            checkWaveComplete = () => {
                // 테스팅 존에서는 웨이브 완료 체크 안함
                if (this.gameMode === 'testzone') return;
                
                // 보스 웨이브 완료 체크
                if (this.gameState.wave % 10 === 0) {
                    this.checkBossWaveComplete();
                } else {
                    this.checkNormalWaveComplete();
                }
            }
            
            // 보스 웨이브 완료 체크
            checkBossWaveComplete = () => {
                // 보스가 모두 죽었고, 게임이 진행 중일 때
                const bossCount = this.gameState.enemies.filter(e => e.type && e.type.startsWith('boss')).length;
                if (this.bossSystem && this.bossSystem.isActive && bossCount === 0 && this.gameState.gameStatus === 'playing') {
                    this.completeWave();
                }
            }
            
            // 일반 웨이브 완료 체크
            checkNormalWaveComplete = () => {
                // 모든 적이 죽었고, 게임이 진행 중일 때
                if (this.gameState.enemies.length === 0 && this.gameState.gameStatus === 'playing') {
                    this.completeWave();
                }
            }
            
            // 웨이브 완료 처리
            completeWave = () => {
                this.gameState.gameStatus = 'wave-complete';
                this.showMessage(`웨이브 ${this.gameState.wave} 완료!`, '다음 웨이브 준비 중...', 3000);
                this.gameState.wave++;
                
                // 부활 시스템 체크 (멀티플레이 모드일 때만)
                if (this.gameState.multiplayerMode) {
                    this.checkRevivalSystem();
                }
                
                setTimeout(() => {
                    this.gameState.gameStatus = 'spawning';
                    this.spawnInitialWave();
                    this.gameState.gameStatus = 'playing';
                }, 3000);
            }

            // 부활 시스템 체크
            checkRevivalSystem = () => {
                // 플레이어1이 죽어있고 플레이어2가 살아있을 때
                if (this.gameState.player1Dead && !this.gameState.player2Dead) {
                    this.gameState.revivalWaveCount++;
                    if (this.gameState.revivalWaveCount >= 5) {
                        this.revivePlayer('player1');
                    } else {
                        this.showMessage(`플레이어1 부활까지`, `${5 - this.gameState.revivalWaveCount}웨이브 남음`, 2000);
                    }
                }
                // 플레이어2가 죽어있고 플레이어1이 살아있을 때
                else if (this.gameState.player2Dead && !this.gameState.player1Dead) {
                    this.gameState.revivalWaveCount++;
                    if (this.gameState.revivalWaveCount >= 5) {
                        this.revivePlayer('player2');
                    } else {
                        this.showMessage(`플레이어2 부활까지`, `${5 - this.gameState.revivalWaveCount}웨이브 남음`, 2000);
                    }
                }
            }
            
            // 보스 시스템 리셋
            resetBossSystem = () => {
                console.log('보스 시스템 리셋');
                if (this.bossSystem) {
                    this.bossSystem.isActive = false;
                    this.bossSystem.currentBoss = null;
                    this.bossSystem.spawnLock = false;
                }
                this.gameState.gameStatus = 'playing'; // 혹시라도 상태가 꼬였을 때 복구
                // 보스 체력바 숨기기
                const bossBarContainer = document.getElementById('bossBarContainer');
                if (bossBarContainer) {
                    bossBarContainer.style.display = 'none';
                }
                this.showMessage('보스 처치!', '훌륭한 전투였습니다!', 2000);
            }
                        
            // 게임 오버 처리
            gameOver = () => {
                this.gameState.gameStatus = 'game-over'; // 게임 상태를 '게임 오버'로 변경
                this.showMessage('게임 오버!', `최종 점수: ${this.gameState.score.toLocaleString()}`, 5000, true);
                // 어떤 적에게 죽었는지 콘솔에 출력
                const lastHitById = this.gameState.player.lastHitById;
                if (lastHitById) {
                    // lastHitById가 적의 ID일 경우 해당 적의 정보를 찾음
                    const killerEnemy = Object.values(this.ENEMY_TYPES).find(enemyType => 
                        this.gameState.enemies.some(enemy => enemy.id === lastHitById && enemy.type === enemyType.type)
                    );
                    if (killerEnemy) {
                        console.log(`플레이어가 '${killerEnemy.name}'에게 사망했습니다.`);
                    } else if (lastHitById === 'player') { // 플레이어 스스로에게 피해를 입은 경우 (수류탄 등)
                        console.log('플레이어가 스스로에게 피해를 입어 사망했습니다.');
                    } else {
                        console.log(`플레이어가 알 수 없는 적에게 사망했습니다 (ID: ${lastHitById}).`);
                    }
                } else {
                    console.log('플레이어가 적에게 직접적인 공격 없이 사망했습니다 (예: 낙사).');
                }
                // 5초 후 게임 재시작 (시작 화면으로 돌아가지 않음)
                const restartBtn = document.getElementById('restartButton');
                restartBtn.style.display = 'block';
                restartBtn.onclick = () => {
                    restartBtn.style.display = 'none';
                    this.resetGame();
                };
            }
            
            // 게임 초기화
            resetGame = () => {
                // 게임 상태를 초기값으로 재설정
                this.gameState = {
                    player: {
                        x: this.canvas.width / 2, y: this.canvas.height / 2,
                        width: 40, height: 40,
                        vx: 0, vy: 0,
                        health: 150, maxHealth: 150, // 기본값 100으로 변경
                        ammo: 30, maxAmmo: 30, // 기본값 100으로 변경
                        speed: 5, jumpPower: 15,
                        onGround: false, facing: 0,
                        expression: this.getRandomExpression(),
                        color: '#6366f1',
                        baseDamage: 10, // 기본값 10으로 변경
                        multishot: 1,
                        rapidFireTime: 0,
                        damageReductionFactor: 1,
                        shieldBoostEndTime: 0,
                        healthRegenEndTime: 0,
                        lastRegenTick: 0,
                        magnetEndTime: 0,
                        magnetRadius: 200,
                        lastHitById: null, // 초기화
                        type: 'player', // 플레이어 타입
                        orbitingKnives: [], // 회전 칼날 초기화
                        piercingShot: 0, // 관통 사격 초기화
                        explosiveShot: 0, // 폭발 사격 초기화
                        ricochetLevel: 0, // 도탄 사격 초기화
                        homingLevel: 0, // 유도 사격 초기화
                        splitLevel: 0, // 분열 사격 초기화
                        lifeStealPercent: 0, // 생명력 흡수 초기화
                        critChance: 0, // 치명타 확률 초기화
                        critMultiplier: 1.5, // 치명타 배율 초기화
                        cooldownReduction: 0, // 재사용 대기시간 감소 초기화
                        armor: 0, // 방어력 초기화
                        timeStopEndTime: 0, // 시간 정지 초기화
                        ammoRegenEndTime: 0, // 탄약 재생 초기화
                        lastAmmoRegenTick: 0, // 마지막 탄약 재생 틱 초기화
                        ammoRegenAmount: 0, // 탄약 재생량 초기화
                        dashCooldown: 0, // 마지막 대시 시각
                        dashEndTime: 0, // 대시 종료 시각
                        isDashing: false, // 대시 중 여부
                        reloadTime: 1500, // 기본 재장전 시간(ms)
                        isReloading: false,
                        machineGunMode: false, // 기관단총 패시브
                        machineGunPenalty: false, // 기관단총 패널티
                        reloadPenalty: 0, // 패시브로 인한 추가 재장전 시간(ms)
                        gunRecoil: 0,
                        gunRecoilTarget: 0,
                    },
                    enemies: [],
                    projectiles: [],
                    items: [],
                    particles: [],
                    floatingTexts: [],
                    allies: [], // 아군 배열 초기화
                    score: 0,
                    wave: 1,
                    gameStatus: 'playing', // 게임 오버 후 바로 플레이 상태로 전환
                    message: '',
                    messageTimer: 0,
                    playerSlowedEndTime: 0,
                    timeSlowEndTime: 0,
                    timeSlowEffect: 1
                };
                
                // 보스 시스템 초기화
                this.bossSystem = {
                    isActive: false,
                    currentBoss: null,
                    spawnLock: false
                };
                
                this.spawnInitialWave(); // 새 게임 시작 시 초기 웨이브 생성
                this.updateHUD(); // HUD 업데이트 (초기화된 값으로)
                this.hideMessage(); // 메시지 숨기기
                this.gameLoop(); // 게임 루프 재시작
            }

            // 게임 메시지 표시
            showMessage = (text, subText, duration, showRestart) => {
                const messageEl = document.getElementById('gameMessage');
                const messageTextEl = document.getElementById('messageText');
                const messageSubTextEl = document.getElementById('messageSubText');
                const restartBtn = document.getElementById('restartButton');
                messageTextEl.textContent = text;
                messageSubTextEl.textContent = subText;
                messageEl.style.display = 'block';
                if (showRestart) {
                    restartBtn.style.display = 'block';
                } else if (restartBtn) {
                    restartBtn.style.display = 'none';
                }
                if (!showRestart) {
                    setTimeout(() => {
                        this.hideMessage();
                    }, duration);
                }
            }
            
            // 게임 메시지 숨기기
            hideMessage = () => {
                document.getElementById('gameMessage').style.display = 'none';
            }

            // 보상 선택 화면 표시
            showRewardSelection = (type = 'score') => {
                this.canvas.style.filter = 'blur(10px)';
                document.querySelector('.hud').style.display = 'none';
                document.getElementById('rewardSelectionScreen').style.display = 'flex';
                const titleEl = document.getElementById('rewardSelectionTitle');
                if (type === 'boss') {
                    titleEl.textContent = '보스 처치! 보상을 선택하세요.';
                } else {
                    titleEl.textContent = '점수 달성! 보상을 선택하세요.';
                }
                const rewardOptionsEl = document.getElementById('rewardOptions');
                rewardOptionsEl.innerHTML = '';
                const shuffledRewards = [...this.REWARD_OPTIONS].sort(() => 0.5 - Math.random());
                const selectedRewards = shuffledRewards.slice(0, 3);
                selectedRewards.forEach(option => {
                    const button = document.createElement('button');
                    button.className = 'reward-button';
                    button.textContent = option.text;
                    button.addEventListener('click', () => {
                        this.applyReward(option.type, option.value);
                        this.hideRewardSelection();
                        this.gameState.gameStatus = 'playing';
                        this.updateHUD();
                        if (typeof this.gameLoop === 'function') {
                            this.gameLoop();
                        }
                    });
                    rewardOptionsEl.appendChild(button);
                });
            };

            // 보상 선택 화면 숨기기
            hideRewardSelection = () => {
                this.canvas.style.filter = 'blur(0px)'; // 캔버스 블러 제거
                document.querySelector('.hud').style.display = 'flex'; // HUD 표시
                document.getElementById('rewardSelectionScreen').style.display = 'none'; // 보상 화면 숨김
            }

            // 선택된 보상 적용
            applyReward = (type, value) => {
                const player = this.gameState.player;
                const player2 = this.gameState.player2;
                
                // 멀티플레이 모드에서 패시브 능력 공유
                const applyToPlayer = (targetPlayer) => {
                    if (!targetPlayer) return;
                    
                    switch (type) {
                        case 'tank':
                            targetPlayer.maxHealth += 100;
                            targetPlayer.health = Math.min(targetPlayer.maxHealth, targetPlayer.health + 100);
                            targetPlayer.speed -= 4;
                            break;
                        case 'speedster':
                            targetPlayer.speed += 10;
                            targetPlayer.dashCooldown = Math.max(0, targetPlayer.dashCooldown - 10000);
                            targetPlayer.baseDamage *= 0.95;
                            targetPlayer.reloadPenalty += 3000;
                            break;
                        case 'machine_gun':
                            targetPlayer.machineGunMode = true;
                            targetPlayer.machineGunPenalty = true;
                            targetPlayer.reloadPenalty += 5000;
                            break;
                        case 'homing_master':
                            targetPlayer.homingLevel = 3;
                            targetPlayer.homingPenalty = true;
                            break;
                        case 'ricochet_shot':
                            targetPlayer.ricochetLevel = 1;
                            break;
                        case 'vampire':
                            targetPlayer.lifeStealPercent += 0.03;
                            targetPlayer.reloadPenalty += 2000;
                            break;
                        case 'knife_shield':
                            for (let i = 0; i < 3; i++) {
                                targetPlayer.orbitingKnives.push({
                                    angle: Math.random() * Math.PI * 2,
                                    radius: 60,
                                    speed: 0.05,
                                    damage: 15,
                                    lastHit: 0,
                                    cooldown: 200,
                                    color: this.ITEM_TYPES.find(i => i.type === 'orbiting_knife').color,
                                    emoji: this.ITEM_TYPES.find(i => i.type === 'orbiting_knife').emoji
                                });
                            }
                            break;
                        case 'crit_master':
                            targetPlayer.critChance += 0.2;
                            targetPlayer.maxHealth = Math.floor(targetPlayer.maxHealth * 0.9);
                            targetPlayer.health = Math.min(targetPlayer.maxHealth, targetPlayer.health);
                            break;
                        case 'armor':
                            targetPlayer.armor += 5;
                            break;
                        case 'ammo_overflow':
                            targetPlayer.ammoRegenEndTime = Date.now() + 10000;
                            targetPlayer.ammoRegenAmount = 10;
                            targetPlayer.maxAmmo += 20;
                            break;
                        case 'maxHealth':
                            targetPlayer.maxHealth += value;
                            targetPlayer.health = Math.min(targetPlayer.maxHealth, targetPlayer.health + value);
                            break;
                        case 'currentHealth':
                            targetPlayer.health = Math.min(targetPlayer.maxHealth, targetPlayer.health + value);
                            break;
                        case 'damage':
                            targetPlayer.baseDamage += value;
                            break;
                        case 'speed':
                            targetPlayer.speed += value;
                            break;
                        case 'multishot':
                            targetPlayer.multishot = Math.min(99, (targetPlayer.multishot || 1) + 1);
                            break;
                        case 'orbiting_knife':
                            targetPlayer.orbitingKnives.push({
                                angle: Math.random() * Math.PI * 2,
                                radius: 60,
                                speed: 0.05,
                                damage: 15,
                                lastHit: 0,
                                cooldown: 200,
                                color: this.ITEM_TYPES.find(i => i.type === 'orbiting_knife').color,
                                emoji: this.ITEM_TYPES.find(i => i.type === 'orbiting_knife').emoji
                            });
                            break;
                        case 'piercing_shot':
                            targetPlayer.piercingShot = Math.min(99, targetPlayer.piercingShot + value);
                            break;
                        case 'explosive_shot':
                            targetPlayer.explosiveShot = Math.min(99, targetPlayer.explosiveShot + value);
                            break;
                        case 'ricochet_shot':
                            targetPlayer.ricochetLevel = Math.min(99, targetPlayer.ricochetLevel + value);
                            break;
                        case 'homing_shot':
                            targetPlayer.homingLevel = Math.min(99, targetPlayer.homingLevel + value);
                            break;
                        case 'split_shot':
                            targetPlayer.splitLevel = Math.min(99, targetPlayer.splitLevel + value);
                            break;
                        case 'life_steal':
                            targetPlayer.lifeStealPercent = Math.min(0.2, targetPlayer.lifeStealPercent + value);
                            break;
                        case 'crit_chance':
                            targetPlayer.critChance = Math.min(0.5, targetPlayer.critChance + value);
                            break;
                        case 'cooldown_reduction':
                            targetPlayer.cooldownReduction = Math.min(0.5, targetPlayer.cooldownReduction + value);
                            break;
                        case 'armor':
                            targetPlayer.armor += value;
                            break;
                        case 'ammo':
                            targetPlayer.ammo = Math.min(targetPlayer.maxAmmo, targetPlayer.ammo + value);
                            break;
                        case 'max_ammo':
                            targetPlayer.maxAmmo += value;
                            targetPlayer.ammo = Math.min(targetPlayer.maxAmmo, targetPlayer.ammo + value);
                            break;
                    }
                };
                
                // 멀티플레이 모드에서 두 플레이어 모두에게 적용
                if (this.gameState.multiplayerMode && player2) {
                    applyToPlayer(player);
                    applyToPlayer(player2);
                } else {
                    // 솔로 모드에서는 플레이어1에게만 적용
                    applyToPlayer(player);
                }
                
                // 메시지 표시 (기존 메시지들 유지)
                switch (type) {
                    case 'tank':
                        this.showMessage('탱크가 되어!', '최대 체력 +100, 이동 속도 -4', 2000);
                        break;
                    case 'speedster':
                        this.showMessage('빨라진다아아아아!', '속도 +10, 대시 쿨타임 -10초, 공격력 -5%, 재장전 +3초', 2000);
                        break;
                    case 'machine_gun':
                        this.showMessage('기관단총!', '연사, 재장전 +5초, 공격력 -50%', 2000);
                        break;
                    case 'homing_master':
                        this.showMessage('유도탄!', '유도탄 Lv.3, 공격력 -5%', 2000);
                        break;
                    case 'ricochet_shot':
                        this.showMessage('탱탱볼!', '총알이 벽에 튕김', 2000);
                        break;
                    case 'vampire':
                        this.showMessage('뱀파이어!', '흡혈, 재장전 +2초', 2000);
                        break;
                    case 'knife_shield':
                        this.showMessage('칼날이 나를 감싸네!', '칼날 3개 생성', 2000);
                        break;
                    case 'crit_master':
                        this.showMessage('스치기만 해도 치명타!', '치명타 +20%, 체력 -10%', 2000);
                        break;
                    case 'armor':
                        this.showMessage('방어력!', '피해량 5 감소', 2000);
                        break;
                    case 'ammo_overflow':
                        this.showMessage('탄약이 넘쳐!', '탄약 자동 회복, 탄약통 +20', 2000);
                        break;
                    case 'maxHealth':
                        this.showMessage(`최대 체력 +${value}!`, '', 1500);
                        break;
                    case 'currentHealth':
                        this.createFloatingText(player.x + player.width / 2, player.y, `+${value}`, 'green');
                        this.showMessage(`체력 +${value}!`, '', 1500);
                        break;
                    case 'damage':
                        this.showMessage(`공격력 +${value}!`, '', 1500);
                        break;
                    case 'speed':
                        this.showMessage(`이동 속도 +${value}!`, '', 1500);
                        break;
                    case 'multishot':
                        this.showMessage(`다중 발사!`, `${player.multishot}발 동시 발사`, 2000);
                        break;
                    case 'orbiting_knife':
                        this.showMessage(`회전 칼날 획득!`, `플레이어 주위를 돕니다!`, 2000);
                        break;
                    case 'piercing_shot':
                        this.showMessage(`관통 사격!`, `탄환이 적을 관통합니다! (Lv.${player.piercingShot})`, 2000);
                        break;
                    case 'explosive_shot':
                        this.showMessage(`폭발 사격!`, `탄환이 폭발합니다! (Lv.${player.explosiveShot})`, 2000);
                        break;
                    case 'ricochet_shot':
                        this.showMessage(`도탄 사격!`, `탄환이 벽에서 튕겨 나갑니다! (Lv.${player.ricochetLevel})`, 2000);
                        break;
                    case 'homing_shot':
                        this.showMessage(`유도 사격!`, `탄환이 적을 추적합니다! (Lv.${player.homingLevel})`, 2000);
                        break;
                    case 'split_shot':
                        this.showMessage(`분열 사격!`, `탄환이 분열하여 추가 피해를 줍니다! (Lv.${player.splitLevel})`, 2000);
                        break;
                    case 'life_steal':
                        this.showMessage(`생명력 흡수!`, `피해량의 ${(player.lifeStealPercent * 100).toFixed(0)}% 체력 회복!`, 2000);
                        break;
                    case 'crit_chance':
                        this.showMessage(`치명타 확률!`, `치명타 확률 ${(player.critChance * 100).toFixed(0)}%`, 2000);
                        break;
                    case 'cooldown_reduction':
                        this.showMessage(`재사용 대기시간 감소!`, `발사 속도 ${(player.cooldownReduction * 100).toFixed(0)}% 증가!`, 2000);
                        break;
                    case 'time_stop':
                        this.gameState.timeStopEndTime = Date.now() + value;
                        this.gameState.timeSlowEffect = 0;
                        this.showMessage(`시간 정지!`, `${value / 1000}초간 모든 적 정지!`, 2000);
                        break;
                    case 'ammo_regen':
                        this.showMessage(`탄약 재생!`, `5초간 탄약 자동 회복!`, 2000);
                        break;
                    case 'invincibility':
                        this.showMessage(`무적!`, `${value / 1000}초간 무적 상태!`, 2000);
                        break;
                    case 'shield_boost':
                        this.showMessage(`쉴드 강화!`, `${value / 1000}초간 피해량 50% 감소!`, 2000);
                        break;
                    case 'magnet':
                        this.showMessage(`자석 효과!`, `${value / 1000}초간 아이템 자동 수집!`, 2000);
                        break;
                    case 'health_regen':
                        this.showMessage(`체력 재생!`, `${value / 1000}초간 체력 자동 회복!`, 2000);
                        break;
                    case 'rapid':
                        this.showMessage(`연발 모드!`, `${value / 1000}초간 발사 속도 증가!`, 2000);
                        break;
                    case 'max_health':
                        this.showMessage(`최대 체력 +${value}!`, '', 1500);
                        break;
                    case 'ammo':
                        this.showMessage(`탄약 +${value}!`, '', 1500);
                        break;
                    case 'max_ammo':
                        this.showMessage(`최대 탄약 +${value}!`, '', 1500);
                        break;
                }
                this.updateHUD();
            }
            
            // HUD 업데이트 (체력, 탄약, 점수, 웨이브, 미니맵)
            updateHUD = () => {
                const player = this.gameState.player;
                const now = Date.now();
                
                // 체력 바 업데이트
                const healthPercent = (Math.max(0, player.health) / player.maxHealth) * 100;
                document.getElementById('healthFill').style.width = healthPercent + '%';
                
                // 죽은 플레이어1은 특별한 표시
                if (this.gameState.player1Dead) {
                    document.getElementById('healthText').textContent = '사망';
                    document.getElementById('healthFill').style.background = 'linear-gradient(90deg, #666, #999)';
                } else {
                    document.getElementById('healthText').textContent = `${Math.max(0, player.health.toFixed(0))}/${player.maxHealth.toFixed(0)}`;
                }
                
                // 탄약 바 업데이트
                const ammoPercent = (player.ammo / player.maxAmmo) * 100;
                document.getElementById('ammoFill').style.width = ammoPercent + '%';
                
                // 재장전 중일 때는 다른 색상으로 표시
                if (player.isReloading) {
                    document.getElementById('ammoFill').style.background = 'linear-gradient(90deg, #ff6b6b, #ff8e8e)';
                    document.getElementById('ammoText').textContent = '재장전 중...';
                } else {
                    document.getElementById('ammoFill').style.background = 'linear-gradient(90deg, #3b82f6, #60a5fa)';
                    document.getElementById('ammoText').textContent = `${player.ammo.toFixed(0)}/${player.maxAmmo.toFixed(0)}`;
                }
                
                // 점수 및 웨이브 업데이트
                document.getElementById('scoreText').textContent = this.gameState.score.toLocaleString();
                document.getElementById('waveText').textContent = `웨이브 ${this.gameState.wave}`;
                document.getElementById('enemyCount').textContent = `적: ${this.gameState.enemies.length}마리`;

                // 새로운 스탯 업데이트
                document.getElementById('speedText').textContent = player.speed;
                document.getElementById('damageText').textContent = player.baseDamage;
                document.getElementById('multishotText').textContent = player.multishot;

                // 활성 효과 업데이트
                const invincibilityEl = document.getElementById('invincibilityEffect');
                const shieldBoostEl = document.getElementById('shieldBoostEffect');
                const timeSlowEl = document.getElementById('timeSlowEffect');
                const magnetEl = document.getElementById('magnetEffect');
                const healthRegenEl = document.getElementById('healthRegenEffect');
                const rapidFireEl = document.getElementById('rapidFireEffect');
                const piercingShotEl = document.getElementById('piercingShotEffect'); 
                const explosiveShotEl = document.getElementById('explosiveShotEffect'); 
                const orbitingKnivesEl = document.getElementById('orbitingKnivesEffect'); 
                const ricochetShotEl = document.getElementById('ricochetShotEffect'); 
                const homingShotEl = document.getElementById('homingShotEffect'); 
                const splitShotEl = document.getElementById('splitShotEffect'); 
                const ammoRegenEl = document.getElementById('ammoRegenEffect');
                const timeStopEl = document.getElementById('timeStopEffect');
                const dashEl = document.getElementById('dashEffect');

                invincibilityEl.textContent = now < player.invincibleEndTime ? `무적: ${( (player.invincibleEndTime - now) / 1000).toFixed(1)}초` : '';
                shieldBoostEl.textContent = now < player.shieldBoostEndTime ? `쉴드 강화: ${( (player.shieldBoostEndTime - now) / 1000).toFixed(1)}초 (${(1 - player.damageReductionFactor) * 100}% 감소)` : '';
                timeSlowEl.textContent = now < this.gameState.timeSlowEndTime && this.gameState.timeSlowEffect > 0 ? `시간 둔화: ${( (this.gameState.timeSlowEndTime - now) / 1000).toFixed(1)}초` : '';
                magnetEl.textContent = now < player.magnetEndTime ? `자석: ${( (player.magnetEndTime - now) / 1000).toFixed(1)}초` : '';
                healthRegenEl.textContent = now < player.healthRegenEndTime ? `체력 재생: ${( (player.healthRegenEndTime - now) / 1000).toFixed(1)}초` : '';
                rapidFireEl.textContent = now < player.rapidFireTime ? `연발: ${( (player.rapidFireTime - now) / 1000).toFixed(1)}초` : '';
                piercingShotEl.textContent = player.piercingShot > 0 ? `관통 사격: ${player.piercingShot}회` : '';
                explosiveShotEl.textContent = player.explosiveShot > 0 ? `폭발 사격: Lv.${player.explosiveShot}` : '';
                orbitingKnivesEl.textContent = player.orbitingKnives.length > 0 ? `회전 칼날: ${player.orbitingKnives.length}개` : '';
                ricochetShotEl.textContent = player.ricochetLevel > 0 ? `도탄 사격: Lv.${player.ricochetLevel}` : '';
                homingShotEl.textContent = player.homingLevel > 0 ? `유도 사격: Lv.${player.homingLevel}` : '';
                splitShotEl.textContent = player.splitLevel > 0 ? `분열 사격: Lv.${player.splitLevel}` : '';
                ammoRegenEl.textContent = now < player.ammoRegenEndTime ? `탄약 재생: ${( (player.ammoRegenEndTime - now) / 1000).toFixed(1)}초` : '';
                timeStopEl.textContent = now < this.gameState.timeStopEndTime ? `시간 정지: ${( (this.gameState.timeStopEndTime - now) / 1000).toFixed(1)}초` : '';
                if (dashEl) {
                    if (player.isDashing) dashEl.textContent = `대시: 무적!`;
                    else if (now - player.dashCooldown < 1000) dashEl.textContent = `대시 쿨타임: ${((1000 - (now - player.dashCooldown))/1000).toFixed(1)}초`;
                    else dashEl.textContent = '';
                }


                // 패시브 스킬 업데이트
                const lifeStealEl = document.getElementById('lifeStealEffect');
                const critChanceEl = document.getElementById('critChanceEffect');
                const cooldownReductionEl = document.getElementById('cooldownReductionEffect');
                const armorEl = document.getElementById('armorEffect');

                lifeStealEl.textContent = player.lifeStealPercent > 0 ? `생명력 흡수: ${(player.lifeStealPercent * 100).toFixed(0)}%` : '';
                critChanceEl.textContent = player.critChance > 0 ? `치명타 확률: ${(player.critChance * 100).toFixed(0)}%` : '';
                cooldownReductionEl.textContent = player.cooldownReduction > 0 ? `재사용 대기시간 감소: ${(player.cooldownReduction * 100).toFixed(0)}%` : '';
                armorEl.textContent = player.armor > 0 ? `방어력: ${player.armor}` : '';

                // 미니맵 업데이트
                this.updateMinimap();


                // 보스 체력바 표시
                const bossBarContainer = document.getElementById('bossBarContainer');
                const bossBar = document.getElementById('bossBar');
                const bossName = document.getElementById('bossName');
                
                if (this.bossSystem && this.bossSystem.isActive && this.bossSystem.currentBoss) {
                    const boss = this.bossSystem.currentBoss;
                    bossBarContainer.style.display = 'block';
                    bossName.textContent = this.ENEMY_TYPES[boss.type].name;
                    bossBar.style.width = Math.max(0, (boss.health / boss.maxHealth) * 100) + '%';
                } else {
                    bossBarContainer.style.display = 'none';
                }
                
                // 플레이어2 HUD 업데이트 (멀티플레이 모드일 때만)
                if (this.gameState.player2 && this.gameState.multiplayerMode) {
                    const player2 = this.gameState.player2;
                    
                    // 플레이어2 체력 바 업데이트
                    const healthPercent2 = (Math.max(0, player2.health) / player2.maxHealth) * 100;
                    document.getElementById('healthFill2').style.width = healthPercent2 + '%';
                    
                    // 죽은 플레이어2는 특별한 표시
                    if (this.gameState.player2Dead) {
                        document.getElementById('healthText2').textContent = '사망';
                        document.getElementById('healthFill2').style.background = 'linear-gradient(90deg, #666, #999)';
                        document.getElementById('ammoText2').textContent = '부활 대기';
                        document.getElementById('ammoFill2').style.background = 'linear-gradient(90deg, #666, #999)';
                    } else {
                        document.getElementById('healthText2').textContent = `${Math.max(0, player2.health.toFixed(0))}/${player2.maxHealth.toFixed(0)}`;
                        
                        // 플레이어2 탄약 바 업데이트
                        const ammoPercent2 = (player2.ammo / player2.maxAmmo) * 100;
                        document.getElementById('ammoFill2').style.width = ammoPercent2 + '%';
                        
                        // 재장전 중일 때는 다른 색상으로 표시
                        if (player2.isReloading) {
                            document.getElementById('ammoFill2').style.background = 'linear-gradient(90deg, #ff6b6b, #ff8e8e)';
                            document.getElementById('ammoText2').textContent = '재장전 중...';
                        } else {
                            document.getElementById('ammoFill2').style.background = 'linear-gradient(90deg, #ef4444, #f87171)';
                            document.getElementById('ammoText2').textContent = `${player2.ammo.toFixed(0)}/${player2.maxAmmo.toFixed(0)}`;
                        }
                    }
                    
                    // 플레이어2 HUD 표시
                    document.getElementById('player2HUD').style.display = 'flex';
                } else {
                    // 플레이어2 HUD 숨기기
                    document.getElementById('player2HUD').style.display = 'none';
                }
                
                // 5. updateHUD에 XP/점수 표시 추가 (테스팅 존에서는 점수만)
                if (this.gameMode === 'testzone') {
                    document.getElementById('xpText').textContent = `점수: ${this.gameState.score}`;
                    // 테스팅 존에서는 상점 버튼 숨기기, 테스트 존 버튼 보이기
                    document.getElementById('shopButton').style.display = 'none';
                    document.getElementById('testZoneHUDButton').style.display = 'inline-block';
                } else {
                    document.getElementById('xpText').textContent = `XP: ${this.xp}`;
                    // 솔로 플레이에서는 상점 버튼 보이기, 테스트 존 버튼 숨기기
                    document.getElementById('shopButton').style.display = 'inline-block';
                    document.getElementById('testZoneHUDButton').style.display = 'none';
                }
            }
            
            // 미니맵 업데이트 (플레이어, 적, 아이템 위치 표시)
            updateMinimap = () => {
                const minimapPlayer = document.getElementById('minimapPlayer');
                const minimap = document.getElementById('minimap');
                
                // 플레이어 위치 계산 및 업데이트
                const playerX = (this.gameState.player.x / this.canvas.width) * 120;
                const playerY = (this.gameState.player.y / this.canvas.height) * 120;
                
                minimapPlayer.style.left = playerX + 'px';
                minimapPlayer.style.top = playerY + 'px';
                
                // 기존 적/아이템 도트 제거
                const existingDots = minimap.querySelectorAll('.minimap-enemy, .minimap-item, .minimap-ally');
                existingDots.forEach(dot => dot.remove());
                
                // 적 도트 추가
                this.gameState.enemies.forEach(enemy => {
                    const enemyX = (enemy.x / this.canvas.width) * 120;
                    const enemyY = (enemy.y / this.canvas.height) * 120;
                    
                    const dot = document.createElement('div');
                    dot.className = 'minimap-enemy';
                    dot.style.left = enemyX + 'px';
                    dot.style.top = enemyY + 'px';
                    minimap.appendChild(dot);
                });
                
                // 아이템 도트 추가
                this.gameState.items.forEach(item => {
                    const itemX = (item.x / this.canvas.width) * 120;
                    const itemY = (item.y / this.canvas.height) * 120;
                    
                    const dot = document.createElement('div');
                    dot.className = 'minimap-item';
                    dot.style.left = itemX + 'px';
                    dot.style.top = itemY + 'px';
                    minimap.appendChild(dot);
                });

                // 아군 도트 추가
                this.gameState.allies.forEach(ally => {
                    const allyX = (ally.x / this.canvas.width) * 120;
                    const allyY = (ally.y / this.canvas.height) * 120;
                    
                    const dot = document.createElement('div');
                    dot.className = 'minimap-ally'; // 새로운 클래스
                    dot.style.left = allyX + 'px';
                    dot.style.top = allyY + 'px';
                    dot.style.backgroundColor = ally.color; // 아군 색상
                    dot.style.width = '3px';
                    dot.style.height = '3px';
                    dot.style.borderRadius = '50%';
                    minimap.appendChild(dot);
                });
            }
            
            // 캐릭터 (플레이어 및 적) 그리기 (유령 무적 상태 시 시각적 효과 추가)
            drawCharacter = (character) => {
                this.ctx.save(); // 현재 캔버스 상태 저장
                
                // 그림자 그리기 (변환 전)
                this.ctx.globalAlpha = 0.2;
                this.ctx.fillStyle = 'black';
                this.ctx.fillRect(character.x + 3, character.y + character.height + 3, character.width, 5);
                
                // 플레이어 캐릭터 그리기 (변환 적용)
                if (character.type === 'player' || character.type === 'player2') {
                    // 캐릭터의 중심으로 캔버스 원점 이동
                    this.ctx.translate(character.x + character.width / 2, character.y + character.height / 2);
                    // 마우스 방향으로 플레이어 회전 (캐릭터의 기본 방향이 오른쪽이라고 가정하고 180도 회전 보정)
                    this.ctx.rotate(character.facing + Math.PI); 

                    // 죽은 플레이어는 반투명하게 표시
                    if ((character.type === 'player' && this.gameState.player1Dead) || 
                        (character.type === 'player2' && this.gameState.player2Dead)) {
                        this.ctx.globalAlpha = 0.3;
                    } else {
                        this.ctx.globalAlpha = 0.8;
                    }
                    
                    this.ctx.fillStyle = character.color;
                    this.ctx.shadowBlur = 15;
                    this.ctx.shadowColor = character.color;
                    this.ctx.beginPath();
                    this.ctx.roundRect(-character.width / 2, -character.height / 2, character.width, character.height, 8);
                    this.ctx.fill();

                    // 글래스 효과
                    this.ctx.globalAlpha = 0.3;
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    this.ctx.beginPath();
                    this.ctx.roundRect(-character.width / 2, -character.height / 2, character.width, character.height / 2, 8);
                    this.ctx.fill();

                    // 표정 그리기
                    this.ctx.globalAlpha = 1;
                    this.ctx.fillStyle = 'white';
                    const fontSize = '16px';
                    this.ctx.font = `${fontSize} Poppins`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(character.expression, 0, 0); // 새로운 원점(0,0)에 그리기

                    // 플레이어 총 이모지 그리기 (반동 효과 포함)
                    this.ctx.font = '20px Poppins'; // 총 이모지 크기
                    this.ctx.fillStyle = 'black'; // 총 색상 검정색으로 변경
                    
                    // 총 반동 효과 적용
                    const recoilOffset = character.gunRecoil || 0;
                    
                    // 총 이모지를 플레이어의 왼쪽 (캐릭터 중심 기준 왼쪽)에 고정 + 반동
                    const gunOffsetX = -character.width / 2 - 10 - recoilOffset; // 반동으로 뒤로 밀림
                    const weaponEmoji = (this.currentWeapon === 'melee') ? '🔪' : '🔫';
                    this.ctx.fillText(weaponEmoji, gunOffsetX, 0); // 반동 오프셋 적용

                    // 플레이어2 표시 (멀티플레이 모드에서만)
                    if (character.type === 'player2') {
                        this.ctx.font = '12px Poppins';
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                        this.ctx.fillText('P2', character.width / 2 + 15, -character.height / 2 - 10);
                    }

                } else {
                    // 비-플레이어 캐릭터 (적, 아군) 그리기 (변환 없음)
                    // 캐릭터 몸체 (글래스 효과)
                    this.ctx.globalAlpha = 0.8;
                    this.ctx.fillStyle = character.color;
                    
                    // 보스는 더 강한 글로우 효과, 유령은 무적 상태 시 다른 효과
                    if (character.type && character.type.startsWith('boss')) { // 모든 보스 타입에 적용
                        this.ctx.shadowBlur = 25;
                        this.ctx.shadowColor = character.color;
                        if (character.type === 'boss_beta' && character.isInvincible) { // 베타 보스 쉴드 시
                            this.ctx.globalAlpha = 0.4;
                            this.ctx.shadowBlur = 15;
                            this.ctx.shadowColor = 'rgba(135, 206, 235, 0.8)'; // 스카이블루 글로우
                        }
                    } else if (character.type === 'ghost' && character.isInvincible) {
                        this.ctx.globalAlpha = 0.4; // 무적 상태 시 반투명
                        this.ctx.shadowBlur = 10;
                        this.ctx.shadowColor = 'rgba(255, 255, 255, 0.7)'; // 흰색 글로우
                    } else if (character.type === 'berserker' && character.isRaging) {
                        this.ctx.shadowBlur = 20;
                        this.ctx.shadowColor = 'red'; // 광전사 광폭화 시 붉은 글로우
                    } else if (character.type === 'phaser' && character.isPhasing) {
                        this.ctx.globalAlpha = 0.3; // 페이즈 상태 시 반투명
                        this.ctx.shadowBlur = 15;
                        this.ctx.shadowColor = 'rgba(6, 182, 212, 0.8)'; // 시안 글로우
                    } else {
                        this.ctx.shadowBlur = 15;
                        this.ctx.shadowColor = character.color;
                    }
                    
                    this.ctx.beginPath();
                    this.ctx.roundRect(character.x, character.y, character.width, character.height, 8);
                    this.ctx.fill();
                    
                    // 글래스 효과
                    this.ctx.globalAlpha = 0.3;
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    this.ctx.beginPath();
                    this.ctx.roundRect(character.x, character.y, character.width, character.height / 2, 8);
                    this.ctx.fill();
                    
                    // 표정 그리기
                    this.ctx.globalAlpha = 1;
                    this.ctx.fillStyle = 'white';
                    
                    // 보스는 더 큰 폰트
                    const fontSize = character.type && character.type.startsWith('boss') ? '20px' : '16px'; // character.type 체크 추가
                    this.ctx.font = `${fontSize} Poppins`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(character.expression, character.x + character.width / 2, character.y + character.height / 2);
                    
                    // 적 타입 표시 (작은 아이콘)
                    if (character.type && character !== this.gameState.player) { // character.type 체크 추가
                        this.ctx.font = '10px Poppins';
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        let typeIcon = '';
                        switch (character.type) {
                            case 'fast': typeIcon = '⚡'; break;
                            case 'tank': typeIcon = '🛡'; break;
                            case 'sniper': typeIcon = '🎯'; break;
                            case 'bomber': typeIcon = '💣'; break;
                            case 'guardian': typeIcon = '🛡️'; break;
                            case 'assassin': typeIcon = '🗡'; break;
                            case 'heavy': typeIcon = '💪'; break;
                            case 'ghost': typeIcon = '👻'; break; 
                            case 'medic': typeIcon = '➕'; break; 
                            case 'summoner': typeIcon = '🌀'; break; 
                            case 'jumper': typeIcon = '⬆️'; break; 
                            case 'shielded': typeIcon = '🛡️'; break; 
                            case 'teleporter': typeIcon = '💫'; break; 
                            case 'drone': typeIcon = '📡'; break; 
                            case 'spitter': typeIcon = '🦠'; break; 
                            case 'berserker': typeIcon = '💢'; break; 
                            case 'boss_alpha': typeIcon = 'α'; break; // 알파 보스 아이콘
                            case 'boss_beta': typeIcon = 'β'; break; // 베타 보스 아이콘
                            case 'boss_gamma': typeIcon = 'γ'; break; // 감마 보스 아이콘
                            case 'leech': typeIcon = '🩸'; break; // 흡혈 적
                            case 'mine': typeIcon = '💣'; break; // 지뢰 적
                            case 'freezer': typeIcon = '❄️'; break; // 빙결 적
                            case 'reflector': typeIcon = '🪞'; break; // 반사 적
                            case 'healer': typeIcon = '💚'; break; // 힐러 적
                            case 'portal': typeIcon = '🌀'; break; // 포탈 적
                            case 'exploder': typeIcon = '💥'; break; // 폭발 적
                            case 'magnet': typeIcon = '🧲'; break; // 자석 적
                            case 'curse': typeIcon = '👹'; break; // 저주 적
                            case 'floater': typeIcon = '🦋'; break; // 플로터
                            case 'phaser': typeIcon = '👻'; break; // 페이저
                            case 'ally': typeIcon = '🤖'; break; // 아군 아이콘
                            default: typeIcon = ''; break;
                        }
                        if (typeIcon) {
                            this.ctx.fillText(typeIcon, character.x + character.width - 8, character.y + 8);
                        }
                    }
                    
                    // 체력 바 그리기
                    if (character.health < character.maxHealth || (character.type && character.type.startsWith('boss')) || character.type === 'ally') { // 보스, 아군도 항상 체력바 표시
                        const barWidth = character.width;
                        const barHeight = (character.type && character.type.startsWith('boss')) ? 6 : 4; // character.type 체크 추가
                        const barX = character.x;
                        const barY = character.y - 12;
                        
                        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                        this.ctx.fillRect(barX, barY, barWidth, barHeight);
                        
                        let healthColor;
                        if (character === this.gameState.player) {
                            healthColor = '#22c55e';
                        } else if (character.type && character.type.startsWith('boss')) { // character.type 체크 추가
                            healthColor = '#dc2626';
                        } else if (character.type === 'ally') { // 아군 체력바 색상
                            healthColor = '#90ee90';
                        } else {
                            healthColor = character.color;
                        }
                        
                        this.ctx.fillStyle = healthColor;
                        this.ctx.fillRect(barX, barY, (character.health / character.maxHealth) * barWidth, barHeight);
                    }
                }
                
                this.ctx.restore(); // 저장된 캔버스 상태 복원
            }

            // 회전 칼날 그리기 및 충돌 감지
            drawOrbitingKnives = () => {
                const player = this.gameState.player;
                const now = Date.now();

                player.orbitingKnives.forEach(knife => {
                    // 각도 업데이트 (시간 둔화 효과 적용)
                    knife.angle += knife.speed * (this.gameState.timeSlowEffect < 1 ? this.gameState.timeSlowEffect : 1);

                    // 칼날 위치 계산
                    const knifeX = player.x + player.width / 2 + Math.cos(knife.angle) * knife.radius;
                    const knifeY = player.y + player.height / 2 + Math.sin(knife.angle) * knife.radius;

                    // 칼날 그리기
                    this.ctx.save();
                    this.ctx.globalAlpha = 0.9;
                    this.ctx.fillStyle = knife.color;
                    this.ctx.shadowBlur = 10;
                    this.ctx.shadowColor = knife.color;
                    this.ctx.beginPath();
                    this.ctx.roundRect(knifeX - 5, knifeY - 5, 10, 10, 2); // 작은 사각형으로 칼날 표현
                    this.ctx.fill();
                    this.ctx.globalAlpha = 1;
                    this.ctx.font = '12px Poppins';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(knife.emoji, knifeX, knifeY);
                    this.ctx.restore();

                    // 적과의 충돌 감지
                    this.gameState.enemies = this.gameState.enemies.filter(enemy => {
                        const dx = knifeX - (enemy.x + enemy.width / 2);
                        const dy = knifeY - (enemy.y + enemy.height / 2);
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        // 쿨다운 체크 및 충돌 범위 내에 있는지 확인
                        if (distance < 15 + enemy.width / 2 && now - knife.lastHit > knife.cooldown) { // 15는 칼날의 대략적인 반지름
                            // 유령, 방패병, 베타 보스 쉴드 무적 상태 체크
                            if (enemy.type === 'ghost' && enemy.isInvincible) return true;
                            if (enemy.type === 'boss_beta' && enemy.isInvincible) return true;

                            let actualDamage = knife.damage;
                            if (enemy.type === 'shielded') {
                                const angleToKnife = Math.atan2(dy, dx);
                                const angleDiff = Math.abs(angleToKnife - enemy.facing);
                                if (angleDiff < enemy.shieldAngle || angleDiff > (2 * Math.PI - enemy.shieldAngle)) {
                                    // 방패병이 칼날을 방어하는 방향에 있으면 피해 감소
                                    actualDamage *= 0.1;
                                    this.createFloatingText(enemy.x + enemy.width / 2, enemy.y, `-${actualDamage.toFixed(0)} (방어)`, 'orange');
                                } else {
                                    this.createFloatingText(enemy.x + enemy.width / 2, enemy.y, `-${actualDamage.toFixed(0)}`, 'white');
                                }
                            } else {
                                this.createFloatingText(enemy.x + enemy.width / 2, enemy.y, `-${actualDamage.toFixed(0)}`, 'white');
                            }
                            enemy.health -= actualDamage;

                            this.createHitParticles(knifeX, knifeY);
                            knife.lastHit = now; // 이 칼날의 마지막 공격 시간 업데이트

                            // 생명력 흡수 (Life Steal) 적용
                            if (player.lifeStealPercent > 0) {
                                const healedAmount = actualDamage * player.lifeStealPercent;
                                player.health = Math.min(player.maxHealth, player.health + healedAmount);
                                this.createFloatingText(player.x + player.width / 2, player.y - 20, `+${healedAmount.toFixed(0)} 흡수`, 'lightgreen');
                            }

                            if (enemy.health <= 0) {
                                this.addScore(enemy.points);
                                if (Math.random() < 0.4) this.gameState.items.push(this.createItem(enemy.x, enemy.y));
                                // === 보스 사망 처리 추가 ===
                                if (enemy.type && enemy.type.startsWith('boss')) {
                                    if (this.bossSystem && this.bossSystem.currentBoss && this.bossSystem.currentBoss.id === enemy.id) {
                                        this.bossSystem.currentBoss = null;
                                    }
                                    this.checkBossWaveComplete(); // ← 먼저 호출
                                    this.resetBossSystem();
                                }
                                // =========================
                                this.gameState.enemies = this.gameState.enemies.filter(e => e !== enemy);
                                return false; // 적 제거
                            }
                        }
                        return true; // 적 유지
                    });
                });
            }
            
            // 발사체 그리기
            drawProjectile = (projectile) => {
                this.ctx.save();
                this.ctx.globalAlpha = 0.8;
                this.ctx.fillStyle = projectile.color;
                this.ctx.shadowBlur = 8;
                this.ctx.shadowColor = projectile.color;
                this.ctx.beginPath();
                this.ctx.arc(projectile.x, projectile.y, projectile.radius, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.restore();
            }
            
            // 아이템 그리기
            drawItem = (item) => {
                this.ctx.save();
                this.ctx.globalAlpha = 0.9;
                this.ctx.fillStyle = item.color;
                this.ctx.shadowBlur = 10;
                this.ctx.shadowColor = item.color;
                this.ctx.beginPath();
                this.ctx.roundRect(item.x, item.y, item.width, item.height, 4);
                this.ctx.fill();
                
                // 아이템 아이콘 그리기
                this.ctx.globalAlpha = 1;
                this.ctx.font = '12px Poppins';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(item.emoji, item.x + item.width / 2, item.y + item.height / 2);
                
                this.ctx.restore();
            }
            
            // 파티클 그리기
            drawParticle = (particle) => {
                this.ctx.save();
                this.ctx.globalAlpha = particle.life / particle.maxLife; // 수명에 따라 투명도 조절
                this.ctx.fillStyle = particle.color;
                this.ctx.beginPath();
                this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.restore();
            }

            // 떠다니는 텍스트 그리기
            drawFloatingText = (text) => {
                this.ctx.save();
                this.ctx.globalAlpha = text.life / text.maxLife; // 수명에 따라 투명도 조절
                this.ctx.fillStyle = text.color;
                this.ctx.font = 'bold 16px Poppins';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(text.text, text.x, text.y);
                this.ctx.restore();
            }
            
            // 배경 그리기
            drawBackground = () => {
                // 배경 그라데이션
                const gradient = this.ctx.createLinearGradient(0, 0, this.canvas.width, this.canvas.height);
                gradient.addColorStop(0, '#667eea');
                gradient.addColorStop(1, '#764ba2');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // 지면 그리기
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                this.ctx.fillRect(0, this.canvas.height - this.GROUND_Y, this.canvas.width, this.GROUND_Y);
            }
            
            // 모든 게임 요소 렌더링
            render = () => {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); // 캔버스 초기화
                
                this.drawBackground(); // 배경 그리기
                
                // 캐릭터 그리기
                this.drawCharacter(this.gameState.player);
                // 플레이어2 그리기 (멀티플레이 모드일 때만)
                if (this.gameState.player2 && this.gameState.multiplayerMode) {
                    this.drawCharacter(this.gameState.player2);
                }
                this.gameState.enemies.forEach(enemy => this.drawCharacter(enemy));
                this.gameState.allies.forEach(ally => this.drawCharacter(ally));
                
                // 회전 칼날 그리기 및 충돌
                this.drawOrbitingKnives();
                
                // 파티클 그리기
                this.gameState.particles.forEach(particle => this.drawParticle(particle));
                
                // 발사체 그리기
                this.gameState.projectiles.forEach(projectile => this.drawProjectile(projectile));
                
                // 아이템 그리기
                this.gameState.items.forEach(item => this.drawItem(item));
                
                // 떠다니는 텍스트 그리기
                this.gameState.floatingTexts.forEach(text => this.drawFloatingText(text));
                
                // 파티클 상태 업데이트
                this.updateParticles();
                
                // 발사체 상태 업데이트 및 충돌 감지
                this.updateProjectiles();
                
                // 아이템 상태 업데이트 및 플레이어 충돌 감지
                this.updateItems();
                
                // HUD 업데이트
                this.updateHUD();
                this.updateFloatingTexts();
            }
            // 게임 루프
            gameLoop = () => {
                // 시간 정지/둔화 해제 체크
                const now = Date.now();
                if (now > this.gameState.timeStopEndTime && now > this.gameState.timeSlowEndTime) {
                    this.gameState.timeSlowEffect = 1;
                } else if (now > this.gameState.timeStopEndTime && now < this.gameState.timeSlowEndTime) {
                    this.gameState.timeSlowEffect = 0.5;
                } else if (now < this.gameState.timeStopEndTime) {
                    this.gameState.timeSlowEffect = 0;
                } else if (now < this.gameState.timeSlowEndTime) {
                    this.gameState.timeSlowEffect = 0.5;
                }
                
                // 모바일 터치 컨트롤 처리
                if (this.mobileMode && this.gameState.gameStatus === 'playing') {
                    // 발사 버튼 터치 처리
                    if (this.touchControls.fireButton.pressed) {
                        this.shoot();
                        console.log('Fire button pressed'); // 디버깅용
                    }
                }
                
                // 1. 상태 업데이트
                this.updateCharacter(this.gameState.player);
                // 플레이어2 업데이트 (멀티플레이 모드일 때만)
                if (this.gameState.player2 && this.gameState.multiplayerMode) {
                    this.updateCharacter(this.gameState.player2);
                }
                this.gameState.enemies.forEach(e => this.updateCharacter(e));
                this.gameState.allies.forEach(a => this.updateCharacter(a));
                // 2. 웨이브 완료 체크
                this.checkWaveComplete();
                // 3. 렌더링
                this.render();
                // 4. 다음 프레임 예약
                if (this.gameState.gameStatus === 'playing' || this.gameState.gameStatus === 'wave-complete') {
                    requestAnimationFrame(this.gameLoop);
                }
            }

            // 1. Add addScore method to GlassCombatArena
            addScore = (amount) => {
                this.gameState.score += amount;
                this.updateHUD();
                // 테스팅 존에서는 보상 선택 안함
                if (this.gameMode === 'testzone') return;
                
                while (this.nextMilestoneIndex < this.scoreMilestones.length && this.gameState.score >= this.scoreMilestones[this.nextMilestoneIndex]) {
                    this.pauseGameForReward();
                    this.nextMilestoneIndex++;
                }
            };

            pauseGameForReward = () => {
                this.gameState.gameStatus = 'reward-selection';
                this.showRewardSelection('score');
            };

            updateShopList = () => {
                const shopList = document.getElementById('shopList');
                shopList.innerHTML = '';
                this.SHOP_ITEMS.forEach(item => {
                    // 가격 계산: 구매 횟수에 따라 가격 증가 (20%씩 증가)
                    const currentPrice = Math.floor(item.basePrice * (1 + item.purchaseCount * 0.2));
                    const affordable = this.gameState.score >= currentPrice;
                    const itemDiv = document.createElement('div');
                    itemDiv.style.display = 'flex';
                    itemDiv.style.justifyContent = 'space-between';
                    itemDiv.style.alignItems = 'center';
                    itemDiv.style.margin = '10px 0';
                    itemDiv.style.padding = '10px 0';
                    itemDiv.style.borderBottom = '1px solid rgba(255,255,255,0.15)';
                    itemDiv.style.color = '#fff';
                    const label = document.createElement('span');
                    label.textContent = `${item.text} (구매: ${item.purchaseCount}회)`;
                    const price = document.createElement('span');
                    price.textContent = `${currentPrice}점`;
                    price.style.marginLeft = '16px';
                    price.style.color = affordable ? '#ffe066' : '#aaa';
                    price.style.fontWeight = 'normal';
                    const buyBtn = document.createElement('button');
                    buyBtn.textContent = affordable ? '구매' : '구매불가';
                    buyBtn.disabled = !affordable;
                    buyBtn.style.marginLeft = '18px';
                    buyBtn.style.background = affordable ? '#ffe066' : '#888';
                    buyBtn.style.color = '#222';
                    buyBtn.style.fontWeight = 'bold';
                    buyBtn.style.border = 'none';
                    buyBtn.style.borderRadius = '8px';
                    buyBtn.style.padding = '6px 18px';
                    buyBtn.style.cursor = affordable ? 'pointer' : 'not-allowed';
                    buyBtn.onclick = () => {
                        if (this.gameState.score >= currentPrice) {
                            this.gameState.score -= currentPrice;
                            item.purchaseCount++;
                            this.applyReward(item.type, item.value);
                            this.updateHUD();
                            this.updateShopList();
                        }
                    };
                    itemDiv.appendChild(label);
                    itemDiv.appendChild(price);
                    itemDiv.appendChild(buyBtn);
                    shopList.appendChild(itemDiv);
                });
            };

            // 메인 메뉴로 돌아가기
            returnToMainMenu = () => {
                this.canvas.style.filter = 'blur(10px)';
                document.querySelector('.hud').style.display = 'none';
                document.getElementById('testZonePopup').style.display = 'none';
                document.getElementById('testZoneHUDButton').style.display = 'none';
                document.getElementById('introScreen').style.display = 'flex';
                this.gameState.gameStatus = 'start';
            }

            // 적 도감 표시
            showEnemyDex = () => {
                document.getElementById('enemyDexScreen').style.display = 'flex';
                this.updateEnemyDex();
            }

            // 적 도감 숨김
            hideEnemyDex = () => {
                document.getElementById('enemyDexScreen').style.display = 'none';
            }

            // 적 도감 업데이트
            updateEnemyDex = () => {
                const enemyList = document.getElementById('enemyDexList');
                const enemyDetail = document.getElementById('enemyDexDetail');
                
                enemyList.innerHTML = '';
                enemyDetail.innerHTML = '';
                
                // 적 목록 생성
                Object.entries(this.ENEMY_TYPES).forEach(([type, data]) => {
                    const enemyDiv = document.createElement('div');
                    enemyDiv.style.display = 'flex';
                    enemyDiv.style.alignItems = 'center';
                    enemyDiv.style.padding = '12px 16px';
                    enemyDiv.style.borderBottom = '1px solid rgba(255,255,255,0.1)';
                    enemyDiv.style.cursor = 'pointer';
                    enemyDiv.style.color = '#fff';
                    enemyDiv.style.fontSize = '14px';
                    enemyDiv.style.transition = 'background 0.2s';
                    
                    // 보스인지 일반 적인지 구분
                    const isBoss = type.startsWith('boss');
                    const category = isBoss ? '보스' : '일반';
                    const categoryColor = isBoss ? '#ff6b6b' : '#4ade80';
                    
                    enemyDiv.innerHTML = `
                        <div style="display:flex; align-items:center; gap:12px; width:100%;">
                            <div style="width:20px; height:20px; background:${data.color}; border-radius:50%;"></div>
                            <div style="flex:1;">
                                <div style="font-weight:bold;">${data.name}</div>
                                <div style="font-size:12px; color:${categoryColor};">${category}</div>
                            </div>
                        </div>
                    `;
                    
                    enemyDiv.onmouseover = () => {
                        enemyDiv.style.background = 'rgba(255,255,255,0.1)';
                    };
                    
                    enemyDiv.onmouseout = () => {
                        enemyDiv.style.background = 'transparent';
                    };
                    
                    enemyDiv.onclick = () => {
                        this.showEnemyDetail(type, data);
                    };
                    
                    enemyList.appendChild(enemyDiv);
                });
                
                // 첫 번째 적 선택
                const firstEnemy = Object.entries(this.ENEMY_TYPES)[0];
                if (firstEnemy) {
                    this.showEnemyDetail(firstEnemy[0], firstEnemy[1]);
                }
            }

            // 적 상세 정보 표시
            showEnemyDetail = (type, data) => {
                const enemyDetail = document.getElementById('enemyDexDetail');
                
                const isBoss = type.startsWith('boss');
                const category = isBoss ? '보스' : '일반';
                const categoryColor = isBoss ? '#ff6b6b' : '#4ade80';
                
                enemyDetail.innerHTML = `
                    <div style="text-align:center; width:100%;">
                        <h2 style="color:#fff; margin-bottom:8px;">${data.name}</h2>
                        <div style="color:${categoryColor}; margin-bottom:20px; font-size:14px;">${category}</div>
                        
                        <div style="width:100px; height:100px; background:${data.color}; border-radius:20px; margin:0 auto 20px; display:flex; align-items:center; justify-content:center; font-size:32px; position:relative; box-shadow:0 4px 16px rgba(0,0,0,0.3);">
                            <div style="position:absolute; top:15px; left:50%; transform:translateX(-50%); font-size:16px;">:D</div>
                            ${this.getEnemyEmoji(type)}
                        </div>
                        
                        <div style="background:rgba(255,255,255,0.1); border-radius:8px; padding:16px; margin-bottom:16px;">
                            <h3 style="color:#fff; margin-bottom:12px; font-size:16px;">기본 정보</h3>
                            <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px; color:#fff; font-size:14px;">
                                <div>체력: ${data.health}</div>
                                <div>속도: ${data.speed}</div>
                                <div>공격력: ${data.damage}</div>
                                <div>크기: ${data.size}</div>
                                <div>발사 간격: ${data.shootInterval}ms</div>
                                <div>점수: ${data.points}</div>
                            </div>
                        </div>
                        
                        <div style="background:rgba(255,255,255,0.1); border-radius:8px; padding:16px; margin-bottom:16px;">
                            <h3 style="color:#fff; margin-bottom:12px; font-size:16px;">설명</h3>
                            <p style="color:#fff; font-size:14px; line-height:1.5;">${data.description || this.getEnemyDescription(type) || '이 적에 대한 상세한 설명이 없습니다.'}</p>
                        </div>
                        
                        <div style="background:rgba(255,255,255,0.1); border-radius:8px; padding:16px; margin-bottom:16px;">
                            <h3 style="color:#fff; margin-bottom:12px; font-size:16px;">전투 정보</h3>
                            <div style="color:#fff; font-size:14px; line-height:1.6;">
                                <div style="margin-bottom:8px;"><strong>난이도:</strong> ${data.dexInfo ? data.dexInfo.difficulty : this.getEnemyDifficulty(type, data)}</div>
                                <div style="margin-bottom:8px;"><strong>능력:</strong> ${data.dexInfo ? data.dexInfo.abilities.join(', ') : this.getEnemyAbilities(type, data)}</div>
                                <div style="margin-bottom:8px;"><strong>전략:</strong> ${data.dexInfo ? data.dexInfo.strategy : this.getEnemyStrategy(type, data)}</div>
                                <div><strong>약점:</strong> ${data.dexInfo ? data.dexInfo.weakness : this.getEnemyWeakness(type, data)}</div>
                            </div>
                        </div>
                    </div>
                `;
            }

            // 적 설명 반환
            getEnemyDescription = (type, data) => {
                const descriptions = {
                    'basic': '가장 기본적인 적. 특별한 능력은 없지만 균형잡힌 스탯을 가지고 있습니다.',
                    'fast': '빠른 속도로 움직이며 자주 발사하는 적. 체력은 낮지만 회피하기 어려울 수 있습니다.',
                    'tank': '높은 체력과 공격력을 가진 중장갑 적. 느리지만 강력한 공격을 합니다.',
                    'sniper': '높은 공격력과 긴 사거리를 가진 저격 적. 발사 간격이 길지만 한 번 맞으면 큰 피해를 입습니다.',
                    'bomber': '강력한 폭발 공격을 하는 적. 체력은 보통이지만 공격력이 높습니다.',
                    'guardian': '매우 높은 체력과 강력한 공격력을 가진 정예 적. 처치하기 어렵지만 높은 점수를 제공합니다.',
                    'assassin': '매우 빠른 속도로 움직이며 자주 공격하는 적. 체력은 낮지만 회피하기 매우 어렵습니다.',
                    'heavy': '높은 체력과 강력한 공격력을 가진 중장갑 적. 매우 느리지만 한 번 맞으면 큰 피해를 입습니다.',
                    'ghost': '유령 능력을 가진 적. 투명해지거나 특수한 공격을 할 수 있습니다.',
                    'medic': '다른 적들을 치료하는 능력을 가진 적. 직접 공격력은 없지만 다른 적들을 강화시킵니다.',
                    'summoner': '다른 적들을 소환하는 능력을 가진 적. 직접 공격력은 낮지만 소환된 적들이 위험합니다.',
                    'jumper': '점프 능력을 가진 적. 갑자기 점프하여 예상치 못한 위치에서 공격할 수 있습니다.',
                    'shielded': '방패를 가진 적. 특정 방향에서의 공격을 막을 수 있습니다.',
                    'teleporter': '순간이동 능력을 가진 적. 갑자기 사라졌다가 다른 곳에서 나타날 수 있습니다.',
                    'drone': '매우 빠른 속도로 움직이는 드론. 체력은 낮지만 회피하기 매우 어렵습니다.',
                    'spitter': '슬라임 능력을 가진 적. 느려지는 효과를 가진 공격을 합니다.',
                    'berserker': '체력이 낮아지면 광분 상태가 되어 속도와 공격력이 증가하는 적.',
                    'mirror': '플레이어의 움직임을 따라하는 미러 적. 예측하기 어려운 패턴을 보입니다.',
                    'leech': '플레이어에게 닿으면 체력을 흡수하는 적. 근접 공격에 주의해야 합니다.',
                    'mine': '플레이어가 가까이 오면 폭발하는 지뢰 적. 접근하지 말고 원거리에서 처치하세요.',
                    'freezer': '플레이어를 맞추면 빙결시키는 적. 빙결 상태에서는 움직일 수 없습니다.',
                    'reflector': '플레이어의 탄환을 반사하는 적. 반사된 탄환에 주의하세요.',
                    'healer': '주변의 다른 적들을 치료하는 적. 우선 처치하는 것이 중요합니다.',
                    'portal': '순간이동 능력을 가진 적. 갑자기 플레이어 근처로 이동할 수 있습니다.',
                    'exploder': '사망 시 폭발하는 적. 죽일 때 거리를 두고 처치하세요.',
                    'magnet': '아이템을 끌어당기는 자석 능력을 가진 적. 아이템 수집에 방해가 됩니다.',
                    'curse': '플레이어에게 저주를 거는 적. 저주 상태에서는 다양한 디버프를 받습니다.',
                    'floater': '공중을 자유롭게 움직이는 적. 지상 장애물의 영향을 받지 않습니다.',
                    'phaser': '주기적으로 페이즈 상태가 되어 무적이 되는 적. 타이밍을 노려 공격하세요.',
                    'juggernaut': '공격력은 약하지만 엄청난 체력을 자랑하는 거대 적. 오랫동안 싸워야 합니다.',
                    'skyblaster': '하늘을 날며 한 번에 여러 발의 총알을 퍼뜨리는 탄막 적. 회피가 어렵습니다.',
                    'boss_alpha': '미니언 소환, 연속 돌진, 광역 충격파 능력을 가진 강력한 보스.',
                    'boss_beta': '쉴드, 탄막, 체력 회복 능력을 가진 방어형 보스.',
                    'boss_gamma': '순간이동, 레이저, 속도 버프 능력을 가진 공격형 보스.',
                    'boss_delta': '블랙홀, 광역 폭발, 플레이어 둔화 능력을 가진 마법형 보스.',
                    'boss_epsilon': '분신, 탄환 반사, 체력 흡수 능력을 가진 교활한 보스.',
                    'boss_zeta': '시간 왜곡, 연발 사격, 랜덤 이동 능력을 가진 시간 조작 보스.',
                    'boss_eta': '레이저, 연속 점프, 방어력 증가 능력을 가진 전투형 보스.',
                    'boss_theta': '발사체 반사, 도탄, 위치 추적 능력을 가진 반사형 보스.'
                };
                
                return descriptions[type] || data.description || '이 적에 대한 상세한 설명이 없습니다.';
            }

            // 적 난이도 반환
            getEnemyDifficulty = (type, data) => {
                const difficulties = {
                    'shielded': '★★★☆☆',
                    'teleporter': '★★★☆☆',
                    'drone': '★★★★☆',
                    'spitter': '★★☆☆☆',
                    'berserker': '★★★☆☆',
                    'mirror': '★★☆☆☆',
                    'leech': '★★☆☆☆',
                    'mine': '★★☆☆☆',
                    'freezer': '★★☆☆☆',
                    'reflector': '★★★☆☆',
                    'healer': '★★☆☆☆',
                    'portal': '★★★☆☆',
                    'exploder': '★★☆☆☆',
                    'magnet': '★★☆☆☆',
                    'curse': '★★☆☆☆',
                    'floater': '★★☆☆☆',
                    'phaser': '★★★☆☆',
                    'juggernaut': '★★★☆☆',
                    'skyblaster': '★★★☆☆',
                    'boss_alpha': '★★★★☆',
                    'boss_beta': '★★★★☆',
                    'boss_gamma': '★★★★☆',
                    'boss_delta': '★★★★★',
                    'boss_epsilon': '★★★★☆',
                    'boss_zeta': '★★★★☆',
                    'boss_eta': '★★★★★',
                    'boss_theta': '★★★★☆'
                };
                return difficulties[type] || '★★☆☆☆';
            }

            // 적 능력 반환
            getEnemyAbilities = (type, data) => {
                const abilities = {
                    'shielded': ['방패', '공격 방어'],
                    'teleporter': ['순간이동', '예측 불가능한 이동'],
                    'drone': ['매우 빠른 이동', '빠른 발사'],
                    'spitter': ['느려지는 공격', '디버프'],
                    'berserker': ['광분', '속도/공격력 증가'],
                    'mirror': ['플레이어 모방', '예측 불가능한 패턴'],
                    'leech': ['체력 흡수', '근접 공격'],
                    'mine': ['근접 폭발', '높은 데미지'],
                    'freezer': ['빙결', '이동 불가'],
                    'reflector': ['탄환 반사', '반격'],
                    'healer': ['적 치료', '지속적인 위협'],
                    'portal': ['순간이동', '근접 공격'],
                    'exploder': ['사망 폭발', '범위 데미지'],
                    'magnet': ['아이템 흡수', '자석 효과'],
                    'curse': ['저주', '디버프'],
                    'floater': ['공중 이동', '자유로운 움직임'],
                    'phaser': ['페이즈', '주기적 무적'],
                    'juggernaut': ['높은 체력', '지속 전투'],
                    'skyblaster': ['탄막', '다중 발사'],
                    'boss_alpha': ['미니언 소환', '연속 돌진', '광역 충격파'],
                    'boss_beta': ['쉴드', '탄막', '체력 회복'],
                    'boss_gamma': ['순간이동', '레이저', '속도 버프'],
                    'boss_delta': ['블랙홀', '광역 폭발', '플레이어 둔화'],
                    'boss_epsilon': ['분신', '탄환 반사', '체력 흡수'],
                    'boss_zeta': ['시간 왜곡', '연발 사격', '랜덤 이동'],
                    'boss_eta': ['레이저', '연속 점프', '방어력 증가'],
                    'boss_theta': ['발사체 반사', '도탄', '위치 추적']
                };
                return abilities[type] ? abilities[type].join(', ') : '기본 공격';
            }

            // 적 전략 반환
            getEnemyStrategy = (type, data) => {
                const strategies = {
                    'shielded': '방패로 특정 방향의 공격을 막습니다. 방패가 없는 방향에서 공격하세요.',
                    'teleporter': '순간이동으로 예상치 못한 위치에서 공격할 수 있습니다. 주변을 항상 주의하세요.',
                    'drone': '속도가 매우 빠르고 발사 간격이 짧아 가장 위험한 적 중 하나입니다. 우선 처치하는 것이 필수입니다.',
                    'spitter': '공격에 맞으면 느려지는 효과를 받습니다. 우선 처치하거나 거리를 두고 싸우세요.',
                    'berserker': '체력이 30% 이하로 떨어지면 광분 상태가 되어 위험해집니다. 빠르게 처치하세요.',
                    'mirror': '플레이어의 움직임을 따라하므로 예측하기 어려운 패턴을 보입니다. 패턴을 파악하세요.',
                    'leech': '플레이어에게 닿으면 체력을 흡수합니다. 근접 공격에 주의하고 원거리에서 처치하세요.',
                    'mine': '플레이어가 가까이 오면 폭발합니다. 접근하지 말고 원거리에서 처치하세요.',
                    'freezer': '플레이어를 맞추면 빙결시킵니다. 빙결 상태에서는 움직일 수 없으므로 주의하세요.',
                    'reflector': '플레이어의 탄환을 반사할 수 있습니다. 반사된 탄환에 주의하세요.',
                    'healer': '주변의 다른 적들을 치료합니다. 우선 처치하는 것이 중요합니다.',
                    'portal': '갑자기 플레이어 근처로 순간이동할 수 있습니다. 주변을 항상 주의하세요.',
                    'exploder': '사망 시 폭발합니다. 죽일 때 거리를 두고 처치하세요.',
                    'magnet': '아이템을 끌어당겨 아이템 수집에 방해가 됩니다. 우선 처치하세요.',
                    'curse': '플레이어에게 저주를 걸어 다양한 디버프를 줍니다. 저주 상태에 주의하세요.',
                    'floater': '공중을 자유롭게 움직입니다. 지상 장애물의 영향을 받지 않습니다.',
                    'phaser': '주기적으로 페이즈 상태가 되어 무적이 됩니다. 타이밍을 노려 공격하세요.',
                    'juggernaut': '체력이 매우 높아 오랫동안 싸워야 합니다. 지속적인 공격이 필요합니다.',
                    'skyblaster': '한 번에 여러 발의 총알을 퍼뜨려 회피가 어렵습니다. 탄막에 주의하세요.',
                    'boss_alpha': '미니언을 소환하고 연속 돌진과 광역 충격파를 사용합니다. 패턴을 파악하세요.',
                    'boss_beta': '쉴드로 방어하고 탄막을 발사하며 체력을 회복합니다. 쉴드가 없을 때 공격하세요.',
                    'boss_gamma': '순간이동과 레이저, 속도 버프를 사용합니다. 레이저에 특히 주의하세요.',
                    'boss_delta': '블랙홀과 광역 폭발, 플레이어 둔화를 사용합니다. 가장 위험한 보스 중 하나입니다.',
                    'boss_epsilon': '분신을 생성하고 탄환을 반사하며 체력을 흡수합니다. 교활한 전략을 사용합니다.',
                    'boss_zeta': '시간을 왜곡하고 연발 사격과 랜덤 이동을 합니다. 시간 왜곡에 주의하세요.',
                    'boss_eta': '레이저와 연속 점프, 방어력 증가를 사용합니다. 가장 강력한 보스 중 하나입니다.',
                    'boss_theta': '발사체를 반사하고 도탄 탄환과 위치 추적을 사용합니다. 반사된 발사체에 주의하세요.'
                };
                return strategies[type] || '기본적인 전투 패턴을 보입니다.';
            }

            // 적 약점 반환
            getEnemyWeakness = (type, data) => {
                const weaknesses = {
                    'shielded': '속도가 매우 느리고 방패가 모든 방향을 막지 못함',
                    'teleporter': '체력이 낮고 순간이동 후 공격까지 시간이 필요',
                    'drone': '체력이 매우 낮아 한 번의 공격으로 처치 가능',
                    'spitter': '체력이 보통이고 기본 공격력이 낮음',
                    'berserker': '광분 전에는 일반적인 적과 비슷함',
                    'mirror': '체력이 낮고 예측 가능한 패턴이 있음',
                    'leech': '체력이 낮고 근접 공격만 가능',
                    'mine': '체력이 매우 낮고 접근해야만 위험함',
                    'freezer': '체력이 낮고 공격력이 보통임',
                    'reflector': '체력이 보통이고 반사 확률이 30%로 제한적',
                    'healer': '직접 공격력이 없고 체력이 보통임',
                    'portal': '체력이 낮고 순간이동 후 공격까지 시간이 필요',
                    'exploder': '체력이 낮고 사망 시에만 위험함',
                    'magnet': '체력이 낮고 직접적인 공격력이 없음',
                    'curse': '체력이 낮고 공격력이 낮음',
                    'floater': '체력이 보통이고 특별한 방어 능력이 없음',
                    'phaser': '페이즈 상태가 아닐 때는 일반적인 적과 비슷함',
                    'juggernaut': '공격력이 매우 낮고 속도가 느림',
                    'skyblaster': '체력이 보통이고 탄막 패턴이 예측 가능함',
                    'boss_alpha': '속도가 느리고 패턴이 예측 가능함',
                    'boss_beta': '쉴드가 없을 때는 일반적인 보스와 비슷함',
                    'boss_gamma': '체력이 상대적으로 낮고 레이저 사용 시 무방비',
                    'boss_delta': '스킬 사용 후 쿨다운 시간이 있음',
                    'boss_epsilon': '분신은 체력이 낮고 반사 상태가 아닐 때는 일반적',
                    'boss_zeta': '시간 왜곡 사용 후 쿨다운 시간이 있음',
                    'boss_eta': '속도가 느리고 점프 후 착지 시 무방비',
                    'boss_theta': '반사 상태가 아닐 때는 일반적인 보스와 비슷함'
                };
                return weaknesses[type] || '특별한 약점이 없습니다.';
            }

            // 적 이모지 반환
            getEnemyEmoji = (type) => {
                const emojiMap = {
                    'boss': '👑',
                    'boss_alpha': '🦁',
                    'boss_beta': '🛡️',
                    'boss_gamma': '⚡',
                    'boss_delta': '🌀',
                    'boss_epsilon': '🔄',
                    'boss_zeta': '⏰',
                    'boss_eta': '💥',
                    'boss_theta': '🎯',
                    'basic': '👾',
                    'fast': '🏃',
                    'tank': '🛡️',
                    'sniper': '🎯',
                    'bomber': '💣',
                    'guardian': '🛡️',
                    'assassin': '🗡️',
                    'heavy': '⚔️',
                    'ghost': '👻',
                    'medic': '💊',
                    'summoner': '🔮',
                    'jumper': '🦘',
                    'shielded': '🛡️',
                    'teleporter': '🌀',
                    'drone': '🚁',
                    'spitter': '🟢',
                    'berserker': '😤',
                    'mirror': '🪞',
                    'leech': '🩸',
                    'mine': '💣',
                    'freezer': '❄️',
                    'reflector': '🪩',
                    'healer': '💚',
                    'portal': '🚪',
                    'exploder': '💥',
                    'magnet': '🧲',
                    'curse': '👹',
                    'floater': '🎈',
                    'phaser': '✨'
                };
                return emojiMap[type] || '👾';
            }

            // 테스트 존 업데이트
            updateTestZone = () => {
                const enemySpawnList = document.getElementById('enemySpawnList');
                const bossSpawnList = document.getElementById('bossSpawnList');
                const abilityList = document.getElementById('abilityList');
                
                enemySpawnList.innerHTML = '';
                bossSpawnList.innerHTML = '';
                abilityList.innerHTML = '';
                
                // 적 소환 목록 생성
                Object.entries(this.ENEMY_TYPES).forEach(([type, data]) => {
                    if (!type.startsWith('boss')) {
                        const enemyDiv = document.createElement('div');
                        enemyDiv.style.display = 'flex';
                        enemyDiv.style.justifyContent = 'space-between';
                        enemyDiv.style.alignItems = 'center';
                        enemyDiv.style.margin = '8px 0';
                        enemyDiv.style.padding = '8px';
                        enemyDiv.style.background = 'rgba(255,255,255,0.1)';
                        enemyDiv.style.borderRadius = '6px';
                        enemyDiv.style.color = '#222';
                        
                        const label = document.createElement('span');
                        label.textContent = data.name;
                        label.style.fontSize = '14px';
                        
                        const spawnBtn = document.createElement('button');
                        spawnBtn.textContent = '소환';
                        spawnBtn.style.background = '#ff6b6b';
                        spawnBtn.style.color = '#fff';
                        spawnBtn.style.border = 'none';
                        spawnBtn.style.borderRadius = '4px';
                        spawnBtn.style.padding = '4px 12px';
                        spawnBtn.style.cursor = 'pointer';
                        spawnBtn.style.fontSize = '12px';
                        
                        spawnBtn.onclick = () => {
                            const enemy = this.createEnemy(type);
                            enemy.x = Math.random() * (this.canvas.width - 100) + 50;
                            enemy.y = Math.random() * (this.canvas.height - 200) + 50;
                            this.gameState.enemies.push(enemy);
                            this.showMessage(`${data.name} 소환!`, '', 1500);
                        };
                        
                        enemyDiv.appendChild(label);
                        enemyDiv.appendChild(spawnBtn);
                        enemySpawnList.appendChild(enemyDiv);
                    }
                });
                
                // 보스 소환 목록 생성
                Object.entries(this.ENEMY_TYPES).forEach(([type, data]) => {
                    if (type.startsWith('boss')) {
                        const bossDiv = document.createElement('div');
                        bossDiv.style.display = 'flex';
                        bossDiv.style.justifyContent = 'space-between';
                        bossDiv.style.alignItems = 'center';
                        bossDiv.style.margin = '8px 0';
                        bossDiv.style.padding = '8px';
                        bossDiv.style.background = 'rgba(255,255,255,0.1)';
                        bossDiv.style.borderRadius = '6px';
                        bossDiv.style.color = '#222';
                        
                        const label = document.createElement('span');
                        label.textContent = data.name;
                        label.style.fontSize = '14px';
                        label.style.fontWeight = 'bold';
                        
                        const spawnBtn = document.createElement('button');
                        spawnBtn.textContent = '소환';
                        spawnBtn.style.background = '#dc2626';
                        spawnBtn.style.color = '#fff';
                        spawnBtn.style.border = 'none';
                        spawnBtn.style.borderRadius = '4px';
                        spawnBtn.style.padding = '4px 12px';
                        spawnBtn.style.cursor = 'pointer';
                        spawnBtn.style.fontSize = '12px';
                        
                        spawnBtn.onclick = () => {
                            const boss = this.createBoss(type);
                            boss.x = this.canvas.width / 2;
                            boss.y = this.canvas.height / 2;
                            this.gameState.enemies.push(boss);
                            this.showMessage(`${data.name} 소환!`, '강력한 보스가 나타났습니다!', 2000);
                        };
                        
                        bossDiv.appendChild(label);
                        bossDiv.appendChild(spawnBtn);
                        bossSpawnList.appendChild(bossDiv);
                    }
                });
                
                // 능력 부여 목록 생성
                const abilities = [
                    { name: '무적 (5초)', type: 'invincibility', value: 5000 },
                    { name: '쉴드 강화 (10초)', type: 'shield_boost', value: 10000 },
                    { name: '시간 정지 (3초)', type: 'time_stop', value: 3000 },
                    { name: '자석 효과 (8초)', type: 'magnet', value: 8000 },
                    { name: '체력 재생 (10초)', type: 'health_regen', value: 10000 },
                    { name: '연발 모드 (5초)', type: 'rapid', value: 5000 },
                    { name: '관통 사격', type: 'piercing_shot', value: 1 },
                    { name: '폭발 사격', type: 'explosive_shot', value: 1 },
                    { name: '회전 칼날', type: 'orbiting_knife', value: 1 },
                    { name: '도탄 사격', type: 'ricochet_shot', value: 1 },
                    { name: '유도 사격', type: 'homing_shot', value: 1 },
                    { name: '분열 사격', type: 'split_shot', value: 1 },
                    { name: '생명력 흡수', type: 'life_steal', value: 0.05 },
                    { name: '치명타 확률', type: 'crit_chance', value: 0.05 },
                    { name: '재사용 대기시간 감소', type: 'cooldown_reduction', value: 0.05 },
                    { name: '방어력', type: 'armor', value: 5 },
                    { name: '탄약 재생 (5초)', type: 'ammo_regen', value: 5000 },
                    { name: '다중 발사 +1', type: 'multishot', value: 1 },
                    { name: '공격력 +10', type: 'damage', value: 10 },
                    { name: '속도 +1', type: 'speed', value: 1 },
                    { name: '체력 +50', type: 'health', value: 50 },
                    { name: '최대 체력 +50', type: 'max_health', value: 50 },
                    { name: '탄약 +10', type: 'ammo', value: 10 },
                    { name: '최대 탄약 +10', type: 'max_ammo', value: 10 }
                ];
                
                abilities.forEach(ability => {
                    const abilityDiv = document.createElement('div');
                    abilityDiv.style.display = 'flex';
                    abilityDiv.style.justifyContent = 'space-between';
                    abilityDiv.style.alignItems = 'center';
                    abilityDiv.style.margin = '8px 0';
                    abilityDiv.style.padding = '8px';
                    abilityDiv.style.background = 'rgba(255,255,255,0.1)';
                    abilityDiv.style.borderRadius = '6px';
                    abilityDiv.style.color = '#222';
                    
                    const label = document.createElement('span');
                    label.textContent = ability.name;
                    label.style.fontSize = '14px';
                    
                    const applyBtn = document.createElement('button');
                    applyBtn.textContent = '부여';
                    applyBtn.style.background = '#6366f1';
                    applyBtn.style.color = '#fff';
                    applyBtn.style.border = 'none';
                    applyBtn.style.borderRadius = '4px';
                    applyBtn.style.padding = '4px 12px';
                    applyBtn.style.cursor = 'pointer';
                    applyBtn.style.fontSize = '12px';
                    
                    applyBtn.onclick = () => {
                        this.applyReward(ability.type, ability.value);
                        this.showMessage(`${ability.name} 부여!`, '', 1500);
                    };
                    
                    abilityDiv.appendChild(label);
                    abilityDiv.appendChild(applyBtn);
                    abilityList.appendChild(abilityDiv);
                });
            };

            // 테스트 존 HUD 버튼 추가
            addTestZoneButtonToHUD = () => {
                const testZoneHUDButton = document.getElementById('testZoneHUDButton');
                testZoneHUDButton.style.display = 'inline-block';
                
                // 테스트 존 버튼 클릭 이벤트
                testZoneHUDButton.onclick = () => {
                    const testZonePopup = document.getElementById('testZonePopup');
                    if (testZonePopup.style.display === 'block') {
                        testZonePopup.style.display = 'none';
                    } else {
                        testZonePopup.style.display = 'block';
                        this.updateTestZone();
                    }
                };
            };

            // 모바일 컨트롤 초기화
            initMobileControls = () => {
                const joystick = document.getElementById('joystickContainer');
                const joystickThumb = document.getElementById('joystickThumb');
                const aimJoystick = document.getElementById('aimJoystickContainer');
                const aimJoystickThumb = document.getElementById('aimJoystickThumb');
                const fireButton = document.getElementById('fireButton');
                const jumpButton = document.getElementById('jumpButton');
                const reloadButton = document.getElementById('reloadButton');

                if (!joystick || !aimJoystick || !fireButton || !jumpButton || !reloadButton) {
                    console.error('Mobile control elements not found');
                    return;
                }

                // 조이스틱 이벤트
                joystick.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const rect = joystick.getBoundingClientRect();
                    this.touchControls.joystick.centerX = rect.left + rect.width / 2;
                    this.touchControls.joystick.centerY = rect.top + rect.height / 2;
                    this.touchControls.joystick.active = true;
                    this.updateJoystick(touch.clientX, touch.clientY);
                });

                joystick.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (this.touchControls.joystick.active) {
                        const touch = e.touches[0];
                        this.updateJoystick(touch.clientX, touch.clientY);
                    }
                });

                joystick.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.touchControls.joystick.active = false;
                    this.touchControls.joystick.x = 0;
                    this.touchControls.joystick.y = 0;
                    if (joystickThumb) {  // joystickThumb 사용
                        joystickThumb.style.left = '50%';
                        joystickThumb.style.top = '50%';
                    }
                });

                aimJoystick.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const rect = aimJoystick.getBoundingClientRect();
                    this.touchControls.aimJoystick = { centerX: rect.left + rect.width / 2, centerY: rect.top + rect.height / 2, active: true, x: 0, y: 0 };
                    this.updateAimJoystick(touch.clientX, touch.clientY);
                });
                aimJoystick.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (this.touchControls.aimJoystick && this.touchControls.aimJoystick.active) {
                        const touch = e.touches[0];
                        this.updateAimJoystick(touch.clientX, touch.clientY);
                    }
                });
                aimJoystick.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    if (this.touchControls.aimJoystick) {
                        this.touchControls.aimJoystick.active = false;
                        this.touchControls.aimJoystick.x = 0;
                        this.touchControls.aimJoystick.y = 0;
                        if (aimJoystickThumb) {
                            aimJoystickThumb.style.left = '50%';
                            aimJoystickThumb.style.top = '50%';
                        }
                    }
                });

                // 발사 버튼 이벤트
                fireButton.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.touchControls.fireButton.pressed = true;
                });

                fireButton.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.touchControls.fireButton.pressed = false;
                });

                // 점프 버튼 이벤트
                jumpButton.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.touchControls.jumpButton.pressed = true;
                });

                jumpButton.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.touchControls.jumpButton.pressed = false;
                });

                // 재장전 버튼 이벤트
                reloadButton.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.touchControls.reloadButton.pressed = true;
                    if (this.gameState.gameStatus === 'playing') {
                        this.reload();
                    }
                });

                reloadButton.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.touchControls.reloadButton.pressed = false;
                });

                // 조준 영역 이벤트
            };

            // 조이스틱 업데이트
            updateJoystick = (touchX, touchY) => {
                const dx = touchX - this.touchControls.joystick.centerX;
                const dy = touchY - this.touchControls.joystick.centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const maxDistance = 50;

                if (distance > maxDistance) {
                    const angle = Math.atan2(dy, dx);
                    this.touchControls.joystick.x = Math.cos(angle) * maxDistance;
                    this.touchControls.joystick.y = Math.sin(angle) * maxDistance;
                } else {
                    this.touchControls.joystick.x = dx;
                    this.touchControls.joystick.y = dy;
                }

                // 조이스틱 썸 이동
                const joystickThumb = document.getElementById('joystickThumb');
                if (joystickThumb) {
                    const knobX = 50 + (this.touchControls.joystick.x / maxDistance) * 50;
                    const knobY = 50 + (this.touchControls.joystick.y / maxDistance) * 50;
                    joystickThumb.style.left = knobX + '%';
                    joystickThumb.style.top = knobY + '%';
                }

                // 디버깅용 콘솔 출력
                console.log('Joystick:', this.touchControls.joystick.x, this.touchControls.joystick.y);
            };

            updateAimJoystick = (touchX, touchY) => {
                const dx = touchX - this.touchControls.aimJoystick.centerX;
                const dy = touchY - this.touchControls.aimJoystick.centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const maxDistance = 50;
                if (distance > maxDistance) {
                    const angle = Math.atan2(dy, dx);
                    this.touchControls.aimJoystick.x = Math.cos(angle) * maxDistance;
                    this.touchControls.aimJoystick.y = Math.sin(angle) * maxDistance;
                } else {
                    this.touchControls.aimJoystick.x = dx;
                    this.touchControls.aimJoystick.y = dy;
                }
                const aimJoystickThumb = document.getElementById('aimJoystickThumb');
                if (aimJoystickThumb) {
                    const knobX = 50 + (this.touchControls.aimJoystick.x / maxDistance) * 50;
                    const knobY = 50 + (this.touchControls.aimJoystick.y / maxDistance) * 50;
                    aimJoystickThumb.style.left = knobX + '%';
                    aimJoystickThumb.style.top = knobY + '%';
                }
            };
            // 모바일 컨트롤 비활성화
            disableMobileControls = () => {
                this.touchControls.joystick.active = false;
                this.touchControls.joystick.x = 0;
                this.touchControls.joystick.y = 0;
                this.touchControls.fireButton.pressed = false;
                this.touchControls.jumpButton.pressed = false;
                this.touchControls.reloadButton.pressed = false;

                const joystickThumb = document.getElementById('joystickThumb');
                if (joystickThumb) {
                    joystickThumb.style.left = '50%';
                    joystickThumb.style.top = '50%';
                }
            };
        }

        let bossRushMode = false;


        // === Add after GlassCombatArena class definition or at the end of the script ===
        window.onload = function() {
            const soloModeSelect = document.getElementById('soloModeSelect');
            const normalModeButton = document.getElementById('normalModeButton');
            const bossRushModeButton = document.getElementById('bossRushModeButton');
            const backToIntroFromSolo = document.getElementById('backToIntroFromSolo');
            const introScreen = document.getElementById('introScreen');

            // 멀티플레이 버튼 및 팝업 관련 변수
            const multiButton = document.getElementById('multiButton');
            const multiJoinPopup = document.getElementById('multiJoinPopup');
            const multiJoinBtn = document.getElementById('multiJoinBtn');
            const multiJoinCancel = document.getElementById('multiJoinCancel');
            let myNick = "";
            let roomId = "";
            let myState = { x: 100, y: 100, health: 100 };
            let otherPlayers = {};

            var onlineBtn = document.getElementById('onlineMultiplayerButton');
                if (onlineBtn) {
                    onlineBtn.onclick = function() {
                        document.getElementById('onlineMultiplayerPopup').style.display = 'block';
                    };
                }
                var closeOnlineBtn = document.getElementById('closeOnlineMultiplayerPopup');
                if (closeOnlineBtn) {
                    closeOnlineBtn.onclick = function() {
                        document.getElementById('onlineMultiplayerPopup').style.display = 'none';
                    };
                }

            multiButton.onclick = function() {
                introScreen.style.display = 'none';
                multiJoinPopup.style.display = 'block';
                // 멀티플레이 모드 선택/설정 UI 숨김
                document.getElementById('multiplayerModeSelect').style.display = 'none';
                document.getElementById('leaderSetup').style.display = 'none';
                document.getElementById('hybridSetup').style.display = 'none';
                };
                multiJoinCancel.onclick = function() {
                multiJoinPopup.style.display = 'none';
                introScreen.style.display = 'flex';
                };


            multiJoinBtn.onclick = function() {
                myNick = document.getElementById('multiNickname').value.trim();
                roomId = document.getElementById('multiRoomId').value.trim();
                if (!myNick || !roomId) return alert("닉네임과 방 코드를 입력하세요!");
                multiJoinPopup.style.display = 'none';

                // 내 상태 DB에 등록
                db.ref(`rooms/${roomId}/players/${myNick}`).set(myState);

                // 상대방 상태 실시간 감지
                db.ref(`rooms/${roomId}/players`).on('value', (snap) => {
                    const players = snap.val() || {};
                    otherPlayers = {};
                    Object.keys(players).forEach(nick => {
                    if (nick !== myNick) {
                        otherPlayers[nick] = players[nick];
                    }
                    });
                    // === 실제 게임 오브젝트에 반영 ===
                    // 상대방이 있으면 player2로, 없으면 player2 숨김
                    const otherNicks = Object.keys(otherPlayers);
                    if (otherNicks.length > 0) {
                    const other = otherPlayers[otherNicks[0]];
                    if (!window.game.gameState.player2) {
                        // player2 객체 생성 (게임 구조에 맞게)
                        window.game.gameState.player2 = {
                        x: other.x, y: other.y, width: 40, height: 40, health: other.health, maxHealth: 100, color: '#ef4444', type: 'player2',
                        ammo: 30, maxAmmo: 30, speed: 5, baseDamage: 10, multishot: 1
                        };
                        document.getElementById('player2HUD').style.display = 'flex';
                    } else {
                        window.game.gameState.player2.x = other.x;
                        window.game.gameState.player2.y = other.y;
                        window.game.gameState.player2.health = other.health;
                    }
                    } else {
                    window.game.gameState.player2 = null;
                    document.getElementById('player2HUD').style.display = 'none';
                    }
                });

                // 내 상태를 주기적으로 DB에 반영 (0.1초마다)
                if (window.syncInterval) clearInterval(window.syncInterval);
                window.syncInterval = setInterval(() => {
                    if (window.game && window.game.gameState && window.game.gameState.player) {
                    myState.x = window.game.gameState.player.x;
                    myState.y = window.game.gameState.player.y;
                    myState.health = window.game.gameState.player.health;
                    db.ref(`rooms/${roomId}/players/${myNick}`).set(myState);
                    }
                }, 100);
                };
            // 방 나가기(새로고침/닫기 시 내 데이터 삭제)
            window.addEventListener('beforeunload', function() {
                if (myNick && roomId) {
                    db.ref(`rooms/${roomId}/players/${myNick}`).remove();
                }
                });

            document.getElementById('soloButton').onclick = function() {
            introScreen.style.display = 'none';
            soloModeSelect.style.display = 'flex';
            };
            normalModeButton.onclick = function() {
            bossRushMode = false;
            soloModeSelect.style.display = 'none';
            if (window.game && typeof window.game.startGame === 'function') {
                window.game.startGame();
            }
            };
            bossRushModeButton.onclick = function() {
            bossRushMode = true;
            soloModeSelect.style.display = 'none';
            if (window.game && typeof window.game.startGame === 'function') {
                window.game.startGame();
            }
            };
            backToIntroFromSolo.onclick = function() {
            soloModeSelect.style.display = 'none';
            introScreen.style.display = 'flex';
            };


          document.getElementById('startScreen').style.display = 'none';
          document.getElementById('introScreen').style.display = 'flex';

          // Attach event listener to Solo Play button
          document.getElementById('soloButton').onclick = function() {
            document.getElementById('introScreen').style.display = 'none';
            document.getElementById('soloModeSelect').style.display = 'flex';
          };
          
          // 멀티플레이 버튼 클릭 시 멀티플레이 모드 선택 화면 표시
          document.getElementById('multiButton').onclick = function() {
            document.getElementById('introScreen').style.display = 'none';
            document.getElementById('multiplayerModeSelect').style.display = 'flex';
          };
          
          // 리더 시스템 선택
          document.getElementById('leaderSystemButton').onclick = function() {
            document.getElementById('multiplayerModeSelect').style.display = 'none';
            document.getElementById('leaderSetup').style.display = 'flex';
          };
          
          // 하이브리드 시스템 선택
          document.getElementById('hybridSystemButton').onclick = function() {
            document.getElementById('multiplayerModeSelect').style.display = 'none';
            document.getElementById('hybridSetup').style.display = 'flex';
          };
          
          // 리더 시스템 설정 완료
          document.getElementById('leaderStartButton').onclick = function() {
            const leaderColor = document.getElementById('leaderColor').value;
            const followerColor = document.getElementById('followerColor').value;
            const leaderName = document.getElementById('leaderName').value || '리더';
            const followerName = document.getElementById('followerName').value || '따르는자';
            
            document.getElementById('leaderSetup').style.display = 'none';
            if (window.game && typeof window.game.startMultiplayerGame === 'function') {
              window.game.startMultiplayerGame('leader', {
                leaderColor: leaderColor,
                followerColor: followerColor,
                leaderName: leaderName,
                followerName: followerName
              });
            }
          };
          
          // 하이브리드 시스템 설정 완료
          document.getElementById('hybridStartButton').onclick = function() {
            const player1Color = document.getElementById('player1Color').value;
            const player2Color = document.getElementById('player2Color').value;
            const player1Name = document.getElementById('player1Name').value || '플레이어1';
            const player2Name = document.getElementById('player2Name').value || '플레이어2';
            const hybridPlayer = document.getElementById('hybridPlayer').value; // 'player1' or 'player2'
            
            document.getElementById('hybridSetup').style.display = 'none';
            if (window.game && typeof window.game.startMultiplayerGame === 'function') {
              window.game.startMultiplayerGame('hybrid', {
                player1Color: player1Color,
                player2Color: player2Color,
                player1Name: player1Name,
                player2Name: player2Name,
                hybridPlayer: hybridPlayer
              });
            }
          };
          
          // 뒤로가기 버튼들
          document.getElementById('backToIntro').onclick = function() {
            document.getElementById('multiplayerModeSelect').style.display = 'none';
            document.getElementById('introScreen').style.display = 'flex';
          };
          
          document.getElementById('backToModeSelect').onclick = function() {
            document.getElementById('leaderSetup').style.display = 'none';
            document.getElementById('hybridSetup').style.display = 'none';
            document.getElementById('multiplayerModeSelect').style.display = 'flex';
          };
          
          // 테스팅 존 버튼 이벤트 리스너
          document.getElementById('testZoneButton').onclick = function() {
            document.getElementById('introScreen').style.display = 'none';
            if (window.game && typeof window.game.startTestZone === 'function') {
              window.game.startTestZone();
            }
          };
          // 상점 토글 이벤트 리스너
          document.getElementById('shopButton').onclick = function() {
            const shopPopup = document.getElementById('shopPopup');
            if (shopPopup.style.display === 'block') {
              shopPopup.style.display = 'none';
            } else {
              shopPopup.style.display = 'block';
              window.game.updateShopList();
            }
          };
          document.getElementById('returnToMenuButton').onclick = function() {
            window.game.returnToMainMenu();
          };
          // 퀘스트 버튼 열기
          document.getElementById('questButton').onclick = function() {
            document.getElementById('questPopup').style.display = 'block';
            document.getElementById('questList').innerHTML = '<div>예시 퀘스트: 5웨이브 돌파<br>예시 퀘스트: 2000점 달성<br>예시 퀘스트: 보스 처치</div>';
          };
          // 퀘스트 팝업 닫기
          document.getElementById('closeQuestButton').onclick = function() {
            document.getElementById('questPopup').style.display = 'none';
          };
        };

        // === GlassCombatArena 클래스 정의 끝난 후 ===
        window.game = new GlassCombatArena();

        // 모바일 모드 체크박스 이벤트 리스너 설정
        const mobileModeCheckbox = document.getElementById('mobileModeCheckbox');
        if (mobileModeCheckbox) {
            mobileModeCheckbox.addEventListener('change', function() {
                if (window.game) {
                    window.game.mobileMode = this.checked;
                    const mobileControls = document.getElementById('mobileControls');
                    if (this.checked) {
                        mobileControls.style.display = 'block';
                        window.game.initMobileControls();
                    } else {
                        mobileControls.style.display = 'none';
                        window.game.disableMobileControls();
                    }
                }
            });
        }
        (function() {
        const db = firebase.database();
        const createRoomButton = document.getElementById('createRoomButton');
        const roomNameInput = document.getElementById('roomNameInput');
        const roomListDiv = document.getElementById('roomList');
        let myPlayerName = null;
        let myRoomKey = null;
        let lobbyUnsub = null;

        // 입장 버튼(이름 입력 후)
        document.getElementById('enterRoomButton').onclick = function() {
            const playerName = document.getElementById('playerNameInput').value.trim();
            if (!playerName) return alert('이름을 입력하세요!');
            if (!selectedRoomKey) return alert('방이 선택되지 않았습니다.');
            myPlayerName = playerName;
            myRoomKey = selectedRoomKey;
            // Firebase에 플레이어 등록
            db.ref(`rooms/${myRoomKey}/players/${myPlayerName}`).set({
                ready: false,
                joinedAt: Date.now()
            });
            document.getElementById('enterRoomPopup').style.display = 'none';
            openLobby();
        };

        // 로비 열기 함수
        function openLobby() {
            document.getElementById('roomLobbyPopup').style.display = 'block';
            document.getElementById('lobbyRoomName').textContent = '방 이름: ' + (roomListDiv.querySelector(`[data-key='${myRoomKey}'] b`)?.textContent || '');
            // 실시간 플레이어 목록/준비 상태 표시
            if (lobbyUnsub) lobbyUnsub.off();
            lobbyUnsub = db.ref(`rooms/${myRoomKey}/players`);
            lobbyUnsub.on('value', snap => {
                const players = snap.val() || {};
                let html = '';
                let allReady = true;
                Object.entries(players).forEach(([name, info]) => {
                    html += `<div>${name} ${info.ready ? '✅' : '❌'}</div>`;
                    if (!info.ready) allReady = false;
                });
                document.getElementById('lobbyPlayerList').innerHTML = html || '<div style="opacity:0.7;">플레이어 없음</div>';
                // 모두 준비 완료 시
                if (Object.keys(players).length > 0 && allReady) {
                    document.getElementById('lobbyStatusMsg').textContent = '모두 준비 완료! 게임이 곧 시작됩니다...';
                    setTimeout(() => {
                        document.getElementById('roomLobbyPopup').style.display = 'none';
                        // === 여기서 게임 시작 함수 호출 ===
                        if (window.game && typeof window.game.startGame === 'function') {
                            window.game.startGame();
                        }
                    }, 1200);
                } else {
                    document.getElementById('lobbyStatusMsg').textContent = '';
                }
            });
        }

        // 준비 버튼
        document.getElementById('readyButton').onclick = function() {
            if (!myRoomKey || !myPlayerName) return;
            db.ref(`rooms/${myRoomKey}/players/${myPlayerName}/ready`).set(true);
            this.disabled = true;
            this.textContent = '준비 완료';
        };

        // 나가기 버튼
        document.getElementById('leaveLobbyButton').onclick = function() {
            if (myRoomKey && myPlayerName) {
                db.ref(`rooms/${myRoomKey}/players/${myPlayerName}`).remove();
            }
            document.getElementById('roomLobbyPopup').style.display = 'none';
            myRoomKey = null;
            myPlayerName = null;
            if (lobbyUnsub) lobbyUnsub.off();
        };

        // 새로고침/닫기 시 방에서 나가기
        window.addEventListener('beforeunload', function() {
            if (myRoomKey && myPlayerName) {
                db.ref(`rooms/${myRoomKey}/players/${myPlayerName}`).remove();
            }
        });
    })();
    </script>
</body>
</html>
